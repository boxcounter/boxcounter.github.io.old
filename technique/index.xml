<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Techniques on Boxcounter的烂笔头</title>
    <link>http://boxcounter.com/technique/</link>
    <description>Recent content in Techniques on Boxcounter的烂笔头</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 Jan 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://boxcounter.com/technique/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>一起疑似内存泄漏</title>
      <link>http://boxcounter.com/technique/2014-01-12-suspected-memory-leak/</link>
      <pubDate>Sun, 12 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2014-01-12-suspected-memory-leak/</guid>
      <description>&lt;p&gt;上周遇到一起极其诡异的内存泄漏。现象是：&lt;br /&gt;
　　某种测试方法可以使程序物理内存使用量（top命令的RES列）持续上升。当停止测试之后，程序内存使用量稳定在测试过程中的最高值不变。从现象上看就是一典型的内存泄漏。&lt;/p&gt;

&lt;p&gt;　　我的诊断步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用valgrind的memcheck检查泄漏。故障重现后让程序自然退出。memcheck提示资源泄漏量为0.&lt;br /&gt;
  所以，该内存应该没有被泄漏，程序中对它们还有引用，在程序退出时被正常释放掉了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用valgrind的massif分析内存使用。找到了一处可疑的「泄漏」点，90%的内存都是在该处分配。&lt;br /&gt;
  但是调试发现该处分配（通过malloc）的内存都被正确的释放（通过free）掉了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用malloc_info函数查看程序运行过程中的内存情况。
  这是在程序物理内存占用2G后我停止测试以后一段时间（大概5分钟）的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arena(462848), ordblks(2), smblks(1), hblks(5), hblkhd(104857600), usmblks(0), fsmblks(32), uordblks(459424), fordblks(3424), keepcost(3360).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面看，从heap中申请了462848(arena的值，约46KB)，mmap申请的内存是104857600（hblkhd的值，约100MB）。这俩值加在一起和top里显示的2G差很远啊。
  注，arena和hblkhd的man注解：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arena   The total amount of memory allocated by means other than
        mmap(2) (i.e., memory allocated on the heap).  This figure
        includes both in-use blocks and blocks on the free list.
hblkhd  The number of bytes in blocks currently allocated using
        mmap(2).
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;决定统计内存分配释放的次数和尺寸，目的是检查是否严重失衡。因为new/delete不太好跟踪，所以只处理了malloc/free。&lt;br /&gt;
  使用的方法是wrap（gcc/g++的「-Wl,&amp;ndash;wrap,malloc」选项），看了一眼glibc的源码，以在free时候得到待释放内存的尺寸。最后的结果是没有严重失衡，应该不是显式的内存释放。&lt;br /&gt;
  其实这个实验原本就没有报很大的希望，一来new/delete没有照顾到，不够精确。二来如果是显式的泄漏memcheck早就报告了。但是当时没有思路了，姑且一试，看能不能找到点面包屑。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;搜索了一些资料。有些提到glibc内部使用brk和mmap来进行内存分配，其中brk可能会造成这种泄漏假象。&lt;br /&gt;
  于是在程序的开始设置了M_MMAP_THRESHOLD，发现故障依然存在。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mallopt(M_MMAP_THRESHOLD, 1024*1024*1024); // 1G
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　原本还想在不同的模块里使用不同的堆，然后反复根据堆的尺寸细分堆，来精确定位。却发现linux下没有类似HeapCreate的函数。&lt;/p&gt;

&lt;p&gt;　　技穷了。于是我邀请一位同事来协助分析，在协作中我发现我犯了个错误：尝试方法5的时候，我理解反了M_MMAP_THRESHOLD的含义，于是提供错了参数。实际上应该是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mallopt(M_MMAP_THRESHOLD, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　然后故障消失了。也就是说，这次的故障实际并不是我们程序实现的资源泄漏，而是glibc堆管理机制导致的「资源泄漏」。我很奇怪为什么glibc没有重用程序调用free释放掉的空间，而是继续扩充堆。这个问题值得继续琢磨。&lt;/p&gt;

&lt;p&gt;　　总结：本次故障的分析过程里我的粗心大意又给自己惹了大麻烦。原本思路是正确的，结果走歪了。。。 自作孽啊。。。&lt;/p&gt;

&lt;p&gt;　　但是，即便这个故障不是程序实现BUG所导致的，实际上还是会对程序造成不好的影响：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果调整M_MMAP_THRESHOLD让程序不「泄漏」，那么资源占用和性能会变差。原因参考帮助文档中对该参数的描述。&lt;/li&gt;
&lt;li&gt;如果放任不管，程序会不停地吃内存，并且占住不释放。我尝试让程序持续吃内存，最后稳定在3GB的物理内存（共4G）和2.6G的swap空间（共4G）的消耗。（但没有被oom killer干掉）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　再琢磨琢磨吧。&lt;/p&gt;

&lt;p&gt;　　最后，感谢我的同事cntrump。并附上《代码大全》里的一段话，我前些天重温的时候才看过：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;23.2 &lt;strong&gt;寻找缺陷&lt;/strong&gt; - &lt;em&gt;同他人讨论问题&lt;/em&gt;&lt;br /&gt;
　　有人会把这种方法称之为“忏悔式调试”。当你向别人解释自己的程序时，常常能发现自己犯下的一些错误。举个例子，如果你向别人解释上面的关于薪水的例子，你或许会这样对别人说：&lt;br /&gt;
　　嗨，jennifer，你有空么？我现在遇到一个麻烦。这张员工薪水列表本来应当是按照顺序排列的，但里面有些名字乱序了。我原本打算看看是不是新输入的名字就会这种情况，但有时是对的，有时又不是。我向这些数据在我输入他们的时候就应当被排序，因为程序会在我输入数据的时候对其排序，然后在数据保存的时候再排一遍。等一下，不对，它没有在输入数据的时候对其排序。就是这里。程序只是粗略地对这些数据进行了排序。谢谢你，jennifer，你帮了我个大忙。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>隔栏、断言、防御型和攻击型编程的思考</title>
      <link>http://boxcounter.com/technique/2014-01-12-assert-defensive-offensive-programming/</link>
      <pubDate>Sun, 12 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2014-01-12-assert-defensive-offensive-programming/</guid>
      <description>

&lt;h1 id=&#34;一-前言:03abadb4947350f837a3f50c1387e0d7&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　本文的内容最初源自我重温《代码大全》时候读到的一段内容，然后和同事讨论又引发了自己的一些思索。最后觉得这值得写下来，一来我一直很喜欢琢磨编码风格，有一些这方面的​思考，但都是一些存放在脑子里的思维碎片，（部分）整理成文对我自己是件好事。二来抛砖引玉，希望能找到一些同好探讨。&lt;/p&gt;

&lt;h1 id=&#34;二-常用的断言宏:03abadb4947350f837a3f50c1387e0d7&#34;&gt;二、常用的断言宏&lt;/h1&gt;

&lt;p&gt;　　先贴一段我常用的断言宏，后面讲述的时候所说的ASSERT是通指下面这一组ASSERT*。
&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;#ifdef DEBUG&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT(x) assert(x)&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#else&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT(x)&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#endif&lt;/span&gt;

&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_RETURN(x)            {ASSERT(x); if(!(x)) {return;}}&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_RETURN_VAL(x, ret)   {ASSERT(x); if(!(x)) {return ret;}}&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_GOTO(x, label)       {ASSERT(x); if(!(x)) {goto label;}}&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_BREAK(x)             {ASSERT(x); if(!(x)) {break;}}&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_CONTINUE(x)          {ASSERT(x); if(!(x)) {continue;}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;三-隔栏与断言:03abadb4947350f837a3f50c1387e0d7&#34;&gt;三、隔栏与断言&lt;/h1&gt;

&lt;p&gt;　　《代码大全》里有这么一段“隔栏与断言的关系”：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;隔栏外部的程序应使用错误处理技术，在那里对数据做的任何假定都是不安全的。&lt;br /&gt;
隔栏内部的程序应使用断言技术，因为传进来的数据应该已在通过隔栏时被清理过了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　这里的“隔栏”我理解为一些接口，比如类的public函数。按照上述说法，应该在public函数的对参数进行合法性验证“if (!x) return”，在private函数的开头使用ASSERT。&lt;/p&gt;

&lt;p&gt;　　感觉也有点道理。但是觉得又不太习惯。我习惯这么做：&lt;br /&gt;
　　public和private函数都用ASSERT，既把问题反馈给外部使用者，又反馈自身内部的问题。&lt;/p&gt;

&lt;p&gt;　　曾经和同事讨论过这个问题，同事没我这么挑（或者“钻牛角尖”？），他一般的做法是：在public函数里做参数检查，private里不对参数做检查。一来是priva​te里没必要做判断（public已经判断过了），二来是影响效率。&lt;/p&gt;

&lt;p&gt;　　我尝试了一段时间，但是还是觉得不合我的习惯，原因是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;即便public函数做了参数检查，也难保开发者不引入别的问题。比如传递参数过程中误改。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;所谓“内部”、“外部”，只是个相对的概念。多人协作来开发、使用这些类的过程中，一个模块中的函数可能由不同的开发者编写，相互都可以理解为“外部”（甚至不同函数也可​以认为互为“外部”）。即便在做设计时已经约定好相互之间的数据要求，也难免实现过程中会偏离。更不用说使用极端敏捷开发、基本不做文档化设计的小团队协作。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如“隔栏和断言的关系”所述：“隔栏内部的程序应使用断言技术，因为传进来的数据应该已在通过隔栏时被清理过了”。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;担忧的那部分性能损耗极有可能微乎其微。（后面有一些性能优化的想法分享。）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　又琢磨了琢磨，感觉《代码大全》里说的也有道理。隔栏处确实更适合做过滤，而不是断言。&lt;br /&gt;
　　因为隔栏外部的程序未必需要隔栏内部的反馈。比如单元测试时，测试程序可能会有意的传入非法的参数。&lt;/p&gt;

&lt;h1 id=&#34;四-一个讨论引发的思索:03abadb4947350f837a3f50c1387e0d7&#34;&gt;四、一个讨论引发的思索&lt;/h1&gt;

&lt;p&gt;　　另外，同事分享了一个讨论贴，主贴里楼主愤怒地吐槽：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;昨天线上的一个服务程序问了点问题，程序无限重启。&lt;br /&gt;
通过gdb调试发现该程序在某个函数里调用空指针，然后造成了段错误。因为有守护进程监控，所以有了无限重启的现像。&lt;br /&gt;
我把引起段错误的地方告诉了程序的作者，此人竟然说，这个指针应该不为空才对，现在指针为空说明了数据有问题，应该让数据的生产者去修改，他拒绝修改。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　跟帖的有支持楼主的（后简称A），也有认同文中“程序的作者”（B）。&lt;/p&gt;

&lt;p&gt;　　回帖里支持双方的都有。比如支持B的典型说法有：“strcpy不就这样么？”、“野指针同样会照成崩溃，所以是否检查空指针完全看程序各个模块之间的约定”。&lt;/p&gt;

&lt;p&gt;　　我是毫不犹豫的支持A的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;错误应该尽早暴露。&lt;br /&gt;
  并且应该尽可能由开发者可控的引爆，而不是被动的爆掉，然后没头脑地分析爆炸现场。简单来说，一个好的开发人员应该让修正问题的代价尽可能的小。&lt;/li&gt;
&lt;li&gt;参数检查不是银弹，但即便如此，对一些普遍的错误做处理也是必要且高效的。&lt;br /&gt;
  比如常见的NULL指针。这些常见的错误可能占各种参数错误发生总量的一半，解决掉它们带来的收益是很可观的。很多事情很难做到100%完美，但是度量（很多时候靠经验）​面对的问题，整理出解决这些问题的收益比曲线，然后处理掉那些收益比最高的问题，就是一个很好的方法。而不是嚷嚷“我没办法解决100%的问题，所以我就不解决了。问题出​现了再说”。激进一点说，在我看来，这是不负责的想法。&lt;/li&gt;
&lt;li&gt;标准库的做法并不一定是正确的，比如臭名昭著的realloc。&lt;br /&gt;
  具体的缺点很多文章里有讨论，《代码大全》里也有提到。&lt;/li&gt;
&lt;li&gt;函数都需要检查参数。&lt;br /&gt;
  至于如何检查参数（比如是否需要检查空指针），主要取决于函数本身对参数的期望，而不应只取决“模块之间的约定”。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　说的远一些，我很喜欢有调试开关或者调试功能的开发库和工具。比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;*nix平台下的glibc中的MALLOC_CHECK_宏、valgrind，还有electric-fence（貌似这货会误报，哪位朋友分享一个更好的？）等等。&lt;/li&gt;
&lt;li&gt;windows下的application verifier、driver verifier，还有checked版本的系统等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　对我来说，我甚至希望所有的开发库都有类似的机制。我希望某天开发者能通过某个开关让strcpy检查空指针，检查源、目的覆盖问题等等。&lt;/p&gt;

&lt;p&gt;　　此外，还有一些涉及到防御型编程和“攻击型编程”（好像没有约定俗成的名称？姑且这么称呼吧）的想法。&lt;/p&gt;

&lt;p&gt;　　我个人推荐的做法是：对自己狠一点，对最终用户温柔一些。精确点说是“开发和内测版本中多用攻击型技术，让故障尽早（并且可控地）被引爆。发布版本里多用防御行编程，以包​容一些非致命的问题。”&lt;/p&gt;

&lt;p&gt;　　举例来说，本文最开始的ASSERT_RETURN宏就是这种方法的一个典型：&lt;/p&gt;

&lt;p&gt;　　在开发版本（#ifdef DEBUG分支）中，启用了assert，一旦不符合研发人员的预期，就会立刻引爆，让研发能够发现问题。而发布版本中则只是做了&amp;rdquo;if return/break/continue&amp;rdquo;等，包容了错误。让程序能够正常的运行下去。&lt;/p&gt;

&lt;p&gt;　　另外在发布版本中是包容还是优雅的退出，取决于具体的问题。比如office中发现用户通过剪贴板复制过来的数据不合要求，如果此时“优雅的退出”，用户可能杀人的心都有​了。&lt;/p&gt;

&lt;h1 id=&#34;五-性能优化相关的一些想法:03abadb4947350f837a3f50c1387e0d7&#34;&gt;五、性能优化相关的一些想法&lt;/h1&gt;

&lt;p&gt;　　这个话题也是一个很庞大的话题，我只说说我个人的想法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;优化的前提是掌握了准确的性能分析数据，明确了性能瓶颈。没有进行科学的性能分析就着手进行的优化都是耍流氓。&lt;br /&gt;
  当然，开发过程中就拍脑袋想出来的“性能瓶颈”更是地球人愚蠢的想法（我自己犯过好几次，而且还是在我高举“过早优化是一切罪恶之源”大旗的情况下。最后都证明是捡了芝麻​丢了西瓜，感谢我的同事点醒了我）。&lt;br /&gt;
  开发阶段需要做的事是尽量的模块化和抽象，当后续诊断出性能瓶颈后可以很方便的替换、调优那些模块。&lt;/li&gt;
&lt;li&gt;自上而下，先考虑架构，再考虑层、模块，最后考虑底层的实现。&lt;br /&gt;
  切莫为“这个密集调用的函数里这条检查语句很复杂，可能会影响整体性能”而“优化”。首先，参考上述的1，别耍流氓。其次，优化也有收益比曲线，先优化收益比最高的那些瓶​颈，那些才是金矿。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　最后，广而告之：《代码大全》，你值得拥有。&lt;/p&gt;

&lt;h1 id=&#34;六-版本记录:03abadb4947350f837a3f50c1387e0d7&#34;&gt;六、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2014-01-05, 初始发布。&lt;/li&gt;
&lt;li&gt;v1.1 - 2014-01-12, 增加了隔栏处的新思考。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>linux、osx下搭建操作系统开发环境 v1.1</title>
      <link>http://boxcounter.com/technique/2013-11-14-linux%E3%80%81osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83_v1.1/</link>
      <pubDate>Thu, 14 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-11-14-linux%E3%80%81osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83_v1.1/</guid>
      <description>

&lt;h1 id=&#34;一-前言:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　本文档记录的内容既适用于x86也适用于x64，只是对于后者有一些环境要求。&lt;br /&gt;
　　之前开发使用的方法是：自己的引导代码+虚拟软盘。优点是搭建简单，所有代码都是自己编写，可控性强。最近想试试使用grub的引导功能，于是花了些时间琢磨。搜出来的相​关资料有不少，但是要么是grub1的，要么太过零散，要么描述太过简略。总之，没有一篇文章详细的讲述整个配置过程。所以我就在搭建的过程中顺手整理了这么一篇完整的、​完全从零开始的方法，其中每一步都有较丰富的说明。&lt;br /&gt;
　　另外，本文档介绍的方法适用于osx和linux，实际上整个过程中大部分必须使用到linux。也就是说如果要按照本文档来搭建开发环境，linuxer只需要使用自己​的linux系统就行，而osxer还得备一套linux系统（比如虚拟机）。使用linux的主要原因是我选择了ext2作为文件系统，而osx上貌似只有读写ext2​的fuse-ext2，没有用于创建ext2分区的fdisk等工具（如果同好有osx的ext2创建工具推荐，劳烦分享给我(ns.boxcounter[at]gmail.com)吧，不胜感激）。如果改用fat32就没有这个烦恼，整个过程都可以在osx下完成，因为osx的fdisk就可以创建fat32分区。&lt;/p&gt;

&lt;p&gt;　　我使用的系统、软件情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;x86 ubuntu 12.04.2/x64 ubuntu 13.10、osx 10.8.4/osx 10.9&lt;/li&gt;
&lt;li&gt;nasm 2.10.09&lt;/li&gt;
&lt;li&gt;bochs 2.6.1&lt;/li&gt;
&lt;li&gt;grub2 2.0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　如果同好使用的环境不一样，可能需要根据情况自行调整一些细节。&lt;br /&gt;
　　另外，本文提供的命令在显示时候可能会自动折行，所以复制到剪贴板中之后（在折行处）可能会有多余的空格，请同好自行删减。&lt;/p&gt;

&lt;h1 id=&#34;二-创建虚拟磁盘-并分区:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;二、创建虚拟磁盘，并分区&lt;/h1&gt;

&lt;p&gt;　　首先说明：&lt;br /&gt;
　　这里的目标磁盘的属性是：16 headers, 63 sectors per track, 512 bytes per sector。意味着每一个cylinder的大小是516096bytes（16 * 63 * 512）。&lt;br /&gt;
　　“#cylinders”表示柱面数，主要关系到磁盘大小。如果是10MB的磁盘，#cylinders=20。&lt;br /&gt;
　　需要在linux系统中进行，使用的工具是kpartx，系统默认没有自带，需要下载。&lt;/p&gt;

&lt;p&gt;　　好了，开始了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;dd if=/dev/zero of=antos.img bs=516096 count=#cylinders&lt;br /&gt;
创建虚拟磁盘。也可以使用bochs附带的bximage工具来完成。&lt;/li&gt;
&lt;li&gt;ps aux | grep loop&lt;br /&gt;
默认是搜索不到名为“[loopX]”进程的。如果有发现，那记住输出中的“[loopX]”进程。&lt;/li&gt;
&lt;li&gt;kpartx -av ./antos.img&lt;br /&gt;
挂载虚拟磁盘，可能没有输出。&lt;/li&gt;
&lt;li&gt;ps aux | grep loop&lt;br /&gt;
正常情况下，这里会发现一个名为“[loop0]”的进程。说明antos.img被挂载到了“/dev/loop0”设备上。如果前面搜索结果中已经有了“[loopX]”进程，那新增加的那个进程就是挂载的设备名。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fdisk -u -C#cylinders -S63 -H16 /dev/loop0&lt;br /&gt;
为磁盘分区。以#cylinders=20、单个分区为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# fdisk -u -C20 -S63 -H16 /dev/loop0
Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel
Building a new DOS disklabel with disk identifier 0x136d49ee.
Changes will remain in memory only, until you decide to write them.
After that, of course, the previous content won&#39;t be recoverable.


Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)


Command (m for help): o &amp;lt;&amp;lt;&amp;lt;=== Create a new empty DOS partition table
Building a new DOS disklabel with disk identifier 0x5bd665d5.
Changes will remain in memory only, until you decide to write them.
After that, of course, the previous content won&#39;t be recoverable.


Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)


Command (m for help): n &amp;lt;&amp;lt;&amp;lt;=== Create a new partition
Partition type:
p   primary (0 primary, 0 extended, 4 free)
e   extended
Select (default p): &amp;lt;&amp;lt;&amp;lt;=== 回车
Partition number (1-4, default 1): &amp;lt;&amp;lt;&amp;lt;=== 回车
First sector (2048-20159, default 2048): &amp;lt;&amp;lt;&amp;lt;=== 回车
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-20159, default 20159): &amp;lt;&amp;lt;&amp;lt;=== 回车
Using default value 20159


Command (m for help): a &amp;lt;&amp;lt;&amp;lt;=== Toggle the bootable flag (Optional)
Partition number (1-4): 1 &amp;lt;&amp;lt;&amp;lt;=== 分区1


Command (m for help): p &amp;lt;&amp;lt;&amp;lt;=== Print the partition table.


Disk /dev/loop0: 10 MB, 10321920 bytes
16 heads, 63 sectors/track, 20 cylinders, total 20160 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x5bd665d5


Device Boot      Start         End      Blocks   Id  System
/dev/loop0p1   *        2048       20159        9056   83  Linux
&amp;lt;&amp;lt;&amp;lt;=== 如果使用附录2记录的方法，需要记录Start和Blocks的值，本例子中分别是2048和9056。


Command (m for help): w &amp;lt;&amp;lt;&amp;lt;=== Write partition table to our &#39;disk&#39; and exit
The partition table has been altered!


Calling ioctl() to re-read partition table.


WARNING: Re-reading the partition table failed with error 22: Invalid argument.
The kernel still uses the old table. The new table will be used at
the next reboot or after you run partprobe(8) or kpartx(8)
Syncing disks.
&amp;lt;&amp;lt;&amp;lt;=== Ignore any errors about rereading the partition table. Since it&#39;s not a physical device we really don&#39;t care.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kpartx -dv ./antos.img&lt;br /&gt;
卸载磁盘，应该输出“loop deleted : /dev/loop0”。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kpartx -av ./antos.img&lt;br /&gt;
挂载分区磁盘，这次新创建的分区也会自动挂载。&lt;br /&gt;
正常会输出“add map loop0p1 (252:0): 0 18112 linear /dev/loop0 2048”，表示分区挂载到了“/dev/mapper/loop0p1”设备上。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mke2fs -b1024 /dev/mapper/loop0p1&lt;br /&gt;
格式化分区，&amp;rdquo;-b1024&amp;rdquo;表示使用1KB的block。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mkdir /tmp/antos&lt;br /&gt;
创建挂载目录。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mount -text2 /dev/mapper/loop0p1 /tmp/antos&lt;br /&gt;
挂载分区到目录。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ls /tmp/antos/&lt;br /&gt;
如果前面的步骤都成功，会看到名为“lost+found”的目录，说明磁盘和分区都正确的创建了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;三-安装grub2到虚拟磁盘:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;三、安装grub2到虚拟磁盘&lt;/h1&gt;

&lt;p&gt;　　假设磁盘挂载到设备“/dev/loop0”上，分区挂载到“/tmp/antos”目录下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grub-install --no-floppy --modules=&amp;quot;biosdisk part_msdos ext2 configfile normal multiboot&amp;quot; --root-directory=/tmp/antos /dev/loop0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　安装过程中可能会报警告，只要最后输出“Installation finished. No error reported.”就表示安装成功了。&lt;br /&gt;
　　如果使用的系统是x64架构的，需要使用新一些的系统，比如ubuntu 13.10。具体原因请参考附录一。&lt;br /&gt;
　　（在fedora等redhat系中使用的名称是“grub2-install”）&lt;/p&gt;

&lt;h1 id=&#34;四-在bochs中使用虚拟磁盘:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;四、在bochs中使用虚拟磁盘&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;确认虚拟磁盘的属性。&lt;br /&gt;
先挂载虚拟磁盘，然后执行“disk -u -l /dev/loop0”，正常会有如下输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 Disk /dev/loop0: 10 MB, 10321920 bytes
2 16 heads, 63 sectors/track, 20 cylinders, total 20160 sectors
3 Units = sectors of 1 * 512 = 512 bytes
4 Sector size (logical/physical): 512 bytes / 512 bytes
5 I/O size (minimum/optimal): 512 bytes / 512 bytes
6 Disk identifier: 0x6418cb2e
7
8       Device Boot      Start         End      Blocks   Id  System
9 /dev/loop0p1   *        2048       20159        9056   83  Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第2行说明了虚拟磁盘的属性。（前面使用fdisk为磁盘分区的时候也有输出同样的内容，如果记下来了，就可以不需要这一步）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建bochs虚拟机配置文件&lt;br /&gt;
不带参数运行bochs，应该会有这样的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. Restore factory default configuration
2. Read options from...
3. Edit options
4. Save options to...
5. Restore the Bochs state from...
6. Begin simulation
7. Quit now


Please choose one: [2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选择4，然后输入配置文件名，比如“antos.bxrc”，提示保存成功后退出bochs。这样就有了一份默认配置的bochs虚拟机配置文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改bochs虚拟机配置文件，以适应我们的需要&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加虚拟磁盘。&lt;br /&gt;
将这一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ata0-master: type=none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ata0-master: type=disk, path=&amp;quot;./antos.img&amp;quot;, cylinders=#cylinders,heads=#heads,spt=#sec-per-track
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应之前获取到的磁盘属性，这一行应该是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ata0-master: type=disk, path=&amp;quot;./antos.img&amp;quot;, cylinders=20,heads=16,spt=63
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改启动项为磁盘。&lt;br /&gt;
将这一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boot: floppy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boot: disk
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开启bochs的magic breakpoint。&lt;br /&gt;
将这一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;magic_break: enabled=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;magic_break: enabled=1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　到这里，就可以在bochs中运行了（命令是“bochs -f antos.bxrc”），并且看到grub2的命令提示符，如图：&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://boxcounter.com/images/2013-11-14/grub-cmdline.png&#34;/&gt;&lt;/p&gt;

&lt;h1 id=&#34;五-编写最简单的系统内核:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;五、编写最简单的系统内核&lt;/h1&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;//&lt;/span&gt; kernel.asm&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;源码&lt;/span&gt;
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;section&lt;/span&gt; .kernel]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;bits&lt;/span&gt; 32]

load_base&lt;span style=&#34;color: #0000ff&#34;&gt; equ&lt;/span&gt; 0x100000

&lt;span style=&#34;color: #008000&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color: #008000&#34;&gt;; multiboot header&lt;/span&gt;
&lt;span style=&#34;color: #008000&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
multiboot_header:
MBH_magic&lt;span style=&#34;color: #0000ff&#34;&gt;            equ&lt;/span&gt; 0xE85250D6
MBH_architecture&lt;span style=&#34;color: #0000ff&#34;&gt;     equ&lt;/span&gt; 0            &lt;span style=&#34;color: #008000&#34;&gt;; 32-bit protected mode&lt;/span&gt;
MBH_header_length&lt;span style=&#34;color: #0000ff&#34;&gt;    equ&lt;/span&gt; multiboot_header_end - multiboot_header
MBH_checksum&lt;span style=&#34;color: #0000ff&#34;&gt;         equ&lt;/span&gt; -(MBH_header_length + MBH_magic + MBH_architecture)

&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_magic
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_architecture
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_header_length
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_checksum

&lt;span style=&#34;color: #008000&#34;&gt;; tags&lt;/span&gt;
info_request_tag:
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 1
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; info_request_tag_end - info_request_tag
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 5
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 6
info_request_tag_end:
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
address_tag:
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 2
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; address_tag_end - address_tag
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; load_base                 &lt;span style=&#34;color: #008000&#34;&gt;; header_addr&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; load_base                 &lt;span style=&#34;color: #008000&#34;&gt;; load_addr&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 0                         &lt;span style=&#34;color: #008000&#34;&gt;; load_end_addr&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 0                         &lt;span style=&#34;color: #008000&#34;&gt;; bss_end_addr&lt;/span&gt;
address_tag_end:
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
entry_address_tag:
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 3
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; entry_address_tag_end - entry_address_tag
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; load_base + kernel_entry
entry_address_tag_end:
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
&lt;span style=&#34;color: #008000&#34;&gt;; end tag&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 8
multiboot_header_end:

kernel_entry:
xchg bx, bx                 &lt;span style=&#34;color: #008000&#34;&gt;; magic breakpoint&lt;/span&gt;
jmp &lt;span style=&#34;color: #0000ff&#34;&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;br /&gt;
　　编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nasm kernel.asm -o kernel.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　编译过程中可能会报警告，无视它。&lt;br /&gt;
　　将虚拟磁盘挂载到某个目录，然后将kernel.bin拷贝到分区的根目录，即和/boot目录同一层目录。&lt;/p&gt;

&lt;h1 id=&#34;六-使用grub2启动自行编写的操作系统内核:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;六、使用grub2启动自行编写的操作系统内核&lt;/h1&gt;

&lt;p&gt;　　假设分区挂载到“/tmp/antos”目录下，那么创建grub需要的配置文件“/tmp/antos/boot/grub/grub.cfg”，将以下几行文本贴进去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set default=0
insmod ext2
set root=(hd0,1)
set timeout=10
menuentry &amp;quot;antos 0.0.1&amp;quot; {
   insmod ext2
   set root=(hd0,1)
   multiboot2 (hd0,1)/kernel.bin
   boot
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　其中(hd0,1)表示咱之前创建的虚拟磁盘的第一个分区，kernel.bin就是前面编译的系统内核文件。&lt;/p&gt;

&lt;p&gt;　　现在可以启动咱的bochs虚拟机了，执行“bochs -f antos.bxrc”。&lt;br /&gt;
　　再输入c继续执行后，应该就能看到bochs从咱的虚拟磁盘引导，然后可以看见grub的选择界面，最后会中断到咱系统内核的“xchg bx, bx”指令，这是bochs内置的主动中断指令，即magic breakpoint机制。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o 00449811185i[CPU0 ] [449811185] Stopped on MAGIC BREAKPOINT
(0) Magic breakpoint
Next at t=449811185
(0) [0x000000100053] 0010:0000000000100053 (unk. ctxt): jmp .-2 (0x00100053) ; ebfe
00449811185i[XGUI ] Mouse capture off
&amp;lt;bochs:2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　ok，整个配置过程就完毕了，整个过程都是在linux中完成的。使用fat32的osx同好可以使用类似的方法来完成。整个过程每一步的功能都写的很清楚了，看到这里理​理思路应该就明白整个流程了。&lt;/p&gt;

&lt;h1 id=&#34;七-osx中读写ext2文件系统的虚拟磁盘:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;七、osx中读写ext2文件系统的虚拟磁盘&lt;/h1&gt;

&lt;p&gt;　　最后说说osx相关的内容，因为我不想每次做开发的时候都需要开个linux虚拟机。以下是在osx下读写虚拟磁盘的方法，比如更新的kernel.bin等等。linu​xer可以无视这一步。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装osxfuse和fuse-ext2&lt;br /&gt;
fuse-ext2默认只能以只读方式挂载设备，所以需要进行以下修改使其默认以可读可写方式挂载设备：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo vi /System/Library/Filesystems/fuse-ext2.fs/fuse-ext2.util
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搜索定位到Mount函数，为其名为“OPTIONS”的变量增加额外的“rw+”选项。&lt;br /&gt;
比如：原内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mount ()
{
      LogDebug &amp;quot;[Mount] Entering function Mount...&amp;quot;
      # Setting both defer_auth and defer_permissions. The option was renamed
      # starting with MacFUSE 1.0.0, and there seems to be no backward
      # compatibility on the options.
      OPTIONS=&amp;quot;auto_xattr,defer_permissions&amp;quot;
      ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mount ()
{
      LogDebug &amp;quot;[Mount] Entering function Mount...&amp;quot;
      # Setting both defer_auth and defer_permissions. The option was renamed
      # starting with MacFUSE 1.0.0, and there seems to be no backward
      # compatibility on the options.
      OPTIONS=&amp;quot;auto_xattr,defer_permissions,rw+&amp;quot;
      ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;挂载磁盘到设备&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hdiutil attach -nomount antos.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是会输出如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dev/disk1              FDisk_partition_scheme
/dev/disk1s1            Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明虚拟磁盘已经挂载到/dev/disk1设备上了，分区已经挂载到/dev/disk1s1。（之所以加上-nomount参数，是因为hdiutil没法正确地挂载ext2分区到目录）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;挂载分区到目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sbin/mount_fuse-ext2 /dev/disk1s1 ./mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/dev/disk1s1是步骤3中得到的设备（分区)名。&lt;br /&gt;
到这里，就可以对分区内容进行修改了，比如更新kernel.bin等等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从目录卸载分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;umount ./mnt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;卸载虚拟磁盘&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hdiutil detach /dev/disk1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（注意是磁盘设备，不是分区设备disk1s1）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;八-附录一-x64-ubuntu-12-04-2中执行grub-install遇到的问题:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;八、附录一：x64 ubuntu 12.04.2中执行grub-install遇到的问题&lt;/h1&gt;

&lt;p&gt;　　我在x64 ubuntu 12.04.2中执行“安装grub2到虚拟磁盘”操作时总是失败，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@x64:~# grub-install --no-floppy --modules=&amp;quot;biosdisk part_msdos ext2 configfile normal multiboot&amp;quot; --root-directory=/tmp/antos /dev/loop0
Path `/tmp/antos/boot/grub&#39; is not readable by GRUB on boot. Installation is impossible. Aborting.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　加上&amp;ndash;deubg选项后，发现grub-install输出了这么几行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ /usr/local/sbin/grub-probe -t fs /tmp/antos/boot/grub
+ return 1
+ gettext_printf Path `%s&#39; is not readable by GRUB on boot. Installation is impossible. Aborting.\n /tmp/antos/boot/grub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　手动执行grub-probe，输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# /usr/local/sbin/grub-probe -t fs /tmp/antos/boot/grub/usr/local/sbin/grub-probe: error: disk `lvm/loop0p1&#39; not found.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我查阅了很多资料，都没有明确的解决方案。经过了约莫20个小时的摸索，最终发现只需要使用新版本的系统自带的grub 2.0.0即可。（注：x64 ubuntu 12.04.2中的grub2是我源码编译的2.0.0版，也尝试过使用trunk源码编译或者使用系统自带的1.99，都会报错。）&lt;/p&gt;

&lt;h1 id=&#34;九-附录二-创建虚拟磁盘分区的另外一种方法-losetup:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;九、附录二：创建虚拟磁盘分区的另外一种方法（losetup）&lt;/h1&gt;

&lt;p&gt;　　需要说明，这种方法较前面介绍的使用kpartx的方法要繁琐，所以并不推荐（特别是如果要使用多分区）。补充在这里的原因是我最开始搜索到的资料使用的就是losetu​p工具，摸索成功之后才发现kpartx。&lt;br /&gt;
　　另外，操作过程中有部分步骤和前面讲述的步骤一样，所以省略了那些步骤的说明。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;dd if=/dev/zero of=antos.img bs=516096 count=#cylinders&lt;/li&gt;
&lt;li&gt;losetup /dev/loop0 ./antos.img&lt;br /&gt;
这个时候执行“ps aux | grep loop”，会看到一个名为[loop0]的进程。（如果loop0被占用，可以换一个设备）&lt;/li&gt;
&lt;li&gt;fdisk -u -C#cylinders -S63 -H16 /dev/loop0&lt;/li&gt;
&lt;li&gt;losetup /dev/loop0 ./antos.img&lt;br /&gt;
这个时候执行“ps aux | grep loop”，会看到一个名为[loop0]的进程。（如果loop0被占用，可以换一个设备）&lt;/li&gt;
&lt;li&gt;losetup -d /dev/loop0&lt;br /&gt;
到这里，虚拟磁盘已经创建完毕了，从设备（“loop0”）上卸载虚拟磁盘，准备格式化。&lt;/li&gt;
&lt;li&gt;losetup -o1048576 /dev/loop0 ./antos.img&lt;br /&gt;
再次挂载，与前面挂载不同的是，这次使用了“-o1048576”参数，目的是跳过前1048576字节，来到分区的开始。前面提到要记住Start的值，即分区开始扇区号，这里就需要使用它了，1048576=20​48*512。&lt;/li&gt;
&lt;li&gt;mke2fs -b1024 /dev/loop0 9056&lt;br /&gt;
对加载到“loop0”设备上的*分区*（注意是分区，不是整个磁盘了，前面咱跳到了分区开始处）进行格式化，使用的是ext2文件系统。&lt;br /&gt;
”-b1024“表示使用1KB的block，9056就是之前的Blocks的值，即整个分区的blocks数。&lt;/li&gt;
&lt;li&gt;mkdir /tmp/antos&lt;/li&gt;
&lt;li&gt;mount -text2 /dev/loop0 /tmp/antos&lt;/li&gt;
&lt;li&gt;umount /dev/loop0&lt;/li&gt;
&lt;li&gt;losetup -d /dev/loop0&lt;br /&gt;
卸载目录和设备。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;十-主要参考资料:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;十、主要参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The Multiboot Specification&lt;/li&gt;
&lt;li&gt;grub2源码&lt;/li&gt;
&lt;li&gt;Mac OS X下读写ext2/ext3文件系统&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;十一-版本记录:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;十一、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-09-02，初始发布。&lt;/li&gt;
&lt;li&gt;v1.1 - 2013-11-14，增加x64系统下的说明。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-11-14/linux、osx下搭建操作系统开发环境的完整步骤_v1.1.pdf&#34;&gt;2013-11-14-linux、osx下搭建操作系统开发环境_v1.1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下搭建操作系统开发环境之64位交叉开发工具集（gcc&#43;gdb）v1.0</title>
      <link>http://boxcounter.com/technique/2013-11-08-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B64%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.0/</link>
      <pubDate>Fri, 08 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-11-08-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B64%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.0/</guid>
      <description>

&lt;h1 id=&#34;一-前言:a48ba76a4646a20561a3efada380ccda&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　《&lt;a href=&#34;http://boxcounter.com/2013/11/04/osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B32%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc+gdb%EF%BC%89v1.1&#34;&gt;osx下搭建操作系统开发环境之32位交叉开发工具集(gcc+gdb)&lt;/a&gt;》一文中讲解了32位交叉工具的构建。64位（专指x64，非IA64）的构建方法和32位基本相同。看过前文的朋友看本文会发现绝大多数内容都是一样的。没错，之所以不基于前文、只讲差异，是为了独立性，方便只关注x64构建方法的朋友。&lt;br /&gt;
　　我的环境：osx 10.9&lt;/p&gt;

&lt;h1 id=&#34;二-安装osx版的gcc:a48ba76a4646a20561a3efada380ccda&#34;&gt;二、安装osx版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;brew install gcc48
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　推荐下载最新的稳定版gcc。&lt;/p&gt;

&lt;h1 id=&#34;三-配置编译环境:a48ba76a4646a20561a3efada380ccda&#34;&gt;三、配置编译环境&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;下载gcc源码&lt;br /&gt;
根据参考资料1的建议，最好使用最新的gcc来进行编译，被编译的源码也推荐使用一样版本的。也就是说，用gcc 4.8.2来编译gcc 4.8.2的源码。&lt;br /&gt;
下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gcc&#34;&gt;源码包&lt;/a&gt;并解压，得到的目录名称之为“$gcc-4.8.2”。&lt;/li&gt;
&lt;li&gt;下载gcc依赖项&lt;br /&gt;
需要的依赖项有：

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gnu.org/software/binutils/&#34;&gt;GNU Binutils&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gmplib.org/&#34;&gt;GMP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mpfr.org/&#34;&gt;MPFR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://multiprecision.org/&#34;&gt;MPC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将它们都解压出来，把解压出来的b、c、d的目录都放到gcc源码目录下。都需要去掉版本号，比如解压出来的目录名为“mpc-1.0.1”，那么现在就是“$gcc-4.8.2/mpc”。a无需这么做，因为它需要单独编译，参考后续的步骤4。&lt;br /&gt;
   其中GMP源码包是lzip压缩格式，需要下载lzip工具解压（brew安装）。
3. 下载gdb源码&lt;br /&gt;
   下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gdb&#34;&gt;源码包&lt;/a&gt;并解压，得到的目录名称之为“$gdb-7.6.1”。
4. 设置环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export CC=/usr/local/bin/gcc-4.8
    export CXX=/usr/local/bin/g++-4.8
    export CPP=/usr/local/bin/cpp-4.8
    export LD=/usr/local/bin/gcc-4.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都是brew版gcc4.8.2的软链接。如果不设置，那么会使用系统中默认自带的工具，这些工具的版本可能比较老。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export PREFIX=$HOME/opt/cross
    export TARGET=x86_64-pc-linux-gnu
    export PATH=&amp;quot;$PREFIX/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是编译时候使用的选项。需要注意的是：osdev上的《&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler_for_x86_64&#34;&gt;GCC Cross-Compiler for x86 64&lt;/a&gt;》建议将TARGET宏定义为x86_64-elf，但是我实验发现这样行不通，编译gdb的时候会报错“configure: error: configuration x86_64-pc-elf is unsupported.”。
5. 编译交叉版的binutils&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    cd $binutils-x.y.z
    mkdir build-binutils
    cd build-binutils
    ../configure --target=$TARGET --prefix=$PREFIX --enable-64-bit-bfd --enable-werror=no
    make
    make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;四-编译交叉版的gcc:a48ba76a4646a20561a3efada380ccda&#34;&gt;四、编译交叉版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gcc-4.8.2
mkdir build-gcc
cd build-gcc
../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls --enable-languages=c,c++ --without-headers
make all-gcc
make all-target-libgcc
make install-gcc
make install-target-libgcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后，在“~/opt/cross/bin”下就能看到编译好的交叉版的编译套件了，包括“x86_64-pc-linux-gnu-gcc”、“x86_64-pc-linux-gnu-g++”和“x86_64-pc-linux-gnu-ld ”等等。可以用“$HOME/opt/cross/bin/$TARGET-gcc &amp;ndash;version”来验证一下版本是否正确。&lt;br /&gt;
　　另外，为了方便使用，可以在.bashrc或者.zshrc中调整环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=&amp;quot;$HOME/opt/cross/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;五-编译交叉版的gdb:a48ba76a4646a20561a3efada380ccda&#34;&gt;五、编译交叉版的gdb&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gdb-7.6.1
mkdir build-$TARGET
cd build-$TARGET
../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls --enable-64-bit-bfd --enable-werror=no CFLAGS=&amp;quot;-m64&amp;quot;
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后，在“~/opt/cross/bin”下就能看到编译好的交叉版的x86_64-pc-linux-gnu-gdb了。&lt;/p&gt;

&lt;p&gt;　　注：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;和x64的bochs配合调试的时候，需要切换到x86-64模式（默认模式是i386）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) set architecture i386:x86-64
The target architecture is assumed to be i386:x86-64
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在这个编译选项版本之前，我尝试了好几种其他的编译选项，虽然都能编译出gdb，但是都无法与x64的bochs进行配合调试。包括使用“../configure &amp;ndash;enable-targets=all &amp;ndash;enable-64-bit-bfd”。无法与x64的bochs进行配合调试的现象是，gdb能够下断，但是中断点都是错误的，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) target remote localhost:1234
Remote debugging using 192.168.1.16:1234
0x00000000 in ?? ()
(gdb) b *0x7c00
Breakpoint 1 at 0x7c00
(gdb) c
Continuing.
Program received signal SIGTRAP, Trace/breakpoint trap.
0x000e0000 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常应该是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) target remote 192.168.1.16:1234
Remote debugging using localhost:1234
0x000000000000fff0 in ?? ()
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结，gdb的TARGET要和bochs（而非被调试OS）的平台一致，即如果使用的是x64的bochs，那么gdb的编译TARGET也需要是x64的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;六-参考资料:a48ba76a4646a20561a3efada380ccda&#34;&gt;六、参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler&#34;&gt;GCC Cross-Compiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler_for_x86_64&#34;&gt;GCC Cross-Compiler for x86 64&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.utah.edu/~manua/sim_doc/simics-reference-manual-public-all/topic96.html&#34;&gt;gdb-remote&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sourceforge.net/p/bochs/discussion/39592/thread/a489c7f1&#34;&gt;bochs + GDB help&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;七-版本记录:a48ba76a4646a20561a3efada380ccda&#34;&gt;七、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-11-08，初始发布。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-11-08/osx下搭建操作系统开发环境之64位交叉开发工具集（gcc+gdb）v1.0.pdf&#34;&gt;osx下搭建操作系统开发环境之64位交叉开发工具集（gcc+gdb）v1.0.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下搭建操作系统开发环境之构建bochs v1.0</title>
      <link>http://boxcounter.com/technique/2013-11-05-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B%E6%9E%84%E5%BB%BAbochs_v1.0/</link>
      <pubDate>Tue, 05 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-11-05-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B%E6%9E%84%E5%BB%BAbochs_v1.0/</guid>
      <description>

&lt;h1 id=&#34;一-前言:29112401aeca7f6da9b81a38b0dff7ac&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　我编译bochs的目的是为了启用gdb调试功能。bochs提供的调试器功能较简单，开发过程中还是gdb更趁手。本文记录的方法是我一点点尝试出来的，参考了网上一些零碎资料。整个过程虽然简单但是整体比较凌乱，特别是需要对bochs的官方源码包做好几处修改。目前不太想再花时间优化过程，能编译出来就好。如果有同好有更简单的方法，有劳和我分享一下吧。&lt;br /&gt;
　　我的环境：osx 10.9，bochs 2.6.2、使用x11作为界面库。&lt;/p&gt;

&lt;h1 id=&#34;二-安装x11:29112401aeca7f6da9b81a38b0dff7ac&#34;&gt;二、安装X11&lt;/h1&gt;

&lt;p&gt;　　下载&lt;a href=&#34;http://xquartz.macosforge.org/trac&#34;&gt;XQuartz&lt;/a&gt;安装包，并安装。&lt;/p&gt;

&lt;h1 id=&#34;三-配置编译环境:29112401aeca7f6da9b81a38b0dff7ac&#34;&gt;三、配置编译环境&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;export CC=/usr/bin/gcc
export CXX=/usr/bin/g++
export CPP=/usr/bin/cpp
export LD=/usr/bin/g++
export CFLAGS=-I/usr/X11/include
export PREFIX=/Users/boxcounter/opt/bochs-gdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　根据我的试验，使用brew安装的gcc编译会报错，使用系统自带的就可以正常编译，所以调整了CC等环境变量。PREFIX宏请根据需要自行修改。&lt;/p&gt;

&lt;h1 id=&#34;四-编译bochs:29112401aeca7f6da9b81a38b0dff7ac&#34;&gt;四、编译bochs&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;下载&lt;a href=&#34;http://sourceforge.net/projects/bochs/files/bochs/&#34;&gt;源码包&lt;/a&gt;并解压，解压出来的目录名称之为“$bochs”。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改.conf.macosx&lt;br /&gt;
根据需要修改configure的参数，比如以下是我使用的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --enable-disasm \
            --disable-docbook \
            --enable-x86-64 \
            --enable-pci \
            --enable-all-optimizations \
            --enable-plugins \
            --enable-cdrom \
            --enable-a20-pin \
            --enable-fpu \
            --enable-alignment-check \
            --enable-large-ramfile \
            --enable-readline \
            --enable-iodebug \
            --enable-xpm \
            --enable-show-ips \
            --enable-logging \
            --enable-usb \
            --enable-ne2000 \
            --enable-cpu-level=6 \
            --enable-sb16 \
            --enable-clgd54xx \
            --with-term \
            --enable-ne2000 \
            --with-x11 \
            --enable-idle-hack \
            --enable-gdb-stub \
            --prefix=${PREFIX} \
            ${CONFIGURE_ARGS}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;chmod u+x ./.conf.macosx &amp;amp;&amp;amp; ./.conf.macosx&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改ldtl相关选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将$bochs/config.h中的“BX_HAVE_LTDL”宏的定义由1改为0，只有一处。&lt;/li&gt;
&lt;li&gt;将$bochs/Makefile中的“-lltdl”改为“ltdl.o”，有多处。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调整gui模块的编译选项&lt;br /&gt;
将$bochs/gui/Makefile中的“X_LIBS =  -lXpm -lXrandr”修改为“X_LIBS = -L/usr/X11/lib -lXpm -lXrandr”&lt;br /&gt;
如果不进行此项修改，在gui目录下进行链接的时候总会报错，提示无法找到Xmp库。使用LDFLAGS环境变量或者修改.conf.macosx中的LDFLAGS都没有用，因为gui模块链接过程中并没有使用到它们。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make &amp;amp;&amp;amp; make install&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;五-参考资料:29112401aeca7f6da9b81a38b0dff7ac&#34;&gt;五、参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sourceforge.net/p/bochs/discussion/39592/thread/9c22887c&#34;&gt;No rule to make target `-lltdl&amp;rsquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;六-版本记录:29112401aeca7f6da9b81a38b0dff7ac&#34;&gt;六、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-11-05，初始发布。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-11-05/osx下搭建操作系统开发环境之构建bochs_v1.0.pdf&#34;&gt;osx下搭建操作系统开发环境之构建bochs_v1.0.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下搭建操作系统开发环境之32位交叉开发工具集（gcc&#43;gdb）v1.1</title>
      <link>http://boxcounter.com/technique/2013-09-07-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B32%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.1/</link>
      <pubDate>Mon, 04 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-09-07-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B32%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.1/</guid>
      <description>

&lt;h1 id=&#34;一-前言:1fb642315dd7f0464840b224b39a5096&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　《&lt;a href=&#34;http://boxcounter.com/2013/11/14/linux%E3%80%81osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83_v1.1&#34;&gt;linux、osx下搭建操作系统开发环境的完整步骤&lt;/a&gt;》一文中讲解了一些基本的搭建方法，并提供了一个nasm汇编编写的简单的系统内核源码。实际开发过程中更多使用的是C语言，就需要有一个配套的C编译器。因为我使用的可执行文件是elf格式，所以我选择的是GCC。但是osx下安装的GCC生成的是osx的可执行文件格式，并不是elf。所以我需要一个能在osx下生成elf的GCC，俗称的交叉编译器。&lt;br /&gt;
　　我的环境：osx 10.8.4 &amp;amp; 10.9&lt;/p&gt;

&lt;h1 id=&#34;二-安装osx版的gcc:1fb642315dd7f0464840b224b39a5096&#34;&gt;二、安装osx版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;brew install gcc48
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　推荐下载最新的稳定版gcc。&lt;/p&gt;

&lt;h1 id=&#34;三-配置编译环境:1fb642315dd7f0464840b224b39a5096&#34;&gt;三、配置编译环境&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;下载gcc源码&lt;br /&gt;
根据&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler&#34; title=&#34;「GCC Cross-Compiler」&#34;&gt;参考资料1&lt;/a&gt;的建议，最好使用最新的gcc来进行编译，被编译的源码也推荐使用一样版本的。也就是说，用gcc 4.8.1来编译gcc 4.8.1的源码。&lt;br /&gt;
下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gcc/&#34;&gt;源码包&lt;/a&gt;并解压，得到的目录名称之为「$gcc-4.8.1」。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载依赖项&lt;br /&gt;
需要的依赖项有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://gnu.org/software/binutils/&#34;&gt;GNU Binutils&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gmplib.org/&#34;&gt;GMP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mpfr.org/&#34;&gt;MPFR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://multiprecision.org/&#34;&gt;MPC&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将它们都解压出来，把解压出来的2、3、4的目录都放到gcc源码目录下。都需要去掉版本号，比如解压出来的目录名为「mpc-1.0.1」，那么现在就是「$gcc-4.8.1/mpc」。1无需这么做，因为它需要单独编译，参考后续的步骤4。&lt;br /&gt;
   其中GMP源码包是lzip压缩格式，需要下载lzip工具解压（brew安装）。
3. 下载 gdb 源码&lt;br /&gt;
   下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gdb/&#34;&gt;源码包&lt;/a&gt;并解压,得到的目录名称之为「$gdb-7.6.1」。
4. 设置环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export CC=/usr/local/bin/gcc-4.8
    export CXX=/usr/local/bin/g++-4.8
    export CPP=/usr/local/bin/cpp-4.8
    export LD=/usr/local/bin/gcc-4.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都是brew版gcc4.8.1的软链接。如果不设置，那么会使用系统中默认自带的工具，这些工具版本都很陈旧。比如osx 10.8.4带的/usr/bin/gcc是4.2版本的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export PREFIX=$HOME/opt/cross
    export TARGET=i586-elf
    export PATH=&amp;quot;$PREFIX/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是编译时候使用的选项。
5. 编译交叉版的binutils&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    cd $binutils-x.y.z
    mkdir build-binutils
    cd build-binutils
    ../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls
    make
    make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;四-编译交叉版的gcc:1fb642315dd7f0464840b224b39a5096&#34;&gt;四、编译交叉版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gcc-4.8.1
mkdir build-gcc
cd build-gcc
../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls --enable-languages=c,c++ --without-headers
make all-gcc
make all-target-libgcc
make install-gcc
make install-target-libgcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后，在「~/opt/cross/bin」下就能看到编译好的交叉版的编译套件了，包括「i586-elf-gcc」、「i586-elf-g++」和「i586-elf-ld」等等。可以用「$HOME/opt/cross/bin/$TARGET-gcc &amp;ndash;version」来验证一下版本是否正确。&lt;br /&gt;
　　另外，为了方便使用，可以在.bashrc或者.zshrc中调整环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=&amp;quot;$HOME/opt/cross/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;五-测试源码:1fb642315dd7f0464840b224b39a5096&#34;&gt;五、测试源码&lt;/h1&gt;

&lt;p&gt;　　现在咱有了交叉编译器了，试试效果吧：
&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000&#34;&gt;// kernel.c&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#include &amp;quot;multiboot2.h&amp;quot;&lt;/span&gt;


&lt;span style=&#34;color: #0000ff&#34;&gt;#define INFO_REQ_COUNT  2&lt;/span&gt;

&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header_tag_information_request
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header_tag_information_request info_req __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
    &lt;span style=&#34;color: #2b91af&#34;&gt;multiboot_uint32_t&lt;/span&gt; req[INFO_REQ_COUNT];
} __attribute__((packed));


&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header header __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header_tag_information_request info_req __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header_tag end __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
} __attribute__((packed));


&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header amb =
{
    {
        MULTIBOOT2_HEADER_MAGIC,
        MULTIBOOT_ARCHITECTURE_I386,
        &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header),
        -(MULTIBOOT2_HEADER_MAGIC + MULTIBOOT_ARCHITECTURE_I386 + &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header))
    },

    {
        {
            MULTIBOOT_HEADER_TAG_INFORMATION_REQUEST,
            MULTIBOOT_HEADER_TAG_OPTIONAL,
            &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header_tag_information_request)
        },
        MULTIBOOT_TAG_TYPE_BASIC_MEMINFO,
        MULTIBOOT_TAG_TYPE_FRAMEBUFFER
    },

    {
        MULTIBOOT_HEADER_TAG_END,
        MULTIBOOT_HEADER_TAG_OPTIONAL,
        &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header_tag)
    }
};


&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; breakpoint()
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;asm&lt;/span&gt;(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;xchg %bx, %bx&amp;quot;&lt;/span&gt;);
}


&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; _start()
{
    breakpoint();
    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;　　multiboot2.h头文件是从grub2.0.0的源码里拷贝过来的，主要定义了符合multiboot2规范的数据结构。&lt;br /&gt;
　　编译方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/opt/cross/bin/i586-elf-gcc -c -o kernel.o kernel.c
~/opt/cross/bin/i586-elf-ld -Ttext=0x100000 -o kernel.bin kernel.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　「-Ttext=0x100000」是为了让代码段加载到0x100000，而不是默认的08048074（我的环境中），后者超出我的bochs虚拟机的物理内存空间。&lt;br /&gt;
　　然后用kernel.bin替换之前的虚拟磁盘中的同名文件，再运行bochs虚拟机就能看到熟悉的magic breakpoint了。&lt;/p&gt;

&lt;h1 id=&#34;六-编译交叉版的-gdb:1fb642315dd7f0464840b224b39a5096&#34;&gt;六、编译交叉版的 gdb&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gdb-7.6.1
mkdir build-$TARGET
cd build-$TARGET
../configure --target=$TARGET --prefix=$PREFIX --disable-nls
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后,在「~/opt/cross/bin」下就能看到编译好的交叉版的i586-elf-gdb 了。&lt;/p&gt;

&lt;h1 id=&#34;七-参考资料:1fb642315dd7f0464840b224b39a5096&#34;&gt;七、参考资料&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler&#34;&gt;GCC Cross-Compiler&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;八-版本记录:1fb642315dd7f0464840b224b39a5096&#34;&gt;八、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-09-07，初始发布。&lt;/li&gt;
&lt;li&gt;v1.1 - 2013-11-04，增加「编译交叉版的gdb」章节。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;九-网友补充:1fb642315dd7f0464840b224b39a5096&#34;&gt;九、网友补充&lt;/h1&gt;

&lt;p&gt;以下内容为热心网友补充，供同好参考。（我没有验证。暂记录在这里，后续验证过后我再补入正文。感谢这位网友被我之前老博客系统的验证码刁难了N次后，还依然告知我，非常感谢。）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;OSX10.9下使用gcc4.8编译binutils-2.24会报错：nm.c:1687:7: error: &amp;lsquo;sbrk&amp;rsquo; is deprecated (declared at /usr/include/unistd.h:582)&lt;br /&gt;
需要使用gcc4.9，编译时指定编译参数CFLAGS=-Wno-error=deprecated-declarations&lt;br /&gt;
gcc的依赖项GMP/FPMR/MPC也不需要手动下载，在gcc的源码下执行./contrib/download_prerequisites即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-09-17/osx下搭建操作系统开发环境之32位交叉开发工具集（gcc+gdb）v1.1.pdf&#34;&gt;osx下搭建操作系统开发环境之32位交叉开发工具集（gcc+gdb）v1.1.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下为timeoutfree添加定时任务</title>
      <link>http://boxcounter.com/technique/2013-08-14-osx%E4%B8%8B%E4%B8%BAtimeoutfree%E6%B7%BB%E5%8A%A0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Wed, 14 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-08-14-osx%E4%B8%8B%E4%B8%BAtimeoutfree%E6%B7%BB%E5%8A%A0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid>
      <description>&lt;p&gt;我习惯使用休息提醒软件定时提醒我站起来扭扭腰，目前使用的是“Time Out Free”，挺好用的一款免费软件。&lt;/p&gt;

&lt;p&gt;　　但是使用过程中我有一个用着不够爽的地方：&lt;br /&gt;
　　下班回家后或者周末，我基本是躺着或者趴在床上用电脑，不需要再提醒我。但是它没有提供时间段配置，于是我用了定时任务来实现了，如下：&lt;/p&gt;

&lt;p&gt;　　下载附件“timeoutfree.sh”，加上执行权限。然后在终端中输入“crontab -e”编辑个人的定时任务，在里面添加如下两行（路径根据情况调整）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*/20    9-10    *   *   1-5 /Users/boxcounter/timeoutfree.sh start
*/20    18-23   *   *   1-5 /Users/boxcounter/timeoutfree.sh stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　然后保存退出，终端应该会输出“crontab: installing new crontab”，说明添加定时任务成功了。&lt;/p&gt;

&lt;p&gt;　　说明：&lt;br /&gt;
　　第一行的意思是：工作日每天早上9～11点这两个小时内，每隔20分钟尝试一次启动TimeOutFree。&lt;br /&gt;
　　第二行的意思是：工作日每天晚上18～24点这几个小时内，每隔20分钟尝试一次关闭TimeOutFree。&lt;/p&gt;

&lt;p&gt;　　附件：&lt;/p&gt;

&lt;p&gt;　　（脚本可能看起来很麻烦，是我随手找了个守护程序的脚本改的。）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下解决emacs执行中文路径命令出错的方法</title>
      <link>http://boxcounter.com/technique/2013-08-08-osx%E4%B8%8B%E8%A7%A3%E5%86%B3emacs%E6%89%A7%E8%A1%8C%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E5%91%BD%E4%BB%A4%E5%87%BA%E9%94%99%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 12 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-08-08-osx%E4%B8%8B%E8%A7%A3%E5%86%B3emacs%E6%89%A7%E8%A1%8C%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E5%91%BD%E4%BB%A4%E5%87%BA%E9%94%99%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;我第一次发现这个问题是在使用auctex编译中文名tex文件的时候发现的，后来发现不仅仅是auctex，M－!执行shell命令中如果包含中文路径或文件名也失败，最后搜了一些资料测试了几种，发现了这个解决方案。&lt;/p&gt;

&lt;p&gt;在emacs配置文件中增加如下一行：&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;(set-language-environment &lt;span style=&#34;color: #a31515&#34;&gt;&amp;#39;utf-8&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;话说，测试了好几种方法才解决的，一高兴忘了记下出处。惭愧惭愧，谢谢那位我记不得的博主吧。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;后记2013-08-14：&lt;/p&gt;

&lt;p&gt;发现会影响vc-mode（svn1.8），导致提交中文修改纪录时报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emacs svn: E000022: Can&#39;t convert string from native encoding to &#39;UTF-8&#39;:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;暂未处理，后续处理了再补在这里。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>内核资源泄漏样本之一</title>
      <link>http://boxcounter.com/technique/2012-11-02-%E5%86%85%E6%A0%B8%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E6%A0%B7%E6%9C%AC%E4%B9%8B%E4%B8%80/</link>
      <pubDate>Fri, 02 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2012-11-02-%E5%86%85%E6%A0%B8%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E6%A0%B7%E6%9C%AC%E4%B9%8B%E4%B8%80/</guid>
      <description>

&lt;p&gt;又遇到一个很好玩的内核资源泄漏样本，分享一下。&lt;br /&gt;
某台WinXP sp3系统出现了死机现象，该现象是在安装了我的驱动后才出现的，第一反应是“MD，怎么又泄漏了”。&lt;br /&gt;
以下是分析过程：&lt;/p&gt;

&lt;h1 id=&#34;poolused的输出:d0f14dd6c2c81221381bb269dedb95d3&#34;&gt;!poolused的输出&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; !poolused 2

Sorting by NonPaged Pool Consumed

           NonPaged                  Paged
Tag     Allocs         Used     Allocs         Used

tsni     62403     33947232          0            0 UNKNOWN pooltag &#39;tsni&#39;, please update pooltag.txt
FMvo     21652     21825376          0            0 FLT_VOLUME structure , Binary: fltmgr.sys
SBcx     10828     11780864          0            0 UNKNOWN pooltag &#39;SBcx&#39;, please update pooltag.txt
Devi     32861     10905648          0            0 Device objects 
FMis     10841      6503328          0            0 FLT_INSTANCE structure , Binary: fltmgr.sys
Drti     10844      5899136          0            0 UNKNOWN pooltag &#39;Drti&#39;, please update pooltag.txt
FMrr     21682      2425184          0            0 Per-processor Cache-aware rundown ref structure , Binary: fltmgr.sys
FMct     10841      2339864          0            0 TRACK_COMPLETION_NODES structure , Binary: fltmgr.sys
Tef2       220      2242016          0            0 UNKNOWN pooltag &#39;Tef2&#39;, please update pooltag.txt
WPSd       278      1677896          0            0 UNKNOWN pooltag &#39;WPSd&#39;, please update pooltag.txt
MmCm        30       963440          0            0 Calls made to MmAllocateContiguousMemory , Binary: nt!mm
Pp       10822       779184        287        33456 UNKNOWN pooltag &#39;Pp  &#39;, please update pooltag.txt
DmaB        34       729088          0            0 UNKNOWN pooltag &#39;DmaB&#39;, please update pooltag.txt
Io       16786       693632        156         6480 general IO allocations , Binary: nt!io
Thre      1033       661120          0            0 Thread objects , Binary: nt!ps
File      3038       465648          0            0 File objects 
FMwi     10831       433240          0            0 Work item structures , Binary: fltmgr.sys
iAEC       183       361992          0            0 UNKNOWN pooltag &#39;iAEC&#39;, please update pooltag.txt
SEY4      2970       332752          0            0 UNKNOWN pooltag &#39;SEY4&#39;, please update pooltag.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见fltmgr的卷相关资源占用特别严重（tag名以&amp;rdquo;FM&amp;rdquo;开头的几项，如&amp;rdquo;FMvo&amp;rdquo;和&amp;rdquo;FMi&amp;rdquo;等）&lt;br /&gt;
fltmgr.sys是微软的文件过滤驱动，一般可以排除由它导致资源泄漏的可能性。于是想到可能是基于fltmgr的minifilter驱动引起此故障。&lt;br /&gt;
于是继续列举系统中目前以存在的minifilter驱动。&lt;/p&gt;

&lt;h1 id=&#34;fltkd-filters的输出:d0f14dd6c2c81221381bb269dedb95d3&#34;&gt;!fltkd.filters的输出&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; !fltkd.filters

Filter List: 8999805c &amp;quot;Frame 1&amp;quot; 
   FLT_FILTER: 897e5ba8 &amp;quot;SEyeFilter&amp;quot; &amp;quot;382020&amp;quot;
      FLT_INSTANCE: 89965510 &amp;quot;SEyeFilter - Top Instance&amp;quot; &amp;quot;382020&amp;quot;
      FLT_INSTANCE: 89964b50 &amp;quot;SEyeFilter - Top Instance&amp;quot; &amp;quot;382020&amp;quot;
   FLT_FILTER: 89e8be68 &amp;quot;SPBBCDrv&amp;quot; &amp;quot;365100&amp;quot;
      FLT_INSTANCE: 89987420 &amp;quot;SPBBCDrv&amp;quot; &amp;quot;365100&amp;quot;
      FLT_INSTANCE: 89984008 &amp;quot;SPBBCDrv&amp;quot; &amp;quot;365100&amp;quot;
   FLT_FILTER: 89e4aba8 &amp;quot;eeCtrl&amp;quot; &amp;quot;329010&amp;quot;
      FLT_INSTANCE: 89ec5c28 &amp;quot;eeCtrl&amp;quot; &amp;quot;329010&amp;quot;
      FLT_INSTANCE: 899ba008 &amp;quot;eeCtrl&amp;quot; &amp;quot;329010&amp;quot;
   FLT_FILTER: 89ab9568 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
      FLT_INSTANCE: 89981de0 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
      FLT_INSTANCE: 89982270 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
      FLT_INSTANCE: 896dd780 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
      FLT_INSTANCE: 896be9d8 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
   FLT_FILTER: 893e0e30 &amp;quot;vfsmfd&amp;quot; &amp;quot;263410&amp;quot;
      FLT_INSTANCE: 893f6008 &amp;quot;VEAI&amp;quot; &amp;quot;263400&amp;quot;
      FLT_INSTANCE: 89649008 &amp;quot;VEAI&amp;quot; &amp;quot;263400&amp;quot;
      FLT_INSTANCE: 895ee008 &amp;quot;VEAI&amp;quot; &amp;quot;263400&amp;quot;
      FLT_INSTANCE: 895f0008 &amp;quot;VEAI&amp;quot; &amp;quot;263400&amp;quot;
      FLT_INSTANCE: 893f67c0 &amp;quot;Default&amp;quot; &amp;quot;263410&amp;quot;
   FLT_FILTER: 8971bb58 &amp;quot;WavxDMgr&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 89cf58b0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 8997b400 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 896de608 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 896d7998 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 89230cf0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 87018878 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 870076a8 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 87018b30 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 870032d0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 8700e970 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 87003008 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 87003580 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 86fffdb0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 86ff02d0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      ... 省略若干重复输出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现WavxDmgr这个minifilter对卷设备进行了上万次的挂载（有上万条“FLT_INSTANCE: XXXXXXXX &amp;ldquo;WavxDMgr Instance&amp;rdquo; &amp;ldquo;145300&amp;rdquo;”），&lt;br /&gt;
因此占用了大量的Nonpaged Pool资源。有理由猜测某种操作触发了WavxDmgr的BUG，导致它疯狂的进行挂载操作，最终导致系统资源耗尽而死机。&lt;/p&gt;

&lt;p&gt;以“WavxDmgr”为关键字搜索，可以找到这么一篇文章：&lt;a href=&#34;http://www.novell.com/zh-cn/documentation/zenworks11/readme/data/readme_zenworks11sp2.html&#34;&gt;Novell ZENworks 11 SP2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中有一段相关的说明：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2.6.3 数据加密与 Tablet PC 上的 Dell ControlPoint Security Manager 不兼容&lt;br /&gt;
如果将数据加密策略应用到使用 Dell ControlPoint Security Manager 的 Tablet PC，设备将无法重引导到操作系统。&lt;br /&gt;
此问题是因 Dell ControlPoint Security Manager 驱动程序 (WavxDMgr.sys) 过渡使用文件系统堆栈所致。对于任何使用名称解析且晚于该安全管理器驱动程序装载的文件系统过滤器驱动程序，都可能会发生同样的结果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而我的驱动正好符合“使用名称解析且晚于该安全管理器驱动程序装载的文件系统过滤器驱动程序”，于是触发了WavxDmgr的资源泄漏BUG。&lt;/p&gt;

&lt;h1 id=&#34;验证:d0f14dd6c2c81221381bb269dedb95d3&#34;&gt;验证&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; !for_each_module s -a @#Base @#End &amp;quot;tsni&amp;quot;
a7e0f300  74 73 6e 69 14 02 00 00-68 c9 54 80 50 c9 54 80  tsni....h.T.P.T.
a7e10ba3  74 73 6e 69 68 14 02 00-00 53 53 53 68 e0 f2 e0  tsnih....SSSh...

0: kd&amp;gt; lm a a7e0f300
start    end        module name
a7ddb000 a7e14180   WavxDMgr   (deferred)             

0: kd&amp;gt; lm a a7e10ba3
start    end        module name
a7ddb000 a7e14180   WavxDMgr   (deferred)             

0: kd&amp;gt; !for_each_module s -a @#Base @#End &amp;quot;SBcx&amp;quot;
a7e0e114  53 42 63 78 00 00 00 00-00 00 00 00 00 00 00 00  SBcx............

0: kd&amp;gt; lm a a7e0e114
start    end        module name
a7ddb000 a7e14180   WavxDMgr   (deferred)             

0: kd&amp;gt; !for_each_module s -a @#Base @#End &amp;quot;Drti&amp;quot;
a7dde5ad  44 72 74 69 68 18 02 00-00 6a 00 ff 15 e8 df e0  Drtih....j......

0: kd&amp;gt; lm a a7dde5ad
start    end        module name
a7ddb000 a7e14180   WavxDMgr   (deferred)             
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是这厮！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>64位系统的对齐问题</title>
      <link>http://boxcounter.com/technique/2012-10-25-64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 25 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2012-10-25-64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;今天在技术群里有位童鞋问了一个问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;On 64-bit Windows, if a data structure is misaligned, routines that manipulate the structure, such as RtlCopyMemory and memcpy, will not fault. Instead, they will raise an exception. For example:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&amp;gt;  &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;#&lt;/span&gt;pragma pack (1) &lt;span style=&#34;color: #008000&#34;&gt;// also set by /Zp switch &lt;/span&gt;
&amp;gt;  &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Buffer {
&amp;gt;      ULONG size;
&amp;gt;      &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *ptr;
&amp;gt;  };
&amp;gt;
&amp;gt;  &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; SetPointer(&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *p) {
&amp;gt;      &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Buffer s;
&amp;gt;      s.ptr = p;  &lt;span style=&#34;color: #008000&#34;&gt;/* will cause alignment fault */&lt;/span&gt;
&amp;gt;      ...
&amp;gt;  }
&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;You could use the UNALIGNED macro to fix this:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&amp;gt;  &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; SetPointer(&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *p) {
&amp;gt;      &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Buffer s;
&amp;gt;      *(UNALIGNED &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *)&amp;amp;s.ptr = p;
&amp;gt;  }
&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　我搜了一下，这段话来自&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/windows/hardware/ff559744.aspx&#34;&gt;Porting Issues Checklist&lt;/a&gt;这篇文章。&lt;/p&gt;

&lt;p&gt;　　他的问题是：「我对这句 s.ptr = p 不太明白。为什么会引发对齐错误，什么意思？」&lt;/p&gt;

&lt;p&gt;　　我的回答（当时的原话，貌似有点凌乱，群里讨论嘛，想一句说一句，见谅）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;因为s这个结构体的首地址是被编译器默认对齐的。由于「#pragma pack (1)」，s.ptr肯定不在对齐的地址上。所以访问s.ptr时会触犯x64 win的对齐规定，于是抛出异常。&lt;/li&gt;
&lt;li&gt;对于x86架构，对于类似这种没有对齐的地址访问，win内核会自动帮你处理好，用户感觉不到这个问题的存在。但实际上会导致系统性能下降。&lt;br /&gt;
到了x64架构，win决定不帮用户擦屁股了。于是就会抛出异常。&lt;/li&gt;
&lt;li&gt;x64是按照8字节对齐，&amp;amp;s是对齐的，那s.ptr是处在 （N*8 + 4）的地址上，于是没有对齐。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　这时另一位提了一个问题：「#pragma pack (1) 了，对齐地址是按1的倍数来的，为什么会s.ptr不在对齐的地址上啊？」&lt;br /&gt;
　　我的回答：「pragma pack的对齐只是影响编译器对结构体的padding，这个俗称的对齐，跟硬件手册里的对齐，不是一回事。」&lt;/p&gt;

&lt;p&gt;　　回答完后觉得心理有点不踏实，主要的不确定点是回答3中的「x64是按照8字节对齐」。翻了下手册，果然没这么简单。&lt;br /&gt;
　　（x64架构的）cpu的对齐是根据数据类型的不同而不同的，对于第一个问题，s.ptr是个指针，确实是按照8个字节来对齐的，所以我的回答没有问题。&lt;br /&gt;
　　更具体的对齐在《AMD64 Architecture Programmer&amp;rsquo;s Manual Volume 2: System Programming》的「8.2.17  #AC—Alignment-Check Exception (Vector 17)」，如下图：&lt;br /&gt;
　　&lt;img src=&#34;http://boxcounter.com/images/2012-10-25/Data-Type-Alignment.jpg&#34;/&gt;&lt;/p&gt;

&lt;p&gt;　　还有个问题，为什么不对齐就会影响性能？&lt;br /&gt;
　　以x64位下的void* 数据类型为例，void&lt;em&gt;是8个字节大小。如果某void&lt;/em&gt; p没有按照8字节对齐，比如下图所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;addr:      N*8           (N+1)*8
           |               |
offset:     0 1 2 3 4 5 6 7
          +-+-+-+-+-+-+-+-+-+
          | |X|X|X|X|X|X|X|X|
          +-----------------+
            ^
            |
            p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　如果按照8字节对齐，即ptr处在N*8的位置，那么当需要访问ptr的时候，把ptr的值从mem读到cpu cache，只需要一次读取操作（从N*8到N*8+7，正好8个字节）。&lt;br /&gt;
　　但是如果如上图所示，那么就不得不读两次，第一次也是从N*8到(N+1)*8，第二次读取(N+1)*8到(N+1)*8+7，然后还要把第一次读的后7个字节和第二次读的第一个字节拼起来。此外，在多核环境下，为了保证对ptr的读取操作的原子性，还必须额外消耗一个bus control。另外，unaligned的ptr还有可能分布在两个cache line中，导致更多额外的处理成本（每次对ptr的修改操作会影响两个cache line，造成更严重的&lt;a href=&#34;http://software.intel.com/en-us/articles/avoiding-and-identifying-false-sharing-among-threads/&#34;&gt;False Sharing&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;　　再多想想，有人可能会问：对于WORD类型，只要求2字节对齐，那如果具体的内存是这样呢：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;addr:      N*8
           |
offset:     0 1 2 3 4 5 6 7
          +-+-+-+-+-+-+-+-+
          | | |X|X| | | | |
          +---------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这样虽然是按照2字节对齐，但是并没有在N*8的位置，会不会有性能损耗？&lt;/p&gt;

&lt;p&gt;　　理论上是有的，因为读取到cpu cache后，还有个+2的操作（理论上有，但我不确定到电路那一层，+0和+2的耗时是不是就等价了）。但即便有这个+2的操作，也没太大影响，因为对cpu cache的操作是非常非常快的，而mem-&amp;gt;cpu cache这个操作相对来说就非常耗时了。&lt;br /&gt;
　　总结：性能损耗主要是因为多了一次mem-&amp;gt;cpu cache操作。&lt;/p&gt;

&lt;p&gt;　　注：&lt;br /&gt;
　　在整理这篇文章之前，我不确定多一次读操作是不是导致性能损耗的主要原因，于是请教sinster师傅，对话如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Boxcounter 18:43:11&lt;br /&gt;
贾佳师傅，请教个问题：&lt;br /&gt;
访问unaligned的数据会造成性能下降，比如64位系统，某个void*类型的数据如果是unaligned。那么访问它时会导致2次从内存到cpu cache的读操作，而如果它是aligned，则只需要一次。&lt;br /&gt;
是因为这个原因吗？&lt;/p&gt;

&lt;p&gt;sinister 18:43:55&lt;br /&gt;
是，有些系统直接CORE DUMP了。&lt;br /&gt;
sinister 18:44:44&lt;br /&gt;
一些RISC的，POWER,SPARC,EPIC 都这样&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　后记1：&lt;br /&gt;
　　提问的童鞋说在x64 WinXP系统里，即使不对齐也没有因为异常而中断下来。&lt;br /&gt;
　　我试了下，确实如此，x64 win7系统，挂着windbg内核调试，单步步过unaligned操作，并没有任何提示和中断等异样。恢复到一个没有任何调试设置的快照，也是如此。应用层也是一样。&lt;/p&gt;

&lt;p&gt;　　继续琢磨，在AMD手册里翻到这么几段资料：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;还是在「8.2.17  #AC—Alignment-Check Exception (Vector 17)」&lt;br /&gt;
&lt;blockquote&gt;
After a processor reset, #AC exceptions are disabled. Software enables the #AC exception by setting&lt;br /&gt;
the following register bits:&lt;br /&gt;
• CR0.AM=1.&lt;br /&gt;
• RFLAGS.AC=1.&lt;br /&gt;
When the above register bits are set, an #AC can occur only when CPL=3. #AC never occurs when&lt;br /&gt;
CPL &amp;lt; 3.&lt;br /&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CR0中AM标志在第18bit，RFLAGS的AC标志也是在18bit
查看了下我的虚拟机：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; r efl
efl=00000246


0: kd&amp;gt; .formats 0x246
  ......
  Binary:  00000000 00000000 00000000 00000000 00000000 00000000 00000010 01000110
  ......


0: kd&amp;gt; r cr0
cr0=0000000080050031


0: kd&amp;gt; .formats 0x0000000080050031 
  ......
  Binary:  11111111 11111111 11111111 11111111 10000000 00000101 00000000 00110001
  ......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见两个18bit都是0，并没有启用#AC异常。
为了避免是内核调试器对虚拟系统的干扰造成的，我用livekd抓了个本机系统DMP来分析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; r cr0
cr0=0000000080050033


0: kd&amp;gt; .formats 0000000080050033
  ......
  Binary:  11111111 11111111 11111111 11111111 10000000 00000101 00000000 00110011
  ......


0: kd&amp;gt; r efl
efl=00000286


0: kd&amp;gt; .formats 00000286
  ......
  Binary:  00000000 00000000 00000000 00000000 00000000 00000000 00000010 10000110
  ......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果是一样的，也没有启用#AC异常。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　不明白为什么，难道MSDN上那篇文章里的64bit仅指IA64？&lt;br /&gt;
　　目前暂没什么好的思路，先记到这里吧。（如果有朋友知道原因，请不吝赐教。）&lt;/p&gt;

&lt;p&gt;　　后记2：&lt;br /&gt;
　　发现一篇相关的文章：&lt;a href=&#34;http://stackoverflow.com/questions/5498102/how-to-debug-unaligned-accesses-on-amd64-using-visual-studio&#34;&gt;How to debug unaligned accesses on amd64 using Visual Studio?&lt;/a&gt;&lt;br /&gt;
　　其中有一条回复是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;How do real world Windows developers track unaligned accesses in their code?&amp;rdquo;. Being a primarily Windows developer myself, I think they just never do it, unless the code has to run on Itanium. And if it has to run on Itanium, the exception will tell the places. What is the real overhead of unaligned access on x86? BTW, you can still use assembly on x64, in .asm files, just not inline assembly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　后记3（2013-01-06）：&lt;br /&gt;
　　群里的朋友分享了新资料：&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms177389.aspx&#34;&gt;__unaligned&lt;/a&gt;，里面有这么一段话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The __unaligned modifier is valid for the x64 and Itanium compilers but affects only applications that target an IPF computer. This modifier describes the alignment of the addressed data only; the pointer itself is assumed to be aligned.&lt;br /&gt;
The Itanium processor generates an alignment fault when it accesses misaligned data, and the time to process the fault weakens performance. Use the __unaligned modifier to cause the processor to read data one byte at a time and avoid the fault. This modifier is not required for x64 applications because the x64 processor handles misaligned data without faulting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　也就是说，确实只有在IA64环境才会凸显出来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>有关STATUS_THREAD_IS_TERMINATING</title>
      <link>http://boxcounter.com/technique/2012-10-16-%E6%9C%89%E5%85%B3STATUS_THREAD_IS_TERMINATING/</link>
      <pubDate>Tue, 16 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2012-10-16-%E6%9C%89%E5%85%B3STATUS_THREAD_IS_TERMINATING/</guid>
      <description>&lt;p&gt;手头有个驱动，因为客户需求的原因，只在x86的2k3和xp系统上做过测试，今天在把它往x64 win7系统移植的时候遇到这么一个问题：&lt;br /&gt;
　　在PsSetCreateProcessNotifyRoutine注册的回调函数中，通过FltSendMessage发通知给应用层接收者。在发送“进程退出”事件时FltSendMessage总是会返回STATUS_THREAD_IS_TERMINATING（0xC000004B）。&lt;/p&gt;

&lt;p&gt;　　琢磨了一会，找到了问题关键，分析过程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定位返回STATUS_THREAD_IS_TERMINATING的点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1: kd&amp;gt; pc
fltmgr!FltSendMessage+0x1bf:
fffff880`011a1ddf call    qword ptr [fltmgr!_imp_FsRtlCancellableWaitForMultipleObjects (fffff880`011a75c8)]


1: kd&amp;gt; p
fltmgr!FltSendMessage+0x1c5:
fffff880`011a1de5 mov     ebx,eax


1: kd&amp;gt; r eax
eax=c000004b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里定位到在FltSendMessage函数中是FsRtlCancellableWaitForMultipleObjects这个函数返回的这个错误。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;继续更细致的定位&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
nt! ?? ::NNGAKEGL::`string&#39;+0xcb90:
fffff800`0418d031 mov     rax,qword ptr gs:[188h]
fffff800`0418d03a mov     ecx,dword ptr [rax+448h]
fffff800`0418d040 test    cl,1
fffff800`0418d043 jne     nt! ?? ::NNGAKEGL::`string&#39;+0xcc16 (fffff800`0418d0b7)
...
nt! ?? ::NNGAKEGL::`string&#39;+0xcc16:
fffff800`0418d0b7 mov     eax,0C000004Bh
fffff800`0418d0bc jmp     nt!FsRtlCancellableWaitForMultipleObjects+0x69 (fffff800`0416a271)
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很幸运，就是FsRtlCancellableWaitForMultipleObjects这个函数返回的STATUS_THREAD_IS_TERMINATING。
（有时候要深入好几层函数调用才能定位到错误码的直接返回者）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据2中的汇编码，继续分析&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1: kd&amp;gt; dp gs:[188h]
002b:00000000`00000188  fffffa80`0d168b60 


1: kd&amp;gt; !pool fffffa80`0d168b60  2 
Pool page fffffa800d168b60 region is Nonpaged pool
*fffffa800d168b00 size:  500 previous size:  280  (Allocated) *Thre (Protected)
            Pooltag Thre : Thread objects, Binary : nt!ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看来这个地址是个线程结构体。
为了确认这个地址就是线程结构体的开头，再找个线程相关函数来看看吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; u nt!KeGetCurrentThread
nt!PsGetCurrentThread:
fffff800`03f23f40 mov   rax,qword ptr gs:[188h]
fffff800`03f23f49 ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么不是kthread就是ethread，而汇编码中取值的偏移是0x448，前者大小不对，那看看后者的0x448是什么吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 1 1: kd&amp;gt; dt nt!_ethread
 2 nt!_ETHREAD
 3    ...
 4    +0x448 CrossThreadFlags : Uint4B
 5    +0x448 Terminated       : Pos 0, 1 Bit
 6    +0x448 ThreadInserted   : Pos 1, 1 Bit
 7    +0x448 HideFromDebugger : Pos 2, 1 Bit
 8    +0x448 ActiveImpersonationInfo : Pos 3, 1 Bit
 9    +0x448 Reserved         : Pos 4, 1 Bit
10    +0x448 HardErrorsAreDisabled : Pos 5, 1 Bit
11    +0x448 BreakOnTermination : Pos 6, 1 Bit
12    +0x448 SkipCreationMsg  : Pos 7, 1 Bit
13    +0x448 SkipTerminationMsg : Pos 8, 1 Bit
14    +0x448 CopyTokenOnOpen  : Pos 9, 1 Bit
15    +0x448 ThreadIoPriority : Pos 10, 3 Bits
16    +0x448 ThreadPagePriority : Pos 13, 3 Bits
17    +0x448 RundownFail      : Pos 16, 1 Bit
18    +0x448 NeedsWorkingSetAging : Pos 17, 1 Bit
19  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对照着汇编码，可以知道在FsRtlCancellableWaitForMultipleObjects函数判断了当前线程的ethread::Terminated（行5）这个域，而在我的调试环境中该域是1，于是FsRtlCancellableWaitForMultipleObjects就返回了STATUS_THREAD_IS_TERMINATING。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　到这里，已经弄清楚了在什么情况下会出现这个错误。那解决方案也很简单，不赘述。&lt;/p&gt;

&lt;p&gt;　　另外，多说两句：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;这个特性是从vista开始引入。&lt;/li&gt;
&lt;li&gt;目的是为了保证线程结束的处理过程中不被卡住。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　参考资料：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osronline.com/showThread.cfm?link=110848&#34;&gt; STATUS_THREAD_IS_TERMINATING returned by FltSendMessage&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ZeroMemory与类对象</title>
      <link>http://boxcounter.com/technique/2012-09-20-ZeroMemory%E4%B8%8E%E7%B1%BB%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Thu, 20 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2012-09-20-ZeroMemory%E4%B8%8E%E7%B1%BB%E5%AF%B9%E8%B1%A1/</guid>
      <description>&lt;p&gt;今天看到一段同事的代码：&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;ZeroMemory(&amp;amp;m_PacketInfo, &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(packet_info));

&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; packet_info
{
    string m_strModule;                 &lt;span style=&#34;color: #008000&#34;&gt;//模块&lt;/span&gt;
    string m_strProtocol;               &lt;span style=&#34;color: #008000&#34;&gt;//协议&lt;/span&gt;
	string m_strClientHostIP;           &lt;span style=&#34;color: #008000&#34;&gt;//客户端IP&lt;/span&gt;
	string m_strClientHostPort;			&lt;span style=&#34;color: #008000&#34;&gt;//客户端端口&lt;/span&gt;
    ...
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;　　按照我的经验，这种对类对象进行ZeroMemory或者memset的代码会导致程序崩掉。因为会覆盖掉类对象中的关键域，比如虚表。但是同事在vs2005中这样做却很正常。让我很奇怪，于是花了点时间分析了下。&lt;/p&gt;

&lt;p&gt;　　首先，std::string的vc实现并没有虚表，如下：
&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;0:000&amp;gt; dt string
QueueTest!string
   +0x000 _Myproxy         : Ptr32 std::_Container_proxy
   +0x004 _Bx              : std::_String_val::_Bxty
   +0x014 _Mysize          : Uint4B
   +0x018 _Myres           : Uint4B
   +0x01c _Alval           : std::allocator
   =00000000&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;`&lt;/span&gt;01202180
   std::basic_string::npos : Uint4B
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;　　所以ZeroMemory后不会导致非法访问。&lt;/p&gt;

&lt;p&gt;　　翻了一下std::string的实现，发现就是一普通的模板类，没有用到继承等OO特性。跟一普通的结构体和一系列配套函数的简单组合没太大区别。&lt;/p&gt;

&lt;p&gt;　　于是写了一小段测试代码&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;Father&lt;/span&gt;
{
&lt;span style=&#34;color: #0000ff&#34;&gt;public&lt;/span&gt;:
    Father() {}
    ~Father(){}

    &lt;span style=&#34;color: #0000ff&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Show()
    {
        printf(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;Father\n&amp;quot;&lt;/span&gt;);
    }
};

&lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;Son&lt;/span&gt;: &lt;span style=&#34;color: #0000ff&#34;&gt;public&lt;/span&gt; Father
{
&lt;span style=&#34;color: #0000ff&#34;&gt;public&lt;/span&gt;:
    &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; Show()
    {
        printf(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;Son\n&amp;quot;&lt;/span&gt;);
    }
};

&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; main()
{
    Son son;

    son.Show();
    ZeroMemory(&amp;amp;son, &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(Son));
    son.Show();

    ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;　　我对这段代码的预期是，因为有继承以及虚函数，所以会有虚表。ZeroMemory会导致虚表被破坏，然后在第二次Show的时候非法访问。但实际运行效果依然正常。&lt;br /&gt;
　　于是检查了一下man的反汇编代码：
&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;0:000:&lt;/span&gt;x86&amp;gt; uf main
QueueTest&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;!&lt;/span&gt;main:
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd120 push    ebp
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd121 mov     ebp,esp
...
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd15d lea     ecx,[ebp-14h]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd160 call    QueueTest&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;!&lt;/span&gt;ILT+3860(??0SonQAEXZ) (002faf19)
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd165 mov     &lt;span style=&#34;color: #2b91af&#34;&gt;dword&lt;/span&gt; ptr [ebp-4],0
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd16c lea     ecx,[ebp-14h]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd16f call    QueueTest&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;!&lt;/span&gt;ILT+4840(?ShowSonUAEXXZ) (002fb2ed)
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd174 push    4
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd176 push    0
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd178 lea     eax,[ebp-14h]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd17b push    eax
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd17c call    QueueTest&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;!&lt;/span&gt;ILT+1520(_memset) (002fa5f5)
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd181 add     esp,0Ch
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd184 lea     ecx,[ebp-14h]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd187 call    QueueTest&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;!&lt;/span&gt;ILT+4840(?ShowSonUAEXXZ) (002fb2ed)
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd18c mov     &lt;span style=&#34;color: #2b91af&#34;&gt;dword&lt;/span&gt; ptr [ebp-4],0FFFFFFFFh
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd193 lea     ecx,[ebp-14h]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd196 call    QueueTest&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;!&lt;/span&gt;ILT+4125(??1SonQAEXZ) (002fb022)
...
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd1c9 mov     esp,ebp
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd1cb pop     ebp
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;002&lt;/span&gt;fd1cc ret
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;　　可以看出来，这段代码里根本就没有用到虚表，而是直接把内嵌函数地址。仔细琢磨琢磨，这样做确实有些道理：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;son是明确的Son类对象，son.Show是一个明确的函数，无需使用虚表进行间接调用。&lt;/li&gt;
&lt;li&gt;效率更高。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　再想想什么时候才需要虚表呢？动态绑定。&lt;br /&gt;
　　于是改了改测试代码，如下（Father和Son的定义不变）：&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; main()
{
    Son son;
    Father *pson = (Father*)&amp;amp;son;

    pson-&amp;gt;Show();
    ZeroMemory(&amp;amp;son, &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(Son));
    pson-&amp;gt;Show();
    ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;　　看看反汇编码：
&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;0:000:&lt;/span&gt;x86&amp;gt; uf main
QueueTest&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;!&lt;/span&gt;main:
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad120 push    ebp
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad121 mov     ebp,esp
...
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad15d lea     ecx,[ebp-14h]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad160 call    QueueTest&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;!&lt;/span&gt;ILT+3860(??0SonQAEXZ) (011aaf19)
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad165 mov     &lt;span style=&#34;color: #2b91af&#34;&gt;dword&lt;/span&gt; ptr [ebp-4],0
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad16c lea     eax,[ebp-14h]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad16f mov     &lt;span style=&#34;color: #2b91af&#34;&gt;dword&lt;/span&gt; ptr [ebp-20h],eax
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad172 mov     eax,&lt;span style=&#34;color: #2b91af&#34;&gt;dword&lt;/span&gt; ptr [ebp-20h]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad175 mov     edx,&lt;span style=&#34;color: #2b91af&#34;&gt;dword&lt;/span&gt; ptr [eax]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad177 mov     esi,esp
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad179 mov     ecx,&lt;span style=&#34;color: #2b91af&#34;&gt;dword&lt;/span&gt; ptr [ebp-20h]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad17c mov     eax,&lt;span style=&#34;color: #2b91af&#34;&gt;dword&lt;/span&gt; ptr [edx]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad17e call    eax &amp;lt;--------
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad180 cmp     esi,esp
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad182 call    QueueTest&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;!&lt;/span&gt;ILT+3870(__RTC_CheckEsp) (011aaf23)
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad187 push    4
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad189 push    0
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad18b lea     eax,[ebp-14h]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad18e push    eax
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad18f call    QueueTest&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;!&lt;/span&gt;ILT+1520(_memset) (011aa5f5)
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad194 add     esp,0Ch
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad197 mov     eax,&lt;span style=&#34;color: #2b91af&#34;&gt;dword&lt;/span&gt; ptr [ebp-20h]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad19a mov     edx,&lt;span style=&#34;color: #2b91af&#34;&gt;dword&lt;/span&gt; ptr [eax]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad19c mov     esi,esp
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad19e mov     ecx,&lt;span style=&#34;color: #2b91af&#34;&gt;dword&lt;/span&gt; ptr [ebp-20h]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad1a1 mov     eax,&lt;span style=&#34;color: #2b91af&#34;&gt;dword&lt;/span&gt; ptr [edx]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad1a3 call    eax &amp;lt;--------
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad1a5 cmp     esi,esp
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad1a7 call    QueueTest&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;!&lt;/span&gt;ILT+3870(__RTC_CheckEsp) (011aaf23)
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad1ac mov     &lt;span style=&#34;color: #2b91af&#34;&gt;dword&lt;/span&gt; ptr [ebp-4],0FFFFFFFFh
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad1b3 lea     ecx,[ebp-14h]
...
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad1e9 mov     esp,ebp
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad1eb pop     ebp
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;011&lt;/span&gt;ad1ec ret
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;　　可以看到这次用了虚表。再运行，果然崩了。&lt;/p&gt;

&lt;p&gt;　　但是gcc的实现不同，于是最开始的那行ZeroMemory一跑就崩。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>又一个内核资源泄漏样本</title>
      <link>http://boxcounter.com/technique/2012-08-15-%E5%8F%88%E4%B8%80%E4%B8%AA%E5%86%85%E6%A0%B8%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E6%A0%B7%E6%9C%AC/</link>
      <pubDate>Wed, 15 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2012-08-15-%E5%8F%88%E4%B8%80%E4%B8%AA%E5%86%85%E6%A0%B8%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E6%A0%B7%E6%9C%AC/</guid>
      <description>&lt;p&gt;这两天在处理一个内核资源泄漏的问题，整个分析过程比较典型，记在这里以便以后参考。&lt;/p&gt;

&lt;p&gt;　　这个问题发生在测试部同事的真实机上，于是抓内核DMP用的是sysinternals的livekd，命令行很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;livekd -o dump-file-path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　注：为了分析，我开了GFlags中的kernel pool tagging功能。&lt;/p&gt;

&lt;p&gt;　　分析过程如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 1 0: kd&amp;gt; !vm
 2 
 3 *** Virtual Memory Usage ***
 4  Physical Memory:      842859 (   3371,436 Kb)
 5  ...（Boxcounter：此处省略PagingFile相关输出）
 6  Available Pages:      582485 (   2329,940 Kb)
 7  ResAvail Pages:       756136 (   3024,544 Kb)
 8  Locked IO Pages:          51 (       204 Kb)
 9  Free System PTEs:      32523 (    130,092 Kb)
10  Free NP PTEs:          32767 (    131,068 Kb)
11  Free Special NP:       94800 (    379,200 Kb)[/font]
12  Modified Pages:        17626 (     70,504 Kb)
13  Modified PF Pages:     17131 (     68,524 Kb)
14  NonPagedPool Usage:     4096 (     16,384 Kb) &amp;lt;&amp;lt;
15  NonPagedPoolNx Usage:   5076 (     20,304 Kb)
16  NonPagedPool Max:      65536 (    262,144 Kb)
17  PagedPool 0 Usage:      7665 (     30,660 Kb)
18  PagedPool 1 Usage:     16753 (     67,012 Kb)
19  PagedPool 2 Usage:     16728 (     66,912 Kb)
20  PagedPool 3 Usage:     16766 (     67,064 Kb)
21  PagedPool 4 Usage:     16725 (     66,900 Kb)
22  PagedPool Usage:       74637 (    298,548 Kb) &amp;lt;&amp;lt;
23  PagedPool Maximum:     92160 (    368,640 Kb)
24  Session Commit:         2095 (      8,380 Kb)
25  Shared Commit:         13172 (     52,688 Kb)
26  Special Pool:           1175 (      4,700 Kb)
27  Shared Process:         3457 (     13,828 Kb)
28  PagedPool Commit:      74583 (    298,332 Kb) &amp;lt;&amp;lt;
29  Driver Commit:          3840 (     15,360 Kb)
30  Committed pages:      196936 (    787,744 Kb)
31  Commit limit:        2327741 (   9310,964 Kb)
32 
33  Total Private:         95118 (    380,472 Kb)
34          0c40 procexp.exe      19592 (     78,368 Kb)
35          0860 360Tray.exe      14027 (     56,108 Kb)
36          070c svchost.exe      13336 (     53,344 Kb)
37          068c explorer.exe      7362 (     29,448 Kb)
38          08b8 XDict.exe         7102 (     28,408 Kb)
39          0470 RTHDCPL.EXE       5785 (     23,140 Kb)
40          075c svchost.exe       4462 (     17,848 Kb)
41          06d4 SEye.exe          2513 (     10,052 Kb)
42          03b8 winlogon.exe      1739 (      6,956 Kb)
43          019c ZhuDongFangYu.e   1519 (      6,076 Kb)
44          ... （Boxcounter：省略剩余不重要的进程信息）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这段输出需要关注的重点是第16、22和28行。&lt;br /&gt;
　　看上去，nonpaged pool使用情况比较正常，主要嫌疑在paged pool上。&lt;br /&gt;
　　看看paged pool吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 1 0: kd&amp;gt; !poolused 5
 2    Sorting by  Paged Pool Consumed
 3 
 4   Pool Used:
 5             NonPaged                    Paged
 6  Tag    Allocs    Frees     Diff     Used   Allocs    Frees     Diff     Used
 7  prpt        0        0        0        0  4191169  1396976  2794193  203,976,160    UNKNOWN pooltag &#39;prpt&#39;, please update pooltag.txt
 8  otpu        0        0        0        0   349352       28   349324   30,269,696    UNKNOWN pooltag &#39;otpu&#39;, please update pooltag.txt
 9  INTC    38799    38410      389    95952  1355200  1352980     2220    9,142,856    Intel video driver 
10  Gh05        0        0        0        0   561321   560728      593    4,213,584    GDITAG_HMGR_SPRITE_TYPE , Binary: win32k.sys
11  UlHT        0        0        0        0        1        0        1    4,198,400    Hash Table , Binary: http.sys
12  MmSt        0        0        0        0  1463662  1462178     1484    3,680,824    Mm section object prototype ptes , Binary: nt!mm
13  VMON        2        0        2       72      648        0      648    2,646,432    Volume Manager , Binary: volmgr.sys
14  CM35        0        0        0        0       39       13       26    2,629,632    Internal Configuration manager allocations , Binary: nt!cm
15  Gcac        0        0        0        0      214      157       57    2,096,640    Gdi glyph cache 
16  Ttfd        0        0        0        0     3713     3023      690    1,275,080    TrueType Font driver 
17  Ifs   7166549  7166547        2      176  5361522  5360467     1055    1,131,376    Default file system allocations (user&#39;s of ntifs.h) 
18  Ddk   9649715  9649684       31   931176     2684      790     1894    1,087,824    Default for driver allocated memory (user&#39;s of ntddk.h) 
19  CMDa        0        0        0        0   216579   214244     2335      530,480    value data cache pool tag , Binary: nt!cm
20  Ntff       18        0       18     3744    84222    83589      633      526,656    FCB_DATA , Binary: ntfs.sys
21  Gla1        1        0        1      112     3961     3652      309      494,400    GDITAG_HMGR_LOOKASIDE_DC_TYPE , Binary: win32k.sys
22  Gla5        1        0        1      112     7449     6223     1226      480,592    GDITAG_HMGR_LOOKASIDE_SURF_TYPE , Binary: win32k.sys
23  logb        0        0        0        0     1959     1954        5      413,728    UNKNOWN pooltag &#39;logb&#39;, please update pooltag.txt
24  pipt        0        0        0        0   353979   351340     2639      407,664    UNKNOWN pooltag &#39;pipt&#39;, please update pooltag.txt
25  CM25        0        0        0        0      972      947       25      327,680    Internal Configuration manager allocations , Binary: nt!cm
26  Obtb        0        0        0        0   362905   362778      127      315,376    object tables via EX handle.c , Binary: nt!ob
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　重点是第7、8行这两个windbg不认识的tag。绝大部分的paged pool内存都是它们的。看看它们是谁。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\WINDOWS\system32\drivers&amp;gt;findstr /m /l prpt *sys
qutmdrv.sys

C:\WINDOWS\system32\drivers&amp;gt;findstr /m /l otpu *sys
qutmdrv.sys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　找到这个驱动，看了下属性，安全卫士的，该驱动的版本是7.2.1.1022。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://boxcounter.com/images/2012-08-15/pooltag.jpg&#34;/&gt;&lt;/p&gt;

&lt;p&gt;　　分析到这里我想起之前看过的&lt;a href=&#34;http://www.cnblogs.com/ahuo/archive/2010/09/29/1838439.html&#34;&gt;一个类似的样例&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　现在找到了一个嫌疑人，为了确认没有误伤，卸掉我的驱动重启，等了10来分钟，看内存和cpu占用都稳定了，启动纯应用层测试工具做压力测试。&lt;br /&gt;
　　在测试前抓了个dmp，当时状态是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; .time
Debug session time: Wed Aug 15 10:37:44.500 2012 (UTC + 8:00)
System Uptime: 0 days 0:13:07.406

 1 0: kd&amp;gt; !vm
 2 
 3 *** Virtual Memory Usage ***
 4  Physical Memory:      842859 (   3371436 Kb)
 5  ...（Boxcounter：此处省略PagingFile相关输出）
 6  Available Pages:      703681 (   2814,724 Kb)
 7  ResAvail Pages:       757240 (   3028,960 Kb)
 8  Locked IO Pages:          50 (       200 Kb)
 9  Free System PTEs:     104176 (    416,704 Kb)
10  Free NP PTEs:          32767 (    131,068 Kb)
11  Free Special NP:       95598 (    382,392 Kb)
12  Modified Pages:         1698 (      6,792 Kb)
13  Modified PF Pages:       545 (      2,180 Kb)
14  NonPagedPool Usage:     4096 (     16,384 Kb) &amp;lt;&amp;lt;
15  NonPagedPoolNx Usage:   3164 (     12,656 Kb)
16  NonPagedPool Max:      65536 (    262,144 Kb)
17  PagedPool 0 Usage:      8987 (     35,948 Kb)
18  PagedPool 1 Usage:       934 (      3,736 Kb)
19  PagedPool 2 Usage:       934 (      3,736 Kb)
20  PagedPool 3 Usage:       923 (      3,692 Kb)
21  PagedPool 4 Usage:       944 (      3,776 Kb)
22  PagedPool Usage:       12722 (     50,888 Kb) &amp;lt;&amp;lt;
23  PagedPool Maximum:     92160 (    368,640 Kb)
24  Shared Commit:         11888 (     47,552 Kb)
25  Special Pool:            273 (      1,092 Kb)
26  Shared Process:         3503 (     14,012 Kb)
27  PagedPool Commit:      12690 (     50,760 Kb) &amp;lt;&amp;lt;
28  Driver Commit:          3807 (     15,228 Kb)
29  Committed pages:      111988 (    447,952 Kb)
30  Commit limit:        2327741 (   9310,964 Kb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　依然着重看第15、22和27行。&lt;/p&gt;

&lt;p&gt;　　再重点看看两个嫌疑人的状态。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; !poolused 1 prpt
   Sorting by  Tag

  Pool Used:
            NonPaged                    Paged
Tag    Allocs    Frees     Diff     Used   Allocs    Frees     Diff     Used
prpt        0        0        0        0     1081      296      785    57,376  UNKNOWN pooltag &#39;prpt&#39;, please update pooltag.txt
otpu        0        0        0        0      184       30      154    11,104  UNKNOWN pooltag &#39;otpu&#39;, please update pooltag.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这个输出我做了一些调整，!poolused命令不支持同时查询多个tag，我使用了两次，然后把结果合并了。&lt;/p&gt;

&lt;p&gt;　　看看经过几个小时的测试后的状态。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; .time
Debug session time: Wed Aug 15 15:26:00.875 2012 (UTC + 8:00)
System Uptime: 0 days 5:01:23.703

 1 0: kd&amp;gt; !vm
 2 
 3 *** Virtual Memory Usage ***
 4  Physical Memory:      842859 (   3,371,436 Kb)
 5     ...（Boxcounter：此处省略PagingFile相关输出）
 6  Available Pages:      604366 (   2,417,464 Kb)
 7  ResAvail Pages:       757320 (   3,029,280 Kb)
 8  Locked IO Pages:          50 (       200 Kb)
 9  Free System PTEs:     103840 (    415,360 Kb)
10  Free NP PTEs:          32767 (    131,068 Kb)
11  Free Special NP:       95604 (    382,416 Kb)
12  Modified Pages:         1883 (      7,532 Kb)
13  Modified PF Pages:       711 (      2,844 Kb)
14  NonPagedPool Usage:     4096 (     16,384 Kb) &amp;lt;&amp;lt;
15  NonPagedPoolNx Usage:   3144 (     12,576 Kb)
16  NonPagedPool Max:      65536 (    262,144 Kb)
17  PagedPool 0 Usage:      9867 (     39,468 Kb)
18  PagedPool 1 Usage:     11069 (     44,276 Kb)
19  PagedPool 2 Usage:     11059 (     44,236 Kb)
20  PagedPool 3 Usage:     11054 (     44,216 Kb)
21  PagedPool 4 Usage:     11077 (     44,308 Kb)
22  PagedPool Usage:       54126 (    216,504 Kb) &amp;lt;&amp;lt;
23  PagedPool Maximum:     92160 (    368,640 Kb)
24  Session Commit:         2107 (      8,428 Kb)
25  Shared Commit:         12882 (     51,528 Kb)
26  Special Pool:            267 (      1,068 Kb)
27  Shared Process:         3272 (     13,088 Kb)
28  PagedPool Commit:      54058 (    216,232 Kb) &amp;lt;&amp;lt;
29  Driver Commit:          3807 (     15,228 Kb)
30  Committed pages:      163773 (    655,092 Kb)
31  Commit limit:        2327741 (   9310,964 Kb)
32 
33  Total Private:         84063 (    336,252 Kb)
34          061c 360Tray.exe      14005 (     56,020 Kb)
35          0390 svchost.exe      13331 (     53,324 Kb)
36          0460 explorer.exe     10689 (     42,756 Kb)
37          0e18 procexp.exe       9525 (     38,100 Kb)
38          0658 XDict.exe         6997 (     27,988 Kb)
39          ...（Boxcounter：省略其余不重要输出）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　再来看看tag情况。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 1 0: kd&amp;gt; !poolused 5
 2    Sorting by  Paged Pool Consumed
 3 
 4   Pool Used:
 5             NonPaged                    Paged
 6  Tag    Allocs    Frees     Diff     Used   Allocs    Frees     Diff     Used
 7  prpt        0        0        0        0  2681313   893728  1787585 130,493,776 UNKNOWN pooltag &#39;prpt&#39;, please update pooltag.txt
 8  otpu        0        0        0        0   223536       32   223504  19,366,280 UNKNOWN pooltag &#39;otpu&#39;, please update pooltag.txt
 9  MmSt        0        0        0        0   740248   737979     2269  12,516,920 Mm section object prototype ptes , Binary: nt!mm
10  INTC   289851   289462      389    95952  1200152  1197885     2267   9,146,056 Intel video driver 
11  Gh05        0        0        0        0   350733   350137      596   4,870,704 GDITAG_HMGR_SPRITE_TYPE , Binary: win32k.sys
12  UlHT        0        0        0        0        1        0        1   4,198,400 Hash Table , Binary: http.sys
13  VMON        2        0        2       72      648        0      648   2,646,432 Volume Manager , Binary: volmgr.sys
14  CM35        0        0        0        0       39       13       26   2,629,632 Internal Configuration manager allocations , Binary: nt!cm
15  Gcac        0        0        0        0      343      277       66   2,356,704 Gdi glyph cache 
16  Ttfd        0        0        0        0     5625     4930      695   1,313,168 TrueType Font driver 
17  Ifs   3897847  3897844        3      240  3283105  3282050     1055   1,131,376 Default file system allocations (user&#39;s of ntifs.h) 
18  Ddk    622677   622646       31   931176     2654      760     1894   1,087,824 Default for driver allocated memory (user&#39;s of ntddk.h) 
19  Ntff       18        0       18     3744    19431    18491      940     782,080 FCB_DATA , Binary: ntfs.sys
20  pipt        0        0        0        0   229268   226053     3215     499,136 UNKNOWN pooltag &#39;pipt&#39;, please update pooltag.txt
21  ...（Boxcounter：省略其余不重要输出）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　第7、8行验证了前面的判断。目前不太清楚这是qutmdrv.sys的资源泄漏BUG，还是它的缓存机制。（最开始的情况更严重是因为那时已经测试约莫11个小时，而后面这次测试时间较短）&lt;/p&gt;

&lt;p&gt;　　分析过程不长，命令也就那么几个。不过确实耗了我不少时间，主要麻烦是问题不好重现和思维方式转不过弯（之前我的驱动正好刚出现过一次资源泄漏问题，所以这次一看到现象就​认为是我的驱动的问题……）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>VS2010编译regex库的问题</title>
      <link>http://boxcounter.com/technique/2012-05-31-VS2010%E7%BC%96%E8%AF%91regex%E5%BA%93%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 31 May 2012 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2012-05-31-VS2010%E7%BC%96%E8%AF%91regex%E5%BA%93%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;今天把一些VS 2005工程升级到VS 2010，在升级过程中，遇到regex库编译错误。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error C2332: &#39;struct&#39; : missing tag name
error C3306: &#39;regex::detail::&#39;: unnamed class template is not allowed
error C2143: syntax error : missing &#39;;&#39; before &#39;static_assert&#39;
error C2059: syntax error : &#39;;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　出现该错误的代码来自restack.h，如下：&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;namespace&lt;/span&gt; detail
{

&lt;span style=&#34;color: #008000&#34;&gt;// For compile-time assertions that generate&lt;/span&gt;
&lt;span style=&#34;color: #008000&#34;&gt;// no run-time overhead.&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;template&lt;/span&gt;&amp;lt; &lt;span style=&#34;color: #2b91af&#34;&gt;bool&lt;/span&gt; f &amp;gt; &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;static_assert&lt;/span&gt;;
&lt;span style=&#34;color: #0000ff&#34;&gt;template&lt;/span&gt;   &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;static_assert&lt;/span&gt; { &lt;span style=&#34;color: #0000ff&#34;&gt;static_assert&lt;/span&gt;() {} };
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;　　该问题的原因是regex定义的static_assert模板与VS 2010的关键字冲突，将regex中的改名，比如改成_static_assert后就正常了。&lt;/p&gt;

&lt;p&gt;　　参考资料：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://social.msdn.microsoft.com/Forums/eu/vcgeneral/thread/56800d4b-eb9d-43c0-b06a-38c1ebb117bc&#34;&gt;Greta Parser and VS 2010&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>关于STATUS_INVALID_DEVICE_OBJECT_PARAMETER和STATUS_MOUNT_POINT_NOT_RESOLVED</title>
      <link>http://boxcounter.com/technique/2012-05-20-%E5%85%B3%E4%BA%8ESTATUS_INVALID_DEVICE_OBJECT_PARAMETER%E5%92%8CSTATUS_MOUNT_POINT_NOT_RESOLVED/</link>
      <pubDate>Sun, 20 May 2012 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2012-05-20-%E5%85%B3%E4%BA%8ESTATUS_INVALID_DEVICE_OBJECT_PARAMETER%E5%92%8CSTATUS_MOUNT_POINT_NOT_RESOLVED/</guid>
      <description>&lt;p&gt;很久之前，我写了篇&lt;a href=&#34;http://www.boxcounter.com/showthread.php?tid=38&#34;&gt;关于STATUS_INVALID_DEVICE_OBJECT_PARAMETER的blog&lt;/a&gt;，里面提到使用STATUS_REPARSE的FsFilter（后简称为R-FsFilter）对上层FsFilter造成的恶劣干扰。&lt;/p&gt;

&lt;p&gt;　　这两天看Alex Carp的文章，发现事情貌似有转机。具体参考他的&lt;a href=&#34;http://fsfilters.blogspot.com/2012/02/reparsing-to-different-volume-in-win7.html&#34;&gt;Reparsing to a Different Volume in Win7 and Win8&lt;/a&gt;（需要爬墙）。&lt;/p&gt;

&lt;p&gt;　　我总结一下：&lt;br /&gt;
　　目前的win8提供了一种新的ECP和相应的数据结构，保证在返回STATUS_MOUNT_POINT_NOT_RESOLVED的时候开发者可以获得目标FO的FLT_FILE_NAME_INFORMATION和FLT_INSTANCE。&lt;br /&gt;
　　用我那篇blog的原型就是，当驱动A调用FltCreateFile失败后（Alex的文章里只提到了STATUS_MOUNT_POINT_NOT_RESOLVED，但我猜测对STATUS_INVALID_DEVICE_OBJECT_PARAMETER应该也是适用的，我还没有动手测试，只是看IopCheckTopDeviceHint的实现做出的猜测），可以从ECP中获取到本次打开操作的目标FO的FLT_FILE_NAME_INFORMATION和FLT_INSTANCE，然后再次FltCreateFile就可以了。&lt;/p&gt;

&lt;p&gt;　　说来简单，但实际上影响挺大的，这相当于要求所有的FsFilter开发者在调用FltCreateFile时都处理这种错误。仅仅是因为目标系统里可能会存在一个R-FsFilter。&lt;/p&gt;

&lt;p&gt;　　相信不会有太多的开发者会多写这些代码。&lt;br /&gt;
　　而且这个错误对上层FsFilter的开发者来说根本就不是问题。如果在客户机上出现这种问题，完全可以如此解释：“你看，卸载您安装的这个产品（姑且称为T）的驱动后，我公司的产品就能正常工作了。但是只要一安装它，我公司的产品就出问题了，你看你看，另一个公司的产品也不能工作了。这明显是T的问题，跟我公司的产品没有半毛钱关系。”&lt;/p&gt;

&lt;p&gt;　　悲催的是R-FsFilter开发者，知道问题有解决方案，但是却不能在自己的代码里解决……。&lt;/p&gt;

&lt;p&gt;　　或者，R-FsFilter开发者在开发完之后，再多写一个紧贴着它的上层驱动，专门处理STATUS_MOUNT_POINT_NOT_RESOLVED/STATUS_INVALID_DEVICE_OBJECT_PARAMETER？这要求必须使用支持固定加载层次的minifilter框架，并且MS要足够给面子提供两个相邻的Altitude，不过以我之前申请Altitude的经验，貌似有些难度。&lt;/p&gt;

&lt;p&gt;　　另外推荐Alex-Cap的几篇关于reparse技术的博文。其实他blog的每篇技术文章都推荐仔细阅读，我几乎备份了他所有的博文……&lt;/p&gt;

&lt;p&gt;　　注：由于本人能力有限，行文难免有错，请不吝赐教，感谢。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>