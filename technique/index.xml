<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Techniques on Boxcounter的烂笔头</title>
    <link>http://boxcounter.com/technique/index.xml</link>
    <description>Recent content in Techniques on Boxcounter的烂笔头</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 26 Nov 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://boxcounter.com/technique/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Host key verification failed的另类触发</title>
      <link>http://boxcounter.com/technique/2016-11-26-Host-key-verification-failed/</link>
      <pubDate>Sat, 26 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2016-11-26-Host-key-verification-failed/</guid>
      <description>

&lt;p&gt;最近几天在编写、测试部署脚本，准备配合Jenkins进行自动化的持续集成，因此需要全程静默执行，未想触发了一个SSH key问题，卡了我好几个小时……&lt;/p&gt;

&lt;h1 id=&#34;问题现象&#34;&gt;问题现象&lt;/h1&gt;

&lt;p&gt;从GitHub上clone过仓库的码农们都知道，用SSH比HTTPs更可靠。但SSH初次连接服务器时，通常会询问是否接受连接，比如这样：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The authenticity of host &amp;lsquo;github.com (192.30.252.1)&amp;rsquo; can&amp;rsquo;t be established.&lt;br /&gt;
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.&lt;br /&gt;
Are you sure you want to continue connecting (yes/no)?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常大家手输yes就可以继续clone代码了。而静默执行的脚本通常会在建立连接之前将目标站点保存到&lt;code&gt;known_hosts&lt;/code&gt;，以跳过询问。&lt;/p&gt;

&lt;p&gt;在我的脚本里是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh_dir=&amp;quot;${HOME}/.ssh&amp;quot;
...
ssh-keyscan -v -t rsa ssh.github.com &amp;gt; ${ssh_dir}/known_hosts
git clone git@github.com:...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但诡异的是在Jenkins部署过程中并没有生效，还是在建立SSH连接时卡住然后报错「Host key verification failed」。如果打开pty选项，则会如前面那样询问是否接受连接。而在我的本地虚拟机中则完全正常、全程安静地我都不好意思。&lt;/p&gt;

&lt;h1 id=&#34;初步尝试&#34;&gt;初步尝试&lt;/h1&gt;

&lt;p&gt;有怀疑过：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;是不是SSH目录或其中文件的权限设置不对，导致SSH无法读取？&lt;/li&gt;
&lt;li&gt;是不是known_hosts没有生效？格式不对？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;搜遍资料、试遍方法，几个小时过去了，依然没有进展。眼瞅着就没法轻松过周末了……&lt;/p&gt;

&lt;h1 id=&#34;新思路&#34;&gt;新思路&lt;/h1&gt;

&lt;p&gt;于是换了个思路，跳过Jenkins、直接SSH到被部署服务器上，手动执行脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod u+x ./init.sh
sudo ./init.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又看到了熟悉的询问，悬着手腕琢磨接下来该怎么办，转念一想「要不yes了看看它自己能不能保存到known_hosts、保存的格式是怎样的」。动手之前先&lt;code&gt;mv known_hosts known_hosts.old&lt;/code&gt;待会好diff。&lt;/p&gt;

&lt;h1 id=&#34;峰回路转&#34;&gt;峰回路转&lt;/h1&gt;

&lt;p&gt;输入yes，峰回路转 —— 并没有生成known_host。&lt;/p&gt;

&lt;p&gt;又陷入思考「难道权限不够？不对啊，我已经sudo了」，一想到sudo，顿时一个激灵 —— 当前是root帐号！赶紧&lt;code&gt;sudo ls -la /root/.ssh/&lt;/code&gt;，果然躺着一个known_hosts文件。&lt;/p&gt;

&lt;p&gt;到此，我才弄明白问题的原因：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;因为sudo，脚本是以root帐号身份执行，会去&lt;code&gt;/root/.ssh/known_hosts&lt;/code&gt;找known_hosts；&lt;/li&gt;
&lt;li&gt;脚本的ssh-keyscan将ssh.github.com保存进了&lt;code&gt;~/.ssh/known_hosts&lt;/code&gt;，被部署服务器使用的是非root帐号；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;SSH就没找到ssh-keyscan的结果，所以询问。而之所以在本地虚拟机里一切正常是因为我偷懒用的是root帐号。&lt;/p&gt;

&lt;p&gt;再一细想，我真是糊涂，怎么会整个脚本都sudo呢，这样岂不是git clone等等命令都是以root用户身份执行了吗……&lt;/p&gt;

&lt;h1 id=&#34;解决&#34;&gt;解决&lt;/h1&gt;

&lt;p&gt;找到了问题症结，解决也就简单了，花了十分钟把需要权限的命令都加上sudo，&lt;code&gt;echo xxx &amp;gt; $file&lt;/code&gt;都改成&lt;code&gt;echo xxx | sudo tee $file&lt;/code&gt;，去掉Jenkins构建步骤里的sudo 。&lt;/p&gt;

&lt;p&gt;Jenkins部署成功，欢度周末～&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>macOS tar的特殊行为</title>
      <link>http://boxcounter.com/technique/2016-11-26-macOS-tar%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A1%8C%E4%B8%BA/</link>
      <pubDate>Sat, 26 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2016-11-26-macOS-tar%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A1%8C%E4%B8%BA/</guid>
      <description>&lt;p&gt;这周在编写自动部署脚本的过程遇到一个有趣的问题 —— 我把脚本打包成tgz文件，然后scp到被部署服务器上。解压之后发现多出来好些隐藏文件。比如下面的行1和行3：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls ./init/letsencrypt/keys/
._0000_key-certbot.pem
0000_key-certbot.pem
._0000_key-letsencrypt.pem
0000_key-letsencrypt.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一开始我以为是系统自动生成的类似.DS_Store这样的系统文件，但&lt;code&gt;ls -al&lt;/code&gt;看了下源目录，并没有发现踪迹。然后在本机（macOS）上把tgz文件&lt;code&gt;tar zxvf&lt;/code&gt;出来，也没有发现这些文件的存在。&lt;/p&gt;

&lt;p&gt;一头雾水。于是google「tar dot file」，找到了答案：&lt;/p&gt;

&lt;p&gt;macOS自带的tar在打包过程中创建了这些隐藏文件，用于保存被打包文件的扩展属性，解包时会用隐藏文件中的数据重建扩展属性。ubuntu下的tar则不具备这个特性，会将隐藏文件原样解包出来。&lt;/p&gt;

&lt;p&gt;可以通过&lt;code&gt;ls -le@ *&lt;/code&gt;来查看扩展属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /bin/ls -le@ ./init/letsencrypt/keys/
total 56
-rw-------@ 1 Boxcounter  staff  1708 Nov 16 12:26 0000_key-certbot.pem
	com.apple.quarantine	  17
-rw-------@ 1 Boxcounter  staff  1704 Nov 16 12:26 0000_key-letsencrypt.pem
	com.apple.quarantine	  17
-rw-------@ 1 Boxcounter  staff  1704 Nov 16 12:26 0001_key-certbot.pem
	com.apple.quarantine	  17
-rw-------@ 1 Boxcounter  staff  1704 Nov 16 12:26 0001_key-letsencrypt.pem
	com.apple.quarantine	  17
-rw-------@ 1 Boxcounter  staff  1704 Nov 16 12:26 0002_key-certbot.pem
	com.apple.quarantine	  17
-rw-------@ 1 Boxcounter  staff  1704 Nov 16 12:26 0002_key-letsencrypt.pem
	com.apple.quarantine	  17
-rw-------@ 1 Boxcounter  staff  1704 Nov 16 12:26 0003_key-letsencrypt.pem
	com.apple.quarantine	  17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方法有两种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;设置环境变量COPYFILE_DISABLE禁用tar的这个行为：&lt;code&gt;export COPYFILE_DISABLE=1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;改用gnu tar：&lt;code&gt;brew install gnu-tar --with-default-names&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考资料：&lt;a href=&#34;http://superuser.com/a/61188&#34;&gt;Why do I get files like ._foo in my tarball on OS X?&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RefBase::weakref_type::attemptIncStrong的理解</title>
      <link>http://boxcounter.com/technique/2015-09-05-weakref_type.attemptIncStrong/</link>
      <pubDate>Sat, 05 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2015-09-05-weakref_type.attemptIncStrong/</guid>
      <description>&lt;p&gt;见中文注释内容：&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #2b91af&#34;&gt;bool&lt;/span&gt; RefBase::weakref_type::attemptIncStrong(&lt;span style=&#34;color: #0000ff&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt;* id)
{
    incWeak(id);
    
    weakref_impl* &lt;span style=&#34;color: #0000ff&#34;&gt;const&lt;/span&gt; impl = &lt;span style=&#34;color: #0000ff&#34;&gt;static_cast&lt;/span&gt;&amp;lt;weakref_impl*&amp;gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;this&lt;/span&gt;);
    
    &lt;span style=&#34;color: #2b91af&#34;&gt;int32_t&lt;/span&gt; curCount = impl-&amp;gt;mStrong;
    LOG_ASSERT(curCount &amp;gt;= 0, &lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;attemptIncStrong called on %p after underflow&amp;quot;&lt;/span&gt;,
               &lt;span style=&#34;color: #0000ff&#34;&gt;this&lt;/span&gt;);
    &lt;span style=&#34;color: #0000ff&#34;&gt;while&lt;/span&gt; (curCount &amp;gt; 0 &amp;amp;&amp;amp; curCount != INITIAL_STRONG_VALUE) {
        &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (android_atomic_cmpxchg(curCount, curCount+1, &amp;amp;impl-&amp;gt;mStrong) == 0) {
            &lt;span style=&#34;color: #0000ff&#34;&gt;break&lt;/span&gt;;
        }
        curCount = impl-&amp;gt;mStrong;
    }
    
    &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (curCount &amp;lt;= 0 || curCount == INITIAL_STRONG_VALUE) {
        &lt;span style=&#34;color: #2b91af&#34;&gt;bool&lt;/span&gt; allow;
        &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (curCount == INITIAL_STRONG_VALUE) {
            &lt;span style=&#34;color: #008000&#34;&gt;// Attempting to acquire first strong reference...  this is allowed&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;// if the object does NOT have a longer lifetime (meaning the&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;// implementation doesn&amp;#39;t need to see this), or if the implementation&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;// allows it to happen.&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;//&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;// ====&amp;gt;&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;// 未曾被强引用过，如果也不受弱引用影响，那肯定还未被销毁。&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;// &amp;lt;====&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;//&lt;/span&gt;
            allow = (impl-&amp;gt;mFlags&amp;amp;OBJECT_LIFETIME_WEAK) != OBJECT_LIFETIME_WEAK
                  || impl-&amp;gt;mBase-&amp;gt;onIncStrongAttempted(FIRST_INC_STRONG, id);
        } &lt;span style=&#34;color: #0000ff&#34;&gt;else&lt;/span&gt; {
            &lt;span style=&#34;color: #008000&#34;&gt;// Attempting to revive the object...  this is allowed&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;// if the object DOES have a longer lifetime (so we can safely&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;// call the object with only a weak ref) and the implementation&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;// allows it to happen.&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;//&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;// ====&amp;gt;&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;// 曾经被强引用过，如果不受弱引用影响，那么在RefBase.decStrong()中已经被销毁了，无法revive。&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;// 所以，一定要受弱引用影响。&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;// &amp;lt;====&lt;/span&gt;
            &lt;span style=&#34;color: #008000&#34;&gt;//&lt;/span&gt;
            allow = (impl-&amp;gt;mFlags&amp;amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_WEAK
                  &amp;amp;&amp;amp; impl-&amp;gt;mBase-&amp;gt;onIncStrongAttempted(FIRST_INC_STRONG, id);
        }
        &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (!allow) {
            decWeak(id);
            &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; false;
        }
        curCount = android_atomic_inc(&amp;amp;impl-&amp;gt;mStrong);
        &lt;span style=&#34;color: #008000&#34;&gt;// If the strong reference count has already been incremented by&lt;/span&gt;
        &lt;span style=&#34;color: #008000&#34;&gt;// someone else, the implementor of onIncStrongAttempted() is holding&lt;/span&gt;
        &lt;span style=&#34;color: #008000&#34;&gt;// an unneeded reference.  So call onLastStrongRef() here to remove it.&lt;/span&gt;
        &lt;span style=&#34;color: #008000&#34;&gt;// (No, this is not pretty.)  Note that we MUST NOT do this if we&lt;/span&gt;
        &lt;span style=&#34;color: #008000&#34;&gt;// are in fact acquiring the first reference.&lt;/span&gt;
        &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (curCount &amp;gt; 0 &amp;amp;&amp;amp; curCount &amp;lt; INITIAL_STRONG_VALUE) {
            impl-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);
        }
    }
    
    impl-&amp;gt;addWeakRef(id);
    impl-&amp;gt;addStrongRef(id);
&lt;span style=&#34;color: #0000ff&#34;&gt;#if PRINT_REFS&lt;/span&gt;
    LOGD(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;attemptIncStrong of %p from %p: cnt=%d\n&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #0000ff&#34;&gt;this&lt;/span&gt;, id, curCount);
&lt;span style=&#34;color: #0000ff&#34;&gt;#endif&lt;/span&gt;
    &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (curCount == INITIAL_STRONG_VALUE) {
        android_atomic_add(-INITIAL_STRONG_VALUE, &amp;amp;impl-&amp;gt;mStrong);
        impl-&amp;gt;mBase-&amp;gt;onFirstRef();
    }
    
    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; true;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; RefBase::decStrong(&lt;span style=&#34;color: #0000ff&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt;* id) &lt;span style=&#34;color: #0000ff&#34;&gt;const&lt;/span&gt;
{
    weakref_impl* &lt;span style=&#34;color: #0000ff&#34;&gt;const&lt;/span&gt; refs = mRefs;
    refs-&amp;gt;removeStrongRef(id);
    &lt;span style=&#34;color: #0000ff&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;int32_t&lt;/span&gt; c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong);
&lt;span style=&#34;color: #0000ff&#34;&gt;#if PRINT_REFS&lt;/span&gt;
    LOGD(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;decStrong of %p from %p: cnt=%d\n&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #0000ff&#34;&gt;this&lt;/span&gt;, id, c);
&lt;span style=&#34;color: #0000ff&#34;&gt;#endif&lt;/span&gt;
    LOG_ASSERT(c &amp;gt;= 1, &lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;decStrong() called on %p too many times&amp;quot;&lt;/span&gt;, refs);
    &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (c == 1) {
        &lt;span style=&#34;color: #0000ff&#34;&gt;const_cast&lt;/span&gt;&amp;lt;RefBase*&amp;gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;this&lt;/span&gt;)-&amp;gt;onLastStrongRef(id);
        &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; ((refs-&amp;gt;mFlags&amp;amp;OBJECT_LIFETIME_WEAK) != OBJECT_LIFETIME_WEAK) {
            &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (refs-&amp;gt;mDestroyer) {
                refs-&amp;gt;mDestroyer-&amp;gt;destroy(&lt;span style=&#34;color: #0000ff&#34;&gt;this&lt;/span&gt;);
            } &lt;span style=&#34;color: #0000ff&#34;&gt;else&lt;/span&gt; {
                &lt;span style=&#34;color: #0000ff&#34;&gt;delete&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;this&lt;/span&gt;;
            }
        }
    }
    refs-&amp;gt;removeWeakRef(id);
    refs-&amp;gt;decWeak(id);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;完整代码：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://android.googlesource.com/platform/frameworks/base/+/gingerbread/include/utils/RefBase.h&#34;&gt;RefBase.h&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://android.googlesource.com/platform/frameworks/base/+/gingerbread/libs/utils/RefBase.cpp&#34;&gt;RefBase.cpp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>baselineAligned属性</title>
      <link>http://boxcounter.com/technique/2015-09-01-baselineAligned/</link>
      <pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2015-09-01-baselineAligned/</guid>
      <description>&lt;p&gt;在使用LinearLayout+TextView的过程中遇到一个看似诡异的问题，显示效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://boxcounter.com/images/2015-09-01/baselineAligned.png&#34; width=&#34;300&#34;/&gt;&lt;/p&gt;

&lt;p&gt;其中两个灰色方块是使用代码动态创建的TextView。它们的父LinearLayout是这样的：&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;LinearLayout
    android:id=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;@+id/ll_files&amp;quot;&lt;/span&gt;
    android:layout_width=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
    android:layout_height=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;100dp&amp;quot;&lt;/span&gt;
    android:layout_marginTop=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;7.5dp&amp;quot;&lt;/span&gt;
    android:orientation=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;horizontal&amp;quot;&lt;/span&gt;
    /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不知道是什么原因，导致第一个TextView「下挫」了一些。仔细检查了它的margin和padding都是0、符合预期，但top是29。&lt;/p&gt;

&lt;p&gt;仔细阅读了一遍代码和布局文件，确定我并没有误调整top，那么问题应该出现在动态layout过程中。那就开始调试分析吧。&lt;/p&gt;

&lt;p&gt;顺着LinearLayout.onLayout()追踪到了LinearLayout.layoutHorizontal()，发现了这样一段代码：&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; layoutHorizontal(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; left, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; top, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; right, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; bottom) {
    &lt;span style=&#34;color: #008000&#34;&gt;// 若干无关代码，略&lt;/span&gt;
    
    &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; childBaseline = -1;
    
    &lt;span style=&#34;color: #0000ff&#34;&gt;final&lt;/span&gt; LinearLayout.LayoutParams lp =
            (LinearLayout.LayoutParams) child.getLayoutParams();
    
    &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (baselineAligned &amp;amp;&amp;amp; lp.height != LayoutParams.MATCH_PARENT) {
        childBaseline = child.getBaseline();
    }
    
    &lt;span style=&#34;color: #008000&#34;&gt;// 若干无关代码，略&lt;/span&gt;
    
    &lt;span style=&#34;color: #0000ff&#34;&gt;switch&lt;/span&gt; (gravity &amp;amp; Gravity.VERTICAL_GRAVITY_MASK) {
        &lt;span style=&#34;color: #0000ff&#34;&gt;case&lt;/span&gt; Gravity.TOP:
            childTop = paddingTop + lp.topMargin;
            &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (childBaseline != -1) {
                childTop += maxAscent[INDEX_TOP] - childBaseline;  &lt;span style=&#34;color: #008000&#34;&gt;// &amp;lt;==== A&lt;/span&gt;
            }
            &lt;span style=&#34;color: #0000ff&#34;&gt;break&lt;/span&gt;;
    
    &lt;span style=&#34;color: #008000&#34;&gt;// 若干无关代码，略&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当执行完A行时，childTop等于29。问题出在这里，再反向阅读代码，跟踪到了两个关键变量：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;baselineAligned为true；&lt;/li&gt;
&lt;li&gt;childBaseline不为0；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这时我想起文本的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9F%BA%E7%B7%9A&#34;&gt;baseline属性&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;继续查阅文档、代码，得到两个结论：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LinearLayout的baselineAligned默认为true；&lt;/li&gt;
&lt;li&gt;TextView重写了getBaseline()，返回了有效值；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;定位了问题症结，解决方案也就不难找了：将LinearLayout的android:baselineAligned改为false。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ImageView.ScaleType</title>
      <link>http://boxcounter.com/technique/2015-08-13-ImageView-ScaleType/</link>
      <pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2015-08-13-ImageView-ScaleType/</guid>
      <description>&lt;p&gt;开启了「Show layout bounds」。左侧是宽图、右侧是竖图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://boxcounter.com/images/2015-08-13/scaleTypeHorizontal.png&#34;  width=&#34;500&#34;/&gt;
&lt;img src=&#34;http://boxcounter.com/images/2015-08-13/scaleTypeVertical.png&#34;  width=&#34;500&#34;/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android下列表视图的性能优化</title>
      <link>http://boxcounter.com/technique/2015-08-01-Android%E4%B8%8B%E5%88%97%E8%A1%A8%E8%A7%86%E5%9B%BE%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 01 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2015-08-01-Android%E4%B8%8B%E5%88%97%E8%A1%A8%E8%A7%86%E5%9B%BE%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>

&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;

&lt;p&gt;Android下使用列表控件，如&lt;code&gt;RecyclerView&lt;/code&gt;和&lt;code&gt;ListView&lt;/code&gt;，很容易遇到滚动不流畅的问题。本文记录我的一次性能优化过程。&lt;/p&gt;

&lt;h1 id=&#34;常见范式&#34;&gt;常见范式&lt;/h1&gt;

&lt;p&gt;我们经常这样使用列表控件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;（使用&lt;code&gt;ListView&lt;/code&gt;）重写&lt;code&gt;Adapter.getView()&lt;/code&gt;，在其中创建或重用View和ViewHolder，将业务数据结构显示到View中。&lt;/li&gt;
&lt;li&gt;（使用&lt;code&gt;RecylerView&lt;/code&gt;）重写&lt;code&gt;Adapter.onCreateViewHolder()&lt;/code&gt;和&lt;code&gt;Adapter.onBindViewHolder()&lt;/code&gt;，在前者中创建View和ViewHolder，在后者中将业务数据结构显示到View中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个范式用了一种优化技术：View重用。避免了频繁的create view和find view过程，这两个过程都是很耗时的。但仅这一种优化手段不足以解决所有的性能问题。&lt;/p&gt;

&lt;h1 id=&#34;优化过程&#34;&gt;优化过程&lt;/h1&gt;

&lt;p&gt;接下来，我将基于一个实际项目的简化版来说明如何进行优化。&lt;/p&gt;

&lt;h2 id=&#34;一-减少overdraw&#34;&gt;一、减少Overdraw&lt;/h2&gt;

&lt;p&gt;Overdraw是常见性能损耗点，且多是无谓的性能损耗。相关资料非常丰富，这里不赘述。只提醒一点：善用&lt;code&gt;Window.setBackgroundDrawable*()&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;二-内存优化&#34;&gt;二、内存优化&lt;/h2&gt;

&lt;p&gt;优化内存使用也是一种常用的性能优化手段。它的机理是：GC会暂停所有线程，而频繁触发GC会加剧掉帧问题。&lt;/p&gt;

&lt;p&gt;来看一下主题的设计图，其中图片矩阵可以容纳0~9张图片。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://boxcounter.com/images/2015-08-01/memorySample.png&#34; width=&#34;300&#34;/&gt;&lt;/p&gt;

&lt;p&gt;优化方法是：尽量缓存、重用ImageView。比如：在&lt;code&gt;onBindViewHolder()&lt;/code&gt;中发现图片矩阵控件中已经包含了7个ImageView（上次该控件显示的主题有7张图片），当前要显示的主题有5张图片，那么直接重用前5个ImageView，隐藏剩下的2个ImageView。&lt;/p&gt;

&lt;h2 id=&#34;三-精简布局&#34;&gt;三、精简布局&lt;/h2&gt;

&lt;p&gt;来看一下主题的赞和评论区域。其中赞区域会有两种展现形式（针对不同的应用场景）。想想如果是你来实现，会怎么布局。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://boxcounter.com/images/2015-08-01/hierachySample1.png&#34; width=&#34;300&#34;/&gt;
&lt;img src=&#34;http://boxcounter.com/images/2015-08-01/hierachySample2.png&#34; width=&#34;300&#34;/&gt;&lt;/p&gt;

&lt;p&gt;布局方式可能会是这样：&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;LinearLayout android:orientation=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;vertical&amp;quot;&lt;/span&gt; &amp;gt;

    &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 赞区域 --&amp;gt;&lt;/span&gt;
    &amp;lt;LinearLayout android:orientation=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;horizontal&amp;quot;&lt;/span&gt; &amp;gt;
        &amp;lt;ImageView /&amp;gt;   &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 心形图标 --&amp;gt;&lt;/span&gt;
        &amp;lt;GridLayout /&amp;gt;  &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 头像形式的赞 --&amp;gt;&lt;/span&gt;
        &amp;lt;TextView /&amp;gt;    &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 文字形式的赞 --&amp;gt;&lt;/span&gt;
    &amp;lt;/LinearLayout&amp;gt;

    &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 评论区域 --&amp;gt;&lt;/span&gt;
    &amp;lt;LinearLayout android:orientation=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;horizontal&amp;quot;&lt;/span&gt; &amp;gt;
        &amp;lt;ImageView /&amp;gt;   &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 评论图标 --&amp;gt;&lt;/span&gt;
        &amp;lt;LinearLayout
            android:orientation=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;vertical&amp;quot;&lt;/span&gt;
            /&amp;gt; &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 评论列表容器 --&amp;gt;&lt;/span&gt;
    &amp;lt;/LinearLayout&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据赞的显示方式来设置&lt;code&gt;GridLayout&lt;/code&gt;和&lt;code&gt;TextView&lt;/code&gt;的Visibility。&lt;/p&gt;

&lt;p&gt;我的方法是：根据需要动态改变布局结构、保正显示效果的同时精简数量和层级。优化后是这样：&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;LinearLayout android:orientation=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;vertical&amp;quot;&lt;/span&gt; &amp;gt;

    &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 赞区域 --&amp;gt;&lt;/span&gt;
    &amp;lt;ViewStub android:background=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;heart.9.png&amp;quot;&lt;/span&gt; /&amp;gt;

    &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 评论区域 --&amp;gt;&lt;/span&gt;
    &amp;lt;LinearLayout
        android:orientation=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;vertical&amp;quot;&lt;/span&gt;
        android:background=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;comment.9.png&amp;quot;&lt;/span&gt;
        android:paddingStart=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;?dp&amp;quot;&lt;/span&gt;
        /&amp;gt; &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 评论列表容器 --&amp;gt;&lt;/span&gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;首先，原赞区域的&lt;code&gt;GridLayout&lt;/code&gt;和&lt;code&gt;TextView&lt;/code&gt;都放到单独的布局文件中，原布局中换上&lt;code&gt;ViewStub&lt;/code&gt;，根据需要动态inflate。其次，赞和评论图标改成.9图作为&lt;code&gt;Background&lt;/code&gt;、并辅以&lt;code&gt;paddingStart&lt;/code&gt;（具体数值由评论图标的宽度计算得到）。&lt;/p&gt;

&lt;p&gt;后者的缺点是.9图可能因为拉伸变得不够清晰，但实测下来效果满足需要。&lt;/p&gt;

&lt;h2 id=&#34;四-改进布局&#34;&gt;四、改进布局&lt;/h2&gt;

&lt;p&gt;常用的方法有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在不增加布局层次及复杂度的前提下，用LinearLayout替换RelativeLayout；&lt;/li&gt;
&lt;li&gt;减少LinearLayout.layout_weight属性的使用，分享一下项目中一个LinearLayout的实际数据：

&lt;ul&gt;
&lt;li&gt;使用layout_weight，measure耗时5.86ms；&lt;/li&gt;
&lt;li&gt;弃用layout_weight，measure耗时2.28ms；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;五-预处理&#34;&gt;五、预处理&lt;/h2&gt;

&lt;p&gt;需要引入一点业务数据结构来辅助说明。&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000&#34;&gt;// 约定：为了行文简洁，本文中所有代码都隐藏了诸如public关键字、构造函数等非核心内容。&lt;/span&gt;

&lt;span style=&#34;color: #008000&#34;&gt;// 主题&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;Topic&lt;/span&gt; {
    String mText;               &lt;span style=&#34;color: #008000&#34;&gt;// 文字内容。&lt;/span&gt;
    List&amp;lt;String&amp;gt; mImages;       &lt;span style=&#34;color: #008000&#34;&gt;// 图片链接。&lt;/span&gt;
    List&amp;lt;User&amp;gt; mLikes;          &lt;span style=&#34;color: #008000&#34;&gt;// 点赞的用户。&lt;/span&gt;
    List&amp;lt;Comment&amp;gt; mComments;    &lt;span style=&#34;color: #008000&#34;&gt;// 评论。&lt;/span&gt;
    User mCreater;              &lt;span style=&#34;color: #008000&#34;&gt;// 发表人。&lt;/span&gt;
    &lt;span style=&#34;color: #2b91af&#34;&gt;long&lt;/span&gt; mCreateTime;           &lt;span style=&#34;color: #008000&#34;&gt;// 发表的时间戳。&lt;/span&gt;
}

&lt;span style=&#34;color: #008000&#34;&gt;// 评论&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;Comment&lt;/span&gt; {
    String mText;   &lt;span style=&#34;color: #008000&#34;&gt;// 文字内容。&lt;/span&gt;
    User mCreater;  &lt;span style=&#34;color: #008000&#34;&gt;// 发表人。&lt;/span&gt;
}

&lt;span style=&#34;color: #008000&#34;&gt;// 用户&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;User&lt;/span&gt; {
    String mName;       &lt;span style=&#34;color: #008000&#34;&gt;// 用户名称。&lt;/span&gt;
    String mAvatarUrl;  &lt;span style=&#34;color: #008000&#34;&gt;// 头像的下载地址。&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这其中有部分数据是可以预处理的，得到的数据结构如下：&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;PreprocessResult&lt;/span&gt; {
    CharSequence mText;             &lt;span style=&#34;color: #008000&#34;&gt;// 包含Spannable（比如超链接）的正文。&lt;/span&gt;
    String mLikes;                  &lt;span style=&#34;color: #008000&#34;&gt;// 用逗号分隔的文字形式的点赞用户的名称。&lt;/span&gt;
    List&amp;lt;CharSequence&amp;gt; mComments;   &lt;span style=&#34;color: #008000&#34;&gt;// 包含Spannable的评论列表。&lt;/span&gt;
    String mCreateTime;             &lt;span style=&#34;color: #008000&#34;&gt;// 发表时间。&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后在&lt;code&gt;onBindViewHolder()&lt;/code&gt;中就可以直接将&lt;code&gt;PreprocessResult&lt;/code&gt;的内容设置到相应的view上，避免在UI线程中动态处理造成掉帧。&lt;/p&gt;

&lt;p&gt;这种方法的缺点是增加了复杂度：PreprocessResult需要和Topic保持同步更新。比如用户点赞、发表评论之后，需要同步修改PreprocessResult和Topic。&lt;/p&gt;

&lt;h2 id=&#34;六-预创建&#34;&gt;六、预创建&lt;/h2&gt;

&lt;p&gt;分析发现，滚动过程会因为动态创建TopicView而卡顿。TopicView是用来显示整个主题的自定义View，包含前述的赞和评论等子布局。即便经过精简，整个布局依然比较复杂，inflate过程很耗时。于是预先创建了一些TopicView备用，在&lt;code&gt;onCreateViewHolder()&lt;/code&gt;中尽量使用它们，如果备用已经用完再动态创建。&lt;/p&gt;

&lt;h2 id=&#34;七-优化textview&#34;&gt;七、优化TextView&lt;/h2&gt;

&lt;p&gt;经过上述这几步优化之后，流畅度提升了很多，但偶尔还是会出现较明显的卡顿现象。分析发现是&lt;code&gt;TextView.setText()&lt;/code&gt;耗时过长导致的，在高强度测试下（长文主题，并且有很多评论），平均一次长文的调用就可能耗时22ms，已经超过了保证帧率的16ms上限。&lt;/p&gt;

&lt;p&gt;因为这个项目的业务逻辑决定了主题、评论的文字内容不会被修改，只有增删。于是采用的优化方法是：对于主题正文和评论，用&lt;code&gt;StaticLayout&lt;/code&gt;配合自定义View展示文字。自定义View代码如下：&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;StaticLayoutView&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;extends&lt;/span&gt; View {
    &lt;span style=&#34;color: #0000ff&#34;&gt;private&lt;/span&gt; StaticLayout mLayout;

    &lt;span style=&#34;color: #0000ff&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; setLayout(StaticLayout layout) {
        mLayout = layout;

        &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; height = layout.getHeight();
        &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; ((mLayout.getWidth() != layout.getWidth()) ||
                (mLayoutHeight != height)) {
            requestLayout();
        }

        mLayoutHeight = height;
    }

    @Override
    &lt;span style=&#34;color: #0000ff&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; onDraw(Canvas canvas) {
        &lt;span style=&#34;color: #0000ff&#34;&gt;super&lt;/span&gt;.onDraw(canvas);

        canvas.save();
        &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #0000ff&#34;&gt;null&lt;/span&gt; != mLayout) {
            canvas.translate(getPaddingLeft(), getPaddingTop());
            mLayout.draw(canvas);
        }
        canvas.restore();
    }

    @Override
    &lt;span style=&#34;color: #0000ff&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; onMeasure(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; heightMeasureSpec) {
        &lt;span style=&#34;color: #0000ff&#34;&gt;super&lt;/span&gt;.onMeasure(widthMeasureSpec, heightMeasureSpec);
        &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #0000ff&#34;&gt;null&lt;/span&gt; != mLayout) {
            setMeasuredDimension(getMeasuredWidth(),
                    mLayoutHeight + getPaddingTop() + getPaddingBottom());
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;StaticLayoutView相比TextView简单、高效很多，更重要的是&lt;code&gt;StaticLayout&lt;/code&gt;可以在非UI线程创建、初始化。于是前述「预处理」过程中的数据结构变为：&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;PreprocessResult&lt;/span&gt; {
    StaticLayout mText;             &lt;span style=&#34;color: #008000&#34;&gt;// &amp;lt;= 之前是CharSequence&lt;/span&gt;
    String mLikes;
    List&amp;lt;StaticLayout&amp;gt; mComments;   &lt;span style=&#34;color: #008000&#34;&gt;// &amp;lt;= 之前是List&amp;lt;CharSequence&amp;gt;&lt;/span&gt;
    String mCreateTime;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;优化后，在高强度测试环境下，平均帧率从34上升至47。实际环境中的平均帧率约为51。&lt;/p&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;整个优化过程的核心思想是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;尽量减少滚动时UI线程中的耗时操作。能挪到后台线程的就不在UI线程中做，必须在UI线程做、但能预先处理的就提早处理；&lt;/li&gt;
&lt;li&gt;以空间换时间。用缓存来减少GC、创建等耗时操作；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要说明的是，一些优化方法是有代价的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;预处理可能增加用户的等待时间。以这个项目为例，进入某Activity后，一边显示进度条，一边从服务端获取一批Topic显示给用户。预处理和预先创建会较明显地增加用户的等待时间；&lt;/li&gt;
&lt;li&gt;缓存数据越多，OOM的风险越大；&lt;/li&gt;
&lt;li&gt;增加了复杂度；&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;

&lt;p&gt;除前述优化方法之外，还有一些零星的、未能实际应用的优化方法。比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;onBindViewHolder()&lt;/code&gt;中检查之前显示的内容是否就是当前将要显示的内容。如果是，return即可。这种方法可以在反方向滚动时，避免不必要的更新view操作。但前提条件是内容不会动态改变，在这个项目中Topic的内容是可能动态改变的，使用这个方法后反而增加了复杂度，权衡得失后，放弃了这个优化方法；&lt;/li&gt;
&lt;li&gt;使用Tracer for OpenGL检查OpenGL渲染过程；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，即便经过这一系列的优化，卡顿问题也未能根除。后续我可能会继续改进优化方案，如果有新的心得体会，再补上。也希望有同好分享经验，相互交流，共同进步，谢谢。&lt;/p&gt;

&lt;p&gt;最后，聊一下我对性能优化的一些建议：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先分析性能瓶颈，再对症下药。对于有经验的研发，这个过程可以适当地借助自己的经验法则。忌讳想当然的「优化」。&lt;/li&gt;
&lt;li&gt;善用工具。比如Traceview、Memory Monitor、Hierarchy Viewer。本文所述的优化过程重度依赖这些工具。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://android-developers.blogspot.com/2010/10/traceview-war-story.html&#34;&gt;Traceview War Story&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://developer.android.com/intl/zh-cn/tools/debugging/debugging-ui.html&#34;&gt;Optimizing Your UI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&#34;&gt;Android Performance Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.curious-creature.com/2012/12/01/android-performance-case-study/&#34;&gt;Android Performance Case Study&lt;/a&gt; by Romain Guy&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.curious-creature.com/docs/android-performance-case-study-1.html&#34;&gt;Android Performance Case Study（同名不同文）&lt;/a&gt; by Romain Guy&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hukai.me/android-performance-patterns/&#34;&gt;Android性能优化典范&lt;/a&gt; by 胡凯&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ragnraok.github.io/textview-pre-render-research.html&#34;&gt;TextView预渲染研究&lt;/a&gt; by Ragnarok&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://instagram-engineering.tumblr.com/post/114508858967/improving-comment-rendering-on-android&#34;&gt;Improving Comment Rendering on Android&lt;/a&gt; by Instagram&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>一起疑似内存泄漏</title>
      <link>http://boxcounter.com/technique/2014-01-12-suspected-memory-leak/</link>
      <pubDate>Sun, 12 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2014-01-12-suspected-memory-leak/</guid>
      <description>&lt;p&gt;上周遇到一起极其诡异的内存泄漏。现象是：&lt;br /&gt;
某种测试方法可以使程序物理内存使用量（top命令的RES列）持续上升。当停止测试之后，程序内存使用量稳定在测试过程中的最高值不变。从现象上看就是一典型的内存泄漏。&lt;/p&gt;

&lt;p&gt;我的诊断步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用valgrind的memcheck检查泄漏。故障重现后让程序自然退出。memcheck提示资源泄漏量为0.&lt;br /&gt;
所以，该内存应该没有被泄漏，程序中对它们还有引用，在程序退出时被正常释放掉了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用valgrind的massif分析内存使用。找到了一处可疑的「泄漏」点，90%的内存都是在该处分配。&lt;br /&gt;
但是调试发现该处分配（通过malloc）的内存都被正确的释放（通过free）掉了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用malloc_info函数查看程序运行过程中的内存情况。
这是在程序物理内存占用2G后我停止测试以后一段时间（大概5分钟）的输出：&lt;/p&gt;

&lt;p&gt;arena(462848), ordblks(2), smblks(1), hblks(5), hblkhd(104857600), usmblks(0), fsmblks(32), uordblks(459424), fordblks(3424), keepcost(3360).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从上面看，从heap中申请了462848(arena的值，约46KB)，mmap申请的内存是104857600（hblkhd的值，约100MB）。这俩值加在一起和top里显示的2G差很远啊。
   注，arena和hblkhd的man注解：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; arena   The total amount of memory allocated by means other than
         mmap(2) (i.e., memory allocated on the heap).  This figure
         includes both in-use blocks and blocks on the free list.
 hblkhd  The number of bytes in blocks currently allocated using
         mmap(2).
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;决定统计内存分配释放的次数和尺寸，目的是检查是否严重失衡。因为new/delete不太好跟踪，所以只处理了malloc/free。&lt;br /&gt;
使用的方法是wrap（gcc/g++的「-Wl,&amp;ndash;wrap,malloc」选项），看了一眼glibc的源码，以在free时候得到待释放内存的尺寸。最后的结果是没有严重失衡，应该不是显式的内存释放。&lt;br /&gt;
其实这个实验原本就没有报很大的希望，一来new/delete没有照顾到，不够精确。二来如果是显式的泄漏memcheck早就报告了。但是当时没有思路了，姑且一试，看能不能找到点面包屑。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;搜索了一些资料。有些提到glibc内部使用brk和mmap来进行内存分配，其中brk可能会造成这种泄漏假象。&lt;br /&gt;
于是在程序的开始设置了M_MMAP_THRESHOLD，发现故障依然存在。&lt;/p&gt;

&lt;p&gt;mallopt(M_MMAP_THRESHOLD, 1024*1024*1024); // 1G&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原本还想在不同的模块里使用不同的堆，然后反复根据堆的尺寸细分堆，来精确定位。却发现linux下没有类似HeapCreate的函数。&lt;/p&gt;

&lt;p&gt;技穷了。于是我邀请一位同事来协助分析，在协作中我发现我犯了个错误：尝试方法5的时候，我理解反了M_MMAP_THRESHOLD的含义，于是提供错了参数。实际上应该是这样：&lt;/p&gt;

&lt;p&gt;mallopt(M_MMAP_THRESHOLD, 0);&lt;/p&gt;

&lt;p&gt;然后故障消失了。也就是说，这次的故障实际并不是我们程序实现的资源泄漏，而是glibc堆管理机制导致的「资源泄漏」。我很奇怪为什么glibc没有重用程序调用free释放掉的空间，而是继续扩充堆。这个问题值得继续琢磨。&lt;/p&gt;

&lt;p&gt;总结：本次故障的分析过程里我的粗心大意又给自己惹了大麻烦。原本思路是正确的，结果走歪了。。。 自作孽啊。。。&lt;/p&gt;

&lt;p&gt;但是，即便这个故障不是程序实现BUG所导致的，实际上还是会对程序造成不好的影响：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果调整M_MMAP_THRESHOLD让程序不「泄漏」，那么资源占用和性能会变差。原因参考帮助文档中对该参数的描述。&lt;/li&gt;
&lt;li&gt;如果放任不管，程序会不停地吃内存，并且占住不释放。我尝试让程序持续吃内存，最后稳定在3GB的物理内存（共4G）和2.6G的swap空间（共4G）的消耗。（但没有被oom killer干掉）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再琢磨琢磨吧。&lt;/p&gt;

&lt;p&gt;最后，感谢我的同事cntrump。并附上《代码大全》里的一段话，我前些天重温的时候才看过：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;23.2 &lt;strong&gt;寻找缺陷&lt;/strong&gt; - &lt;em&gt;同他人讨论问题&lt;/em&gt;&lt;br /&gt;
　　有人会把这种方法称之为“忏悔式调试”。当你向别人解释自己的程序时，常常能发现自己犯下的一些错误。举个例子，如果你向别人解释上面的关于薪水的例子，你或许会这样对别人说：&lt;br /&gt;
　　嗨，jennifer，你有空么？我现在遇到一个麻烦。这张员工薪水列表本来应当是按照顺序排列的，但里面有些名字乱序了。我原本打算看看是不是新输入的名字就会这种情况，但有时是对的，有时又不是。我向这些数据在我输入他们的时候就应当被排序，因为程序会在我输入数据的时候对其排序，然后在数据保存的时候再排一遍。等一下，不对，它没有在输入数据的时候对其排序。就是这里。程序只是粗略地对这些数据进行了排序。谢谢你，jennifer，你帮了我个大忙。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>隔栏、断言、防御型和攻击型编程的思考</title>
      <link>http://boxcounter.com/technique/2014-01-12-assert-defensive-offensive-programming/</link>
      <pubDate>Sun, 12 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2014-01-12-assert-defensive-offensive-programming/</guid>
      <description>

&lt;h1 id=&#34;一-前言&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　本文的内容最初源自我重温《代码大全》时候读到的一段内容，然后和同事讨论又引发了自己的一些思索。最后觉得这值得写下来，一来我一直很喜欢琢磨编码风格，有一些这方面的​思考，但都是一些存放在脑子里的思维碎片，（部分）整理成文对我自己是件好事。二来抛砖引玉，希望能找到一些同好探讨。&lt;/p&gt;

&lt;h1 id=&#34;二-常用的断言宏&#34;&gt;二、常用的断言宏&lt;/h1&gt;

&lt;p&gt;　　先贴一段我常用的断言宏，后面讲述的时候所说的ASSERT是通指下面这一组ASSERT*。
&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;#ifdef DEBUG&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT(x) assert(x)&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#else&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT(x)&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#endif&lt;/span&gt;

&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_RETURN(x)            {ASSERT(x); if(!(x)) {return;}}&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_RETURN_VAL(x, ret)   {ASSERT(x); if(!(x)) {return ret;}}&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_GOTO(x, label)       {ASSERT(x); if(!(x)) {goto label;}}&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_BREAK(x)             {ASSERT(x); if(!(x)) {break;}}&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_CONTINUE(x)          {ASSERT(x); if(!(x)) {continue;}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;三-隔栏与断言&#34;&gt;三、隔栏与断言&lt;/h1&gt;

&lt;p&gt;　　《代码大全》里有这么一段“隔栏与断言的关系”：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;隔栏外部的程序应使用错误处理技术，在那里对数据做的任何假定都是不安全的。&lt;br /&gt;
隔栏内部的程序应使用断言技术，因为传进来的数据应该已在通过隔栏时被清理过了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　这里的“隔栏”我理解为一些接口，比如类的public函数。按照上述说法，应该在public函数的对参数进行合法性验证“if (!x) return”，在private函数的开头使用ASSERT。&lt;/p&gt;

&lt;p&gt;　　感觉也有点道理。但是觉得又不太习惯。我习惯这么做：&lt;br /&gt;
　　public和private函数都用ASSERT，既把问题反馈给外部使用者，又反馈自身内部的问题。&lt;/p&gt;

&lt;p&gt;　　曾经和同事讨论过这个问题，同事没我这么挑（或者“钻牛角尖”？），他一般的做法是：在public函数里做参数检查，private里不对参数做检查。一来是priva​te里没必要做判断（public已经判断过了），二来是影响效率。&lt;/p&gt;

&lt;p&gt;　　我尝试了一段时间，但是还是觉得不合我的习惯，原因是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;即便public函数做了参数检查，也难保开发者不引入别的问题。比如传递参数过程中误改。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;所谓“内部”、“外部”，只是个相对的概念。多人协作来开发、使用这些类的过程中，一个模块中的函数可能由不同的开发者编写，相互都可以理解为“外部”（甚至不同函数也可​以认为互为“外部”）。即便在做设计时已经约定好相互之间的数据要求，也难免实现过程中会偏离。更不用说使用极端敏捷开发、基本不做文档化设计的小团队协作。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如“隔栏和断言的关系”所述：“隔栏内部的程序应使用断言技术，因为传进来的数据应该已在通过隔栏时被清理过了”。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;担忧的那部分性能损耗极有可能微乎其微。（后面有一些性能优化的想法分享。）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　又琢磨了琢磨，感觉《代码大全》里说的也有道理。隔栏处确实更适合做过滤，而不是断言。&lt;br /&gt;
　　因为隔栏外部的程序未必需要隔栏内部的反馈。比如单元测试时，测试程序可能会有意的传入非法的参数。&lt;/p&gt;

&lt;h1 id=&#34;四-一个讨论引发的思索&#34;&gt;四、一个讨论引发的思索&lt;/h1&gt;

&lt;p&gt;　　另外，同事分享了一个讨论贴，主贴里楼主愤怒地吐槽：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;昨天线上的一个服务程序问了点问题，程序无限重启。&lt;br /&gt;
通过gdb调试发现该程序在某个函数里调用空指针，然后造成了段错误。因为有守护进程监控，所以有了无限重启的现像。&lt;br /&gt;
我把引起段错误的地方告诉了程序的作者，此人竟然说，这个指针应该不为空才对，现在指针为空说明了数据有问题，应该让数据的生产者去修改，他拒绝修改。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　跟帖的有支持楼主的（后简称A），也有认同文中“程序的作者”（B）。&lt;/p&gt;

&lt;p&gt;　　回帖里支持双方的都有。比如支持B的典型说法有：“strcpy不就这样么？”、“野指针同样会照成崩溃，所以是否检查空指针完全看程序各个模块之间的约定”。&lt;/p&gt;

&lt;p&gt;　　我是毫不犹豫的支持A的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;错误应该尽早暴露。&lt;br /&gt;
  并且应该尽可能由开发者可控的引爆，而不是被动的爆掉，然后没头脑地分析爆炸现场。简单来说，一个好的开发人员应该让修正问题的代价尽可能的小。&lt;/li&gt;
&lt;li&gt;参数检查不是银弹，但即便如此，对一些普遍的错误做处理也是必要且高效的。&lt;br /&gt;
  比如常见的NULL指针。这些常见的错误可能占各种参数错误发生总量的一半，解决掉它们带来的收益是很可观的。很多事情很难做到100%完美，但是度量（很多时候靠经验）​面对的问题，整理出解决这些问题的收益比曲线，然后处理掉那些收益比最高的问题，就是一个很好的方法。而不是嚷嚷“我没办法解决100%的问题，所以我就不解决了。问题出​现了再说”。激进一点说，在我看来，这是不负责的想法。&lt;/li&gt;
&lt;li&gt;标准库的做法并不一定是正确的，比如臭名昭著的realloc。&lt;br /&gt;
  具体的缺点很多文章里有讨论，《代码大全》里也有提到。&lt;/li&gt;
&lt;li&gt;函数都需要检查参数。&lt;br /&gt;
  至于如何检查参数（比如是否需要检查空指针），主要取决于函数本身对参数的期望，而不应只取决“模块之间的约定”。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　说的远一些，我很喜欢有调试开关或者调试功能的开发库和工具。比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;*nix平台下的glibc中的MALLOC_CHECK_宏、valgrind，还有electric-fence（貌似这货会误报，哪位朋友分享一个更好的？）等等。&lt;/li&gt;
&lt;li&gt;windows下的application verifier、driver verifier，还有checked版本的系统等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　对我来说，我甚至希望所有的开发库都有类似的机制。我希望某天开发者能通过某个开关让strcpy检查空指针，检查源、目的覆盖问题等等。&lt;/p&gt;

&lt;p&gt;　　此外，还有一些涉及到防御型编程和“攻击型编程”（好像没有约定俗成的名称？姑且这么称呼吧）的想法。&lt;/p&gt;

&lt;p&gt;　　我个人推荐的做法是：对自己狠一点，对最终用户温柔一些。精确点说是“开发和内测版本中多用攻击型技术，让故障尽早（并且可控地）被引爆。发布版本里多用防御行编程，以包​容一些非致命的问题。”&lt;/p&gt;

&lt;p&gt;　　举例来说，本文最开始的ASSERT_RETURN宏就是这种方法的一个典型：&lt;/p&gt;

&lt;p&gt;　　在开发版本（#ifdef DEBUG分支）中，启用了assert，一旦不符合研发人员的预期，就会立刻引爆，让研发能够发现问题。而发布版本中则只是做了&amp;rdquo;if return/break/continue&amp;rdquo;等，包容了错误。让程序能够正常的运行下去。&lt;/p&gt;

&lt;p&gt;　　另外在发布版本中是包容还是优雅的退出，取决于具体的问题。比如office中发现用户通过剪贴板复制过来的数据不合要求，如果此时“优雅的退出”，用户可能杀人的心都有​了。&lt;/p&gt;

&lt;h1 id=&#34;五-性能优化相关的一些想法&#34;&gt;五、性能优化相关的一些想法&lt;/h1&gt;

&lt;p&gt;　　这个话题也是一个很庞大的话题，我只说说我个人的想法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;优化的前提是掌握了准确的性能分析数据，明确了性能瓶颈。没有进行科学的性能分析就着手进行的优化都是耍流氓。&lt;br /&gt;
  当然，开发过程中就拍脑袋想出来的“性能瓶颈”更是地球人愚蠢的想法（我自己犯过好几次，而且还是在我高举“过早优化是一切罪恶之源”大旗的情况下。最后都证明是捡了芝麻​丢了西瓜，感谢我的同事点醒了我）。&lt;br /&gt;
  开发阶段需要做的事是尽量的模块化和抽象，当后续诊断出性能瓶颈后可以很方便的替换、调优那些模块。&lt;/li&gt;
&lt;li&gt;自上而下，先考虑架构，再考虑层、模块，最后考虑底层的实现。&lt;br /&gt;
  切莫为“这个密集调用的函数里这条检查语句很复杂，可能会影响整体性能”而“优化”。首先，参考上述的1，别耍流氓。其次，优化也有收益比曲线，先优化收益比最高的那些瓶​颈，那些才是金矿。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　最后，广而告之：《代码大全》，你值得拥有。&lt;/p&gt;

&lt;h1 id=&#34;六-版本记录&#34;&gt;六、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2014-01-05, 初始发布。&lt;/li&gt;
&lt;li&gt;v1.1 - 2014-01-12, 增加了隔栏处的新思考。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>linux、osx下搭建操作系统开发环境 v1.1</title>
      <link>http://boxcounter.com/technique/2013-11-14-linux%E3%80%81osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83_v1.1/</link>
      <pubDate>Thu, 14 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-11-14-linux%E3%80%81osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83_v1.1/</guid>
      <description>

&lt;h1 id=&#34;一-前言&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　本文档记录的内容既适用于x86也适用于x64，只是对于后者有一些环境要求。&lt;br /&gt;
　　之前开发使用的方法是：自己的引导代码+虚拟软盘。优点是搭建简单，所有代码都是自己编写，可控性强。最近想试试使用grub的引导功能，于是花了些时间琢磨。搜出来的相​关资料有不少，但是要么是grub1的，要么太过零散，要么描述太过简略。总之，没有一篇文章详细的讲述整个配置过程。所以我就在搭建的过程中顺手整理了这么一篇完整的、​完全从零开始的方法，其中每一步都有较丰富的说明。&lt;br /&gt;
　　另外，本文档介绍的方法适用于osx和linux，实际上整个过程中大部分必须使用到linux。也就是说如果要按照本文档来搭建开发环境，linuxer只需要使用自己​的linux系统就行，而osxer还得备一套linux系统（比如虚拟机）。使用linux的主要原因是我选择了ext2作为文件系统，而osx上貌似只有读写ext2​的fuse-ext2，没有用于创建ext2分区的fdisk等工具（如果同好有osx的ext2创建工具推荐，劳烦分享给我(ns.boxcounter[at]gmail.com)吧，不胜感激）。如果改用fat32就没有这个烦恼，整个过程都可以在osx下完成，因为osx的fdisk就可以创建fat32分区。&lt;/p&gt;

&lt;p&gt;　　我使用的系统、软件情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;x86 ubuntu 12.04.2/x64 ubuntu 13.10、osx 10.8.4/osx 10.9&lt;/li&gt;
&lt;li&gt;nasm 2.10.09&lt;/li&gt;
&lt;li&gt;bochs 2.6.1&lt;/li&gt;
&lt;li&gt;grub2 2.0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　如果同好使用的环境不一样，可能需要根据情况自行调整一些细节。&lt;br /&gt;
　　另外，本文提供的命令在显示时候可能会自动折行，所以复制到剪贴板中之后（在折行处）可能会有多余的空格，请同好自行删减。&lt;/p&gt;

&lt;h1 id=&#34;二-创建虚拟磁盘-并分区&#34;&gt;二、创建虚拟磁盘，并分区&lt;/h1&gt;

&lt;p&gt;　　首先说明：&lt;br /&gt;
　　这里的目标磁盘的属性是：16 headers, 63 sectors per track, 512 bytes per sector。意味着每一个cylinder的大小是516096bytes（16 * 63 * 512）。&lt;br /&gt;
　　“#cylinders”表示柱面数，主要关系到磁盘大小。如果是10MB的磁盘，#cylinders=20。&lt;br /&gt;
　　需要在linux系统中进行，使用的工具是kpartx，系统默认没有自带，需要下载。&lt;/p&gt;

&lt;p&gt;　　好了，开始了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;dd if=/dev/zero of=antos.img bs=516096 count=#cylinders&lt;br /&gt;
创建虚拟磁盘。也可以使用bochs附带的bximage工具来完成。&lt;/li&gt;
&lt;li&gt;ps aux | grep loop&lt;br /&gt;
默认是搜索不到名为“[loopX]”进程的。如果有发现，那记住输出中的“[loopX]”进程。&lt;/li&gt;
&lt;li&gt;kpartx -av ./antos.img&lt;br /&gt;
挂载虚拟磁盘，可能没有输出。&lt;/li&gt;
&lt;li&gt;ps aux | grep loop&lt;br /&gt;
正常情况下，这里会发现一个名为“[loop0]”的进程。说明antos.img被挂载到了“/dev/loop0”设备上。如果前面搜索结果中已经有了“[loopX]”进程，那新增加的那个进程就是挂载的设备名。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fdisk -u -C#cylinders -S63 -H16 /dev/loop0&lt;br /&gt;
为磁盘分区。以#cylinders=20、单个分区为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# fdisk -u -C20 -S63 -H16 /dev/loop0
Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel
Building a new DOS disklabel with disk identifier 0x136d49ee.
Changes will remain in memory only, until you decide to write them.
After that, of course, the previous content won&#39;t be recoverable.

Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)

Command (m for help): o &amp;lt;&amp;lt;&amp;lt;=== Create a new empty DOS partition table
Building a new DOS disklabel with disk identifier 0x5bd665d5.
Changes will remain in memory only, until you decide to write them.
After that, of course, the previous content won&#39;t be recoverable.

Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)

Command (m for help): n &amp;lt;&amp;lt;&amp;lt;=== Create a new partition
Partition type:
p   primary (0 primary, 0 extended, 4 free)
e   extended
Select (default p): &amp;lt;&amp;lt;&amp;lt;=== 回车
Partition number (1-4, default 1): &amp;lt;&amp;lt;&amp;lt;=== 回车
First sector (2048-20159, default 2048): &amp;lt;&amp;lt;&amp;lt;=== 回车
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-20159, default 20159): &amp;lt;&amp;lt;&amp;lt;=== 回车
Using default value 20159

Command (m for help): a &amp;lt;&amp;lt;&amp;lt;=== Toggle the bootable flag (Optional)
Partition number (1-4): 1 &amp;lt;&amp;lt;&amp;lt;=== 分区1

Command (m for help): p &amp;lt;&amp;lt;&amp;lt;=== Print the partition table.

Disk /dev/loop0: 10 MB, 10321920 bytes
16 heads, 63 sectors/track, 20 cylinders, total 20160 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x5bd665d5

Device Boot      Start         End      Blocks   Id  System
/dev/loop0p1   *        2048       20159        9056   83  Linux
&amp;lt;&amp;lt;&amp;lt;=== 如果使用附录2记录的方法，需要记录Start和Blocks的值，本例子中分别是2048和9056。

Command (m for help): w &amp;lt;&amp;lt;&amp;lt;=== Write partition table to our &#39;disk&#39; and exit
The partition table has been altered!

Calling ioctl() to re-read partition table.

WARNING: Re-reading the partition table failed with error 22: Invalid argument.
The kernel still uses the old table. The new table will be used at
the next reboot or after you run partprobe(8) or kpartx(8)
Syncing disks.
&amp;lt;&amp;lt;&amp;lt;=== Ignore any errors about rereading the partition table. Since it&#39;s not a physical device we really don&#39;t care.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kpartx -dv ./antos.img&lt;br /&gt;
卸载磁盘，应该输出“loop deleted : /dev/loop0”。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kpartx -av ./antos.img&lt;br /&gt;
挂载分区磁盘，这次新创建的分区也会自动挂载。&lt;br /&gt;
正常会输出“add map loop0p1 (252:0): 0 18112 linear /dev/loop0 2048”，表示分区挂载到了“/dev/mapper/loop0p1”设备上。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mke2fs -b1024 /dev/mapper/loop0p1&lt;br /&gt;
格式化分区，&amp;rdquo;-b1024&amp;rdquo;表示使用1KB的block。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mkdir /tmp/antos&lt;br /&gt;
创建挂载目录。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mount -text2 /dev/mapper/loop0p1 /tmp/antos&lt;br /&gt;
挂载分区到目录。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ls /tmp/antos/&lt;br /&gt;
如果前面的步骤都成功，会看到名为“lost+found”的目录，说明磁盘和分区都正确的创建了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;三-安装grub2到虚拟磁盘&#34;&gt;三、安装grub2到虚拟磁盘&lt;/h1&gt;

&lt;p&gt;　　假设磁盘挂载到设备“/dev/loop0”上，分区挂载到“/tmp/antos”目录下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grub-install --no-floppy --modules=&amp;quot;biosdisk part_msdos ext2 configfile normal multiboot&amp;quot; --root-directory=/tmp/antos /dev/loop0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　安装过程中可能会报警告，只要最后输出“Installation finished. No error reported.”就表示安装成功了。&lt;br /&gt;
　　如果使用的系统是x64架构的，需要使用新一些的系统，比如ubuntu 13.10。具体原因请参考附录一。&lt;br /&gt;
　　（在fedora等redhat系中使用的名称是“grub2-install”）&lt;/p&gt;

&lt;h1 id=&#34;四-在bochs中使用虚拟磁盘&#34;&gt;四、在bochs中使用虚拟磁盘&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;确认虚拟磁盘的属性。&lt;br /&gt;
先挂载虚拟磁盘，然后执行“disk -u -l /dev/loop0”，正常会有如下输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 Disk /dev/loop0: 10 MB, 10321920 bytes
2 16 heads, 63 sectors/track, 20 cylinders, total 20160 sectors
3 Units = sectors of 1 * 512 = 512 bytes
4 Sector size (logical/physical): 512 bytes / 512 bytes
5 I/O size (minimum/optimal): 512 bytes / 512 bytes
6 Disk identifier: 0x6418cb2e
7
8       Device Boot      Start         End      Blocks   Id  System
9 /dev/loop0p1   *        2048       20159        9056   83  Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第2行说明了虚拟磁盘的属性。（前面使用fdisk为磁盘分区的时候也有输出同样的内容，如果记下来了，就可以不需要这一步）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建bochs虚拟机配置文件&lt;br /&gt;
不带参数运行bochs，应该会有这样的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. Restore factory default configuration
2. Read options from...
3. Edit options
4. Save options to...
5. Restore the Bochs state from...
6. Begin simulation
7. Quit now

Please choose one: [2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选择4，然后输入配置文件名，比如“antos.bxrc”，提示保存成功后退出bochs。这样就有了一份默认配置的bochs虚拟机配置文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改bochs虚拟机配置文件，以适应我们的需要&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加虚拟磁盘。&lt;br /&gt;
将这一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ata0-master: type=none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ata0-master: type=disk, path=&amp;quot;./antos.img&amp;quot;, cylinders=#cylinders,heads=#heads,spt=#sec-per-track
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应之前获取到的磁盘属性，这一行应该是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ata0-master: type=disk, path=&amp;quot;./antos.img&amp;quot;, cylinders=20,heads=16,spt=63
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改启动项为磁盘。&lt;br /&gt;
将这一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boot: floppy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boot: disk
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开启bochs的magic breakpoint。&lt;br /&gt;
将这一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;magic_break: enabled=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;magic_break: enabled=1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　到这里，就可以在bochs中运行了（命令是“bochs -f antos.bxrc”），并且看到grub2的命令提示符，如图：&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://boxcounter.com/images/2013-11-14/grub-cmdline.png&#34;/&gt;&lt;/p&gt;

&lt;h1 id=&#34;五-编写最简单的系统内核&#34;&gt;五、编写最简单的系统内核&lt;/h1&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;//&lt;/span&gt; kernel.asm&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;源码&lt;/span&gt;
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;section&lt;/span&gt; .kernel]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;bits&lt;/span&gt; 32]

load_base&lt;span style=&#34;color: #0000ff&#34;&gt; equ&lt;/span&gt; 0x100000

&lt;span style=&#34;color: #008000&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color: #008000&#34;&gt;; multiboot header&lt;/span&gt;
&lt;span style=&#34;color: #008000&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
multiboot_header:
MBH_magic&lt;span style=&#34;color: #0000ff&#34;&gt;            equ&lt;/span&gt; 0xE85250D6
MBH_architecture&lt;span style=&#34;color: #0000ff&#34;&gt;     equ&lt;/span&gt; 0            &lt;span style=&#34;color: #008000&#34;&gt;; 32-bit protected mode&lt;/span&gt;
MBH_header_length&lt;span style=&#34;color: #0000ff&#34;&gt;    equ&lt;/span&gt; multiboot_header_end - multiboot_header
MBH_checksum&lt;span style=&#34;color: #0000ff&#34;&gt;         equ&lt;/span&gt; -(MBH_header_length + MBH_magic + MBH_architecture)

&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_magic
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_architecture
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_header_length
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_checksum

&lt;span style=&#34;color: #008000&#34;&gt;; tags&lt;/span&gt;
info_request_tag:
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 1
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; info_request_tag_end - info_request_tag
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 5
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 6
info_request_tag_end:
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
address_tag:
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 2
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; address_tag_end - address_tag
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; load_base                 &lt;span style=&#34;color: #008000&#34;&gt;; header_addr&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; load_base                 &lt;span style=&#34;color: #008000&#34;&gt;; load_addr&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 0                         &lt;span style=&#34;color: #008000&#34;&gt;; load_end_addr&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 0                         &lt;span style=&#34;color: #008000&#34;&gt;; bss_end_addr&lt;/span&gt;
address_tag_end:
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
entry_address_tag:
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 3
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; entry_address_tag_end - entry_address_tag
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; load_base + kernel_entry
entry_address_tag_end:
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
&lt;span style=&#34;color: #008000&#34;&gt;; end tag&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 8
multiboot_header_end:

kernel_entry:
xchg bx, bx                 &lt;span style=&#34;color: #008000&#34;&gt;; magic breakpoint&lt;/span&gt;
jmp &lt;span style=&#34;color: #0000ff&#34;&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;br /&gt;
　　编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nasm kernel.asm -o kernel.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　编译过程中可能会报警告，无视它。&lt;br /&gt;
　　将虚拟磁盘挂载到某个目录，然后将kernel.bin拷贝到分区的根目录，即和/boot目录同一层目录。&lt;/p&gt;

&lt;h1 id=&#34;六-使用grub2启动自行编写的操作系统内核&#34;&gt;六、使用grub2启动自行编写的操作系统内核&lt;/h1&gt;

&lt;p&gt;　　假设分区挂载到“/tmp/antos”目录下，那么创建grub需要的配置文件“/tmp/antos/boot/grub/grub.cfg”，将以下几行文本贴进去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set default=0
insmod ext2
set root=(hd0,1)
set timeout=10
menuentry &amp;quot;antos 0.0.1&amp;quot; {
   insmod ext2
   set root=(hd0,1)
   multiboot2 (hd0,1)/kernel.bin
   boot
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　其中(hd0,1)表示咱之前创建的虚拟磁盘的第一个分区，kernel.bin就是前面编译的系统内核文件。&lt;/p&gt;

&lt;p&gt;　　现在可以启动咱的bochs虚拟机了，执行“bochs -f antos.bxrc”。&lt;br /&gt;
　　再输入c继续执行后，应该就能看到bochs从咱的虚拟磁盘引导，然后可以看见grub的选择界面，最后会中断到咱系统内核的“xchg bx, bx”指令，这是bochs内置的主动中断指令，即magic breakpoint机制。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o 00449811185i[CPU0 ] [449811185] Stopped on MAGIC BREAKPOINT
(0) Magic breakpoint
Next at t=449811185
(0) [0x000000100053] 0010:0000000000100053 (unk. ctxt): jmp .-2 (0x00100053) ; ebfe
00449811185i[XGUI ] Mouse capture off
&amp;lt;bochs:2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　ok，整个配置过程就完毕了，整个过程都是在linux中完成的。使用fat32的osx同好可以使用类似的方法来完成。整个过程每一步的功能都写的很清楚了，看到这里理​理思路应该就明白整个流程了。&lt;/p&gt;

&lt;h1 id=&#34;七-osx中读写ext2文件系统的虚拟磁盘&#34;&gt;七、osx中读写ext2文件系统的虚拟磁盘&lt;/h1&gt;

&lt;p&gt;　　最后说说osx相关的内容，因为我不想每次做开发的时候都需要开个linux虚拟机。以下是在osx下读写虚拟磁盘的方法，比如更新的kernel.bin等等。linu​xer可以无视这一步。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装osxfuse和fuse-ext2&lt;br /&gt;
fuse-ext2默认只能以只读方式挂载设备，所以需要进行以下修改使其默认以可读可写方式挂载设备：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo vi /System/Library/Filesystems/fuse-ext2.fs/fuse-ext2.util
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搜索定位到Mount函数，为其名为“OPTIONS”的变量增加额外的“rw+”选项。&lt;br /&gt;
比如：原内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mount ()
{
      LogDebug &amp;quot;[Mount] Entering function Mount...&amp;quot;
      # Setting both defer_auth and defer_permissions. The option was renamed
      # starting with MacFUSE 1.0.0, and there seems to be no backward
      # compatibility on the options.
      OPTIONS=&amp;quot;auto_xattr,defer_permissions&amp;quot;
      ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mount ()
{
      LogDebug &amp;quot;[Mount] Entering function Mount...&amp;quot;
      # Setting both defer_auth and defer_permissions. The option was renamed
      # starting with MacFUSE 1.0.0, and there seems to be no backward
      # compatibility on the options.
      OPTIONS=&amp;quot;auto_xattr,defer_permissions,rw+&amp;quot;
      ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;挂载磁盘到设备&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hdiutil attach -nomount antos.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是会输出如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dev/disk1              FDisk_partition_scheme
/dev/disk1s1            Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明虚拟磁盘已经挂载到/dev/disk1设备上了，分区已经挂载到/dev/disk1s1。（之所以加上-nomount参数，是因为hdiutil没法正确地挂载ext2分区到目录）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;挂载分区到目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sbin/mount_fuse-ext2 /dev/disk1s1 ./mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/dev/disk1s1是步骤3中得到的设备（分区)名。&lt;br /&gt;
到这里，就可以对分区内容进行修改了，比如更新kernel.bin等等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从目录卸载分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;umount ./mnt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;卸载虚拟磁盘&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hdiutil detach /dev/disk1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（注意是磁盘设备，不是分区设备disk1s1）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;八-附录一-x64-ubuntu-12-04-2中执行grub-install遇到的问题&#34;&gt;八、附录一：x64 ubuntu 12.04.2中执行grub-install遇到的问题&lt;/h1&gt;

&lt;p&gt;　　我在x64 ubuntu 12.04.2中执行“安装grub2到虚拟磁盘”操作时总是失败，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@x64:~# grub-install --no-floppy --modules=&amp;quot;biosdisk part_msdos ext2 configfile normal multiboot&amp;quot; --root-directory=/tmp/antos /dev/loop0
Path `/tmp/antos/boot/grub&#39; is not readable by GRUB on boot. Installation is impossible. Aborting.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　加上&amp;ndash;deubg选项后，发现grub-install输出了这么几行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ /usr/local/sbin/grub-probe -t fs /tmp/antos/boot/grub
+ return 1
+ gettext_printf Path `%s&#39; is not readable by GRUB on boot. Installation is impossible. Aborting.\n /tmp/antos/boot/grub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　手动执行grub-probe，输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# /usr/local/sbin/grub-probe -t fs /tmp/antos/boot/grub/usr/local/sbin/grub-probe: error: disk `lvm/loop0p1&#39; not found.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我查阅了很多资料，都没有明确的解决方案。经过了约莫20个小时的摸索，最终发现只需要使用新版本的系统自带的grub 2.0.0即可。（注：x64 ubuntu 12.04.2中的grub2是我源码编译的2.0.0版，也尝试过使用trunk源码编译或者使用系统自带的1.99，都会报错。）&lt;/p&gt;

&lt;h1 id=&#34;九-附录二-创建虚拟磁盘分区的另外一种方法-losetup&#34;&gt;九、附录二：创建虚拟磁盘分区的另外一种方法（losetup）&lt;/h1&gt;

&lt;p&gt;　　需要说明，这种方法较前面介绍的使用kpartx的方法要繁琐，所以并不推荐（特别是如果要使用多分区）。补充在这里的原因是我最开始搜索到的资料使用的就是losetu​p工具，摸索成功之后才发现kpartx。&lt;br /&gt;
　　另外，操作过程中有部分步骤和前面讲述的步骤一样，所以省略了那些步骤的说明。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;dd if=/dev/zero of=antos.img bs=516096 count=#cylinders&lt;/li&gt;
&lt;li&gt;losetup /dev/loop0 ./antos.img&lt;br /&gt;
这个时候执行“ps aux | grep loop”，会看到一个名为[loop0]的进程。（如果loop0被占用，可以换一个设备）&lt;/li&gt;
&lt;li&gt;fdisk -u -C#cylinders -S63 -H16 /dev/loop0&lt;/li&gt;
&lt;li&gt;losetup /dev/loop0 ./antos.img&lt;br /&gt;
这个时候执行“ps aux | grep loop”，会看到一个名为[loop0]的进程。（如果loop0被占用，可以换一个设备）&lt;/li&gt;
&lt;li&gt;losetup -d /dev/loop0&lt;br /&gt;
到这里，虚拟磁盘已经创建完毕了，从设备（“loop0”）上卸载虚拟磁盘，准备格式化。&lt;/li&gt;
&lt;li&gt;losetup -o1048576 /dev/loop0 ./antos.img&lt;br /&gt;
再次挂载，与前面挂载不同的是，这次使用了“-o1048576”参数，目的是跳过前1048576字节，来到分区的开始。前面提到要记住Start的值，即分区开始扇区号，这里就需要使用它了，1048576=20​48*512。&lt;/li&gt;
&lt;li&gt;mke2fs -b1024 /dev/loop0 9056&lt;br /&gt;
对加载到“loop0”设备上的*分区*（注意是分区，不是整个磁盘了，前面咱跳到了分区开始处）进行格式化，使用的是ext2文件系统。&lt;br /&gt;
”-b1024“表示使用1KB的block，9056就是之前的Blocks的值，即整个分区的blocks数。&lt;/li&gt;
&lt;li&gt;mkdir /tmp/antos&lt;/li&gt;
&lt;li&gt;mount -text2 /dev/loop0 /tmp/antos&lt;/li&gt;
&lt;li&gt;umount /dev/loop0&lt;/li&gt;
&lt;li&gt;losetup -d /dev/loop0&lt;br /&gt;
卸载目录和设备。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;十-主要参考资料&#34;&gt;十、主要参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The Multiboot Specification&lt;/li&gt;
&lt;li&gt;grub2源码&lt;/li&gt;
&lt;li&gt;Mac OS X下读写ext2/ext3文件系统&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;十一-版本记录&#34;&gt;十一、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-09-02，初始发布。&lt;/li&gt;
&lt;li&gt;v1.1 - 2013-11-14，增加x64系统下的说明。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-11-14/linux、osx下搭建操作系统开发环境的完整步骤_v1.1.pdf&#34;&gt;2013-11-14-linux、osx下搭建操作系统开发环境_v1.1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下搭建操作系统开发环境之64位交叉开发工具集（gcc&#43;gdb）v1.0</title>
      <link>http://boxcounter.com/technique/2013-11-08-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B64%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.0/</link>
      <pubDate>Fri, 08 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-11-08-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B64%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.0/</guid>
      <description>

&lt;h1 id=&#34;一-前言&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　《&lt;a href=&#34;http://boxcounter.com/2013/11/04/osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B32%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc+gdb%EF%BC%89v1.1&#34;&gt;osx下搭建操作系统开发环境之32位交叉开发工具集(gcc+gdb)&lt;/a&gt;》一文中讲解了32位交叉工具的构建。64位（专指x64，非IA64）的构建方法和32位基本相同。看过前文的朋友看本文会发现绝大多数内容都是一样的。没错，之所以不基于前文、只讲差异，是为了独立性，方便只关注x64构建方法的朋友。&lt;br /&gt;
　　我的环境：osx 10.9&lt;/p&gt;

&lt;h1 id=&#34;二-安装osx版的gcc&#34;&gt;二、安装osx版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;brew install gcc48
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　推荐下载最新的稳定版gcc。&lt;/p&gt;

&lt;h1 id=&#34;三-配置编译环境&#34;&gt;三、配置编译环境&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;下载gcc源码&lt;br /&gt;
根据参考资料1的建议，最好使用最新的gcc来进行编译，被编译的源码也推荐使用一样版本的。也就是说，用gcc 4.8.2来编译gcc 4.8.2的源码。&lt;br /&gt;
下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gcc&#34;&gt;源码包&lt;/a&gt;并解压，得到的目录名称之为“$gcc-4.8.2”。&lt;/li&gt;
&lt;li&gt;下载gcc依赖项&lt;br /&gt;
需要的依赖项有：

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gnu.org/software/binutils/&#34;&gt;GNU Binutils&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gmplib.org/&#34;&gt;GMP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mpfr.org/&#34;&gt;MPFR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://multiprecision.org/&#34;&gt;MPC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将它们都解压出来，把解压出来的b、c、d的目录都放到gcc源码目录下。都需要去掉版本号，比如解压出来的目录名为“mpc-1.0.1”，那么现在就是“$gcc-4.8.2/mpc”。a无需这么做，因为它需要单独编译，参考后续的步骤4。&lt;br /&gt;
   其中GMP源码包是lzip压缩格式，需要下载lzip工具解压（brew安装）。
3. 下载gdb源码&lt;br /&gt;
   下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gdb&#34;&gt;源码包&lt;/a&gt;并解压，得到的目录名称之为“$gdb-7.6.1”。
4. 设置环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export CC=/usr/local/bin/gcc-4.8
    export CXX=/usr/local/bin/g++-4.8
    export CPP=/usr/local/bin/cpp-4.8
    export LD=/usr/local/bin/gcc-4.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都是brew版gcc4.8.2的软链接。如果不设置，那么会使用系统中默认自带的工具，这些工具的版本可能比较老。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export PREFIX=$HOME/opt/cross
    export TARGET=x86_64-pc-linux-gnu
    export PATH=&amp;quot;$PREFIX/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是编译时候使用的选项。需要注意的是：osdev上的《&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler_for_x86_64&#34;&gt;GCC Cross-Compiler for x86 64&lt;/a&gt;》建议将TARGET宏定义为x86_64-elf，但是我实验发现这样行不通，编译gdb的时候会报错“configure: error: configuration x86_64-pc-elf is unsupported.”。
5. 编译交叉版的binutils&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    cd $binutils-x.y.z
    mkdir build-binutils
    cd build-binutils
    ../configure --target=$TARGET --prefix=$PREFIX --enable-64-bit-bfd --enable-werror=no
    make
    make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;四-编译交叉版的gcc&#34;&gt;四、编译交叉版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gcc-4.8.2
mkdir build-gcc
cd build-gcc
../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls --enable-languages=c,c++ --without-headers
make all-gcc
make all-target-libgcc
make install-gcc
make install-target-libgcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后，在“~/opt/cross/bin”下就能看到编译好的交叉版的编译套件了，包括“x86_64-pc-linux-gnu-gcc”、“x86_64-pc-linux-gnu-g++”和“x86_64-pc-linux-gnu-ld ”等等。可以用“$HOME/opt/cross/bin/$TARGET-gcc &amp;ndash;version”来验证一下版本是否正确。&lt;br /&gt;
　　另外，为了方便使用，可以在.bashrc或者.zshrc中调整环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=&amp;quot;$HOME/opt/cross/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;五-编译交叉版的gdb&#34;&gt;五、编译交叉版的gdb&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gdb-7.6.1
mkdir build-$TARGET
cd build-$TARGET
../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls --enable-64-bit-bfd --enable-werror=no CFLAGS=&amp;quot;-m64&amp;quot;
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后，在“~/opt/cross/bin”下就能看到编译好的交叉版的x86_64-pc-linux-gnu-gdb了。&lt;/p&gt;

&lt;p&gt;　　注：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;和x64的bochs配合调试的时候，需要切换到x86-64模式（默认模式是i386）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) set architecture i386:x86-64
The target architecture is assumed to be i386:x86-64
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在这个编译选项版本之前，我尝试了好几种其他的编译选项，虽然都能编译出gdb，但是都无法与x64的bochs进行配合调试。包括使用“../configure &amp;ndash;enable-targets=all &amp;ndash;enable-64-bit-bfd”。无法与x64的bochs进行配合调试的现象是，gdb能够下断，但是中断点都是错误的，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) target remote localhost:1234
Remote debugging using 192.168.1.16:1234
0x00000000 in ?? ()
(gdb) b *0x7c00
Breakpoint 1 at 0x7c00
(gdb) c
Continuing.
Program received signal SIGTRAP, Trace/breakpoint trap.
0x000e0000 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常应该是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) target remote 192.168.1.16:1234
Remote debugging using localhost:1234
0x000000000000fff0 in ?? ()
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结，gdb的TARGET要和bochs（而非被调试OS）的平台一致，即如果使用的是x64的bochs，那么gdb的编译TARGET也需要是x64的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;六-参考资料&#34;&gt;六、参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler&#34;&gt;GCC Cross-Compiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler_for_x86_64&#34;&gt;GCC Cross-Compiler for x86 64&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.utah.edu/~manua/sim_doc/simics-reference-manual-public-all/topic96.html&#34;&gt;gdb-remote&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sourceforge.net/p/bochs/discussion/39592/thread/a489c7f1&#34;&gt;bochs + GDB help&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;七-版本记录&#34;&gt;七、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-11-08，初始发布。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-11-08/osx下搭建操作系统开发环境之64位交叉开发工具集（gcc+gdb）v1.0.pdf&#34;&gt;osx下搭建操作系统开发环境之64位交叉开发工具集（gcc+gdb）v1.0.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下搭建操作系统开发环境之构建bochs v1.0</title>
      <link>http://boxcounter.com/technique/2013-11-05-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B%E6%9E%84%E5%BB%BAbochs_v1.0/</link>
      <pubDate>Tue, 05 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-11-05-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B%E6%9E%84%E5%BB%BAbochs_v1.0/</guid>
      <description>

&lt;h1 id=&#34;一-前言&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　我编译bochs的目的是为了启用gdb调试功能。bochs提供的调试器功能较简单，开发过程中还是gdb更趁手。本文记录的方法是我一点点尝试出来的，参考了网上一些零碎资料。整个过程虽然简单但是整体比较凌乱，特别是需要对bochs的官方源码包做好几处修改。目前不太想再花时间优化过程，能编译出来就好。如果有同好有更简单的方法，有劳和我分享一下吧。&lt;br /&gt;
　　我的环境：osx 10.9，bochs 2.6.2、使用x11作为界面库。&lt;/p&gt;

&lt;h1 id=&#34;二-安装x11&#34;&gt;二、安装X11&lt;/h1&gt;

&lt;p&gt;　　下载&lt;a href=&#34;http://xquartz.macosforge.org/trac&#34;&gt;XQuartz&lt;/a&gt;安装包，并安装。&lt;/p&gt;

&lt;h1 id=&#34;三-配置编译环境&#34;&gt;三、配置编译环境&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;export CC=/usr/bin/gcc
export CXX=/usr/bin/g++
export CPP=/usr/bin/cpp
export LD=/usr/bin/g++
export CFLAGS=-I/usr/X11/include
export PREFIX=/Users/boxcounter/opt/bochs-gdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　根据我的试验，使用brew安装的gcc编译会报错，使用系统自带的就可以正常编译，所以调整了CC等环境变量。PREFIX宏请根据需要自行修改。&lt;/p&gt;

&lt;h1 id=&#34;四-编译bochs&#34;&gt;四、编译bochs&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;下载&lt;a href=&#34;http://sourceforge.net/projects/bochs/files/bochs/&#34;&gt;源码包&lt;/a&gt;并解压，解压出来的目录名称之为“$bochs”。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改.conf.macosx&lt;br /&gt;
根据需要修改configure的参数，比如以下是我使用的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --enable-disasm \
            --disable-docbook \
            --enable-x86-64 \
            --enable-pci \
            --enable-all-optimizations \
            --enable-plugins \
            --enable-cdrom \
            --enable-a20-pin \
            --enable-fpu \
            --enable-alignment-check \
            --enable-large-ramfile \
            --enable-readline \
            --enable-iodebug \
            --enable-xpm \
            --enable-show-ips \
            --enable-logging \
            --enable-usb \
            --enable-ne2000 \
            --enable-cpu-level=6 \
            --enable-sb16 \
            --enable-clgd54xx \
            --with-term \
            --enable-ne2000 \
            --with-x11 \
            --enable-idle-hack \
            --enable-gdb-stub \
            --prefix=${PREFIX} \
            ${CONFIGURE_ARGS}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;chmod u+x ./.conf.macosx &amp;amp;&amp;amp; ./.conf.macosx&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改ldtl相关选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将$bochs/config.h中的“BX_HAVE_LTDL”宏的定义由1改为0，只有一处。&lt;/li&gt;
&lt;li&gt;将$bochs/Makefile中的“-lltdl”改为“ltdl.o”，有多处。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调整gui模块的编译选项&lt;br /&gt;
将$bochs/gui/Makefile中的“X_LIBS =  -lXpm -lXrandr”修改为“X_LIBS = -L/usr/X11/lib -lXpm -lXrandr”&lt;br /&gt;
如果不进行此项修改，在gui目录下进行链接的时候总会报错，提示无法找到Xmp库。使用LDFLAGS环境变量或者修改.conf.macosx中的LDFLAGS都没有用，因为gui模块链接过程中并没有使用到它们。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make &amp;amp;&amp;amp; make install&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;五-参考资料&#34;&gt;五、参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sourceforge.net/p/bochs/discussion/39592/thread/9c22887c&#34;&gt;No rule to make target `-lltdl&amp;rsquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;六-版本记录&#34;&gt;六、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-11-05，初始发布。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-11-05/osx下搭建操作系统开发环境之构建bochs_v1.0.pdf&#34;&gt;osx下搭建操作系统开发环境之构建bochs_v1.0.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下搭建操作系统开发环境之32位交叉开发工具集（gcc&#43;gdb）v1.1</title>
      <link>http://boxcounter.com/technique/2013-09-07-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B32%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.1/</link>
      <pubDate>Mon, 04 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-09-07-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B32%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.1/</guid>
      <description>

&lt;h1 id=&#34;一-前言&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　《&lt;a href=&#34;http://boxcounter.com/2013/11/14/linux%E3%80%81osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83_v1.1&#34;&gt;linux、osx下搭建操作系统开发环境的完整步骤&lt;/a&gt;》一文中讲解了一些基本的搭建方法，并提供了一个nasm汇编编写的简单的系统内核源码。实际开发过程中更多使用的是C语言，就需要有一个配套的C编译器。因为我使用的可执行文件是elf格式，所以我选择的是GCC。但是osx下安装的GCC生成的是osx的可执行文件格式，并不是elf。所以我需要一个能在osx下生成elf的GCC，俗称的交叉编译器。&lt;br /&gt;
　　我的环境：osx 10.8.4 &amp;amp; 10.9&lt;/p&gt;

&lt;h1 id=&#34;二-安装osx版的gcc&#34;&gt;二、安装osx版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;brew install gcc48
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　推荐下载最新的稳定版gcc。&lt;/p&gt;

&lt;h1 id=&#34;三-配置编译环境&#34;&gt;三、配置编译环境&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;下载gcc源码&lt;br /&gt;
根据&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler&#34; title=&#34;「GCC Cross-Compiler」&#34;&gt;参考资料1&lt;/a&gt;的建议，最好使用最新的gcc来进行编译，被编译的源码也推荐使用一样版本的。也就是说，用gcc 4.8.1来编译gcc 4.8.1的源码。&lt;br /&gt;
下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gcc/&#34;&gt;源码包&lt;/a&gt;并解压，得到的目录名称之为「$gcc-4.8.1」。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载依赖项&lt;br /&gt;
需要的依赖项有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://gnu.org/software/binutils/&#34;&gt;GNU Binutils&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gmplib.org/&#34;&gt;GMP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mpfr.org/&#34;&gt;MPFR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://multiprecision.org/&#34;&gt;MPC&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将它们都解压出来，把解压出来的2、3、4的目录都放到gcc源码目录下。都需要去掉版本号，比如解压出来的目录名为「mpc-1.0.1」，那么现在就是「$gcc-4.8.1/mpc」。1无需这么做，因为它需要单独编译，参考后续的步骤4。&lt;br /&gt;
   其中GMP源码包是lzip压缩格式，需要下载lzip工具解压（brew安装）。
3. 下载 gdb 源码&lt;br /&gt;
   下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gdb/&#34;&gt;源码包&lt;/a&gt;并解压,得到的目录名称之为「$gdb-7.6.1」。
4. 设置环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export CC=/usr/local/bin/gcc-4.8
    export CXX=/usr/local/bin/g++-4.8
    export CPP=/usr/local/bin/cpp-4.8
    export LD=/usr/local/bin/gcc-4.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都是brew版gcc4.8.1的软链接。如果不设置，那么会使用系统中默认自带的工具，这些工具版本都很陈旧。比如osx 10.8.4带的/usr/bin/gcc是4.2版本的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export PREFIX=$HOME/opt/cross
    export TARGET=i586-elf
    export PATH=&amp;quot;$PREFIX/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是编译时候使用的选项。
5. 编译交叉版的binutils&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    cd $binutils-x.y.z
    mkdir build-binutils
    cd build-binutils
    ../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls
    make
    make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;四-编译交叉版的gcc&#34;&gt;四、编译交叉版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gcc-4.8.1
mkdir build-gcc
cd build-gcc
../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls --enable-languages=c,c++ --without-headers
make all-gcc
make all-target-libgcc
make install-gcc
make install-target-libgcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后，在「~/opt/cross/bin」下就能看到编译好的交叉版的编译套件了，包括「i586-elf-gcc」、「i586-elf-g++」和「i586-elf-ld」等等。可以用「$HOME/opt/cross/bin/$TARGET-gcc &amp;ndash;version」来验证一下版本是否正确。&lt;br /&gt;
　　另外，为了方便使用，可以在.bashrc或者.zshrc中调整环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=&amp;quot;$HOME/opt/cross/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;五-测试源码&#34;&gt;五、测试源码&lt;/h1&gt;

&lt;p&gt;　　现在咱有了交叉编译器了，试试效果吧：
&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000&#34;&gt;// kernel.c&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;&amp;quot;multiboot2.h&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;&lt;/span&gt;


&lt;span style=&#34;color: #0000ff&#34;&gt;#define INFO_REQ_COUNT  2&lt;/span&gt;

&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header_tag_information_request
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header_tag_information_request info_req __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
    multiboot_uint32_t req[INFO_REQ_COUNT];
} __attribute__((packed));


&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header header __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header_tag_information_request info_req __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header_tag end __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
} __attribute__((packed));


&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header amb =
{
    {
        MULTIBOOT2_HEADER_MAGIC,
        MULTIBOOT_ARCHITECTURE_I386,
        &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header),
        -(MULTIBOOT2_HEADER_MAGIC + MULTIBOOT_ARCHITECTURE_I386 + &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header))
    },

    {
        {
            MULTIBOOT_HEADER_TAG_INFORMATION_REQUEST,
            MULTIBOOT_HEADER_TAG_OPTIONAL,
            &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header_tag_information_request)
        },
        MULTIBOOT_TAG_TYPE_BASIC_MEMINFO,
        MULTIBOOT_TAG_TYPE_FRAMEBUFFER
    },

    {
        MULTIBOOT_HEADER_TAG_END,
        MULTIBOOT_HEADER_TAG_OPTIONAL,
        &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header_tag)
    }
};


&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; breakpoint()
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;asm&lt;/span&gt;(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;xchg %bx, %bx&amp;quot;&lt;/span&gt;);
}


&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; _start()
{
    breakpoint();
    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;　　multiboot2.h头文件是从grub2.0.0的源码里拷贝过来的，主要定义了符合multiboot2规范的数据结构。&lt;br /&gt;
　　编译方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/opt/cross/bin/i586-elf-gcc -c -o kernel.o kernel.c
~/opt/cross/bin/i586-elf-ld -Ttext=0x100000 -o kernel.bin kernel.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　「-Ttext=0x100000」是为了让代码段加载到0x100000，而不是默认的08048074（我的环境中），后者超出我的bochs虚拟机的物理内存空间。&lt;br /&gt;
　　然后用kernel.bin替换之前的虚拟磁盘中的同名文件，再运行bochs虚拟机就能看到熟悉的magic breakpoint了。&lt;/p&gt;

&lt;h1 id=&#34;六-编译交叉版的-gdb&#34;&gt;六、编译交叉版的 gdb&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gdb-7.6.1
mkdir build-$TARGET
cd build-$TARGET
../configure --target=$TARGET --prefix=$PREFIX --disable-nls
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后,在「~/opt/cross/bin」下就能看到编译好的交叉版的i586-elf-gdb 了。&lt;/p&gt;

&lt;h1 id=&#34;七-参考资料&#34;&gt;七、参考资料&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler&#34;&gt;GCC Cross-Compiler&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;八-版本记录&#34;&gt;八、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-09-07，初始发布。&lt;/li&gt;
&lt;li&gt;v1.1 - 2013-11-04，增加「编译交叉版的gdb」章节。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;九-网友补充&#34;&gt;九、网友补充&lt;/h1&gt;

&lt;p&gt;以下内容为热心网友补充，供同好参考。（我没有验证。暂记录在这里，后续验证过后我再补入正文。感谢这位网友被我之前老博客系统的验证码刁难了N次后，还依然告知我，非常感谢。）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;OSX10.9下使用gcc4.8编译binutils-2.24会报错：nm.c:1687:7: error: &amp;lsquo;sbrk&amp;rsquo; is deprecated (declared at /usr/include/unistd.h:582)&lt;br /&gt;
需要使用gcc4.9，编译时指定编译参数CFLAGS=-Wno-error=deprecated-declarations&lt;br /&gt;
gcc的依赖项GMP/FPMR/MPC也不需要手动下载，在gcc的源码下执行./contrib/download_prerequisites即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-09-17/osx下搭建操作系统开发环境之32位交叉开发工具集（gcc+gdb）v1.1.pdf&#34;&gt;osx下搭建操作系统开发环境之32位交叉开发工具集（gcc+gdb）v1.1.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下解决emacs执行中文路径命令出错的方法</title>
      <link>http://boxcounter.com/technique/2013-08-08-osx%E4%B8%8B%E8%A7%A3%E5%86%B3emacs%E6%89%A7%E8%A1%8C%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E5%91%BD%E4%BB%A4%E5%87%BA%E9%94%99%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 12 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-08-08-osx%E4%B8%8B%E8%A7%A3%E5%86%B3emacs%E6%89%A7%E8%A1%8C%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E5%91%BD%E4%BB%A4%E5%87%BA%E9%94%99%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;我第一次发现这个问题是在使用auctex编译中文名tex文件的时候发现的，后来发现不仅仅是auctex，M－!执行shell命令中如果包含中文路径或文件名也失败，最后搜了一些资料测试了几种，发现了这个解决方案。&lt;/p&gt;

&lt;p&gt;在emacs配置文件中增加如下一行：&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;(set-language-environment &lt;span style=&#34;color: #a31515&#34;&gt;&amp;#39;utf-8&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;话说，测试了好几种方法才解决的，一高兴忘了记下出处。惭愧惭愧，谢谢那位我记不得的博主吧。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;后记2013-08-14：&lt;/p&gt;

&lt;p&gt;发现会影响vc-mode（svn1.8），导致提交中文修改纪录时报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emacs svn: E000022: Can&#39;t convert string from native encoding to &#39;UTF-8&#39;:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;暂未处理，后续处理了再补在这里。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>内核资源泄漏样本之一</title>
      <link>http://boxcounter.com/technique/2012-11-02-%E5%86%85%E6%A0%B8%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E6%A0%B7%E6%9C%AC%E4%B9%8B%E4%B8%80/</link>
      <pubDate>Fri, 02 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2012-11-02-%E5%86%85%E6%A0%B8%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E6%A0%B7%E6%9C%AC%E4%B9%8B%E4%B8%80/</guid>
      <description>

&lt;p&gt;又遇到一个很好玩的内核资源泄漏样本，分享一下。&lt;br /&gt;
某台WinXP sp3系统出现了死机现象，该现象是在安装了我的驱动后才出现的，第一反应是“MD，怎么又泄漏了”。&lt;br /&gt;
以下是分析过程：&lt;/p&gt;

&lt;h1 id=&#34;poolused的输出&#34;&gt;!poolused的输出&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; !poolused 2

Sorting by NonPaged Pool Consumed

           NonPaged                  Paged
Tag     Allocs         Used     Allocs         Used

tsni     62403     33947232          0            0 UNKNOWN pooltag &#39;tsni&#39;, please update pooltag.txt
FMvo     21652     21825376          0            0 FLT_VOLUME structure , Binary: fltmgr.sys
SBcx     10828     11780864          0            0 UNKNOWN pooltag &#39;SBcx&#39;, please update pooltag.txt
Devi     32861     10905648          0            0 Device objects 
FMis     10841      6503328          0            0 FLT_INSTANCE structure , Binary: fltmgr.sys
Drti     10844      5899136          0            0 UNKNOWN pooltag &#39;Drti&#39;, please update pooltag.txt
FMrr     21682      2425184          0            0 Per-processor Cache-aware rundown ref structure , Binary: fltmgr.sys
FMct     10841      2339864          0            0 TRACK_COMPLETION_NODES structure , Binary: fltmgr.sys
Tef2       220      2242016          0            0 UNKNOWN pooltag &#39;Tef2&#39;, please update pooltag.txt
WPSd       278      1677896          0            0 UNKNOWN pooltag &#39;WPSd&#39;, please update pooltag.txt
MmCm        30       963440          0            0 Calls made to MmAllocateContiguousMemory , Binary: nt!mm
Pp       10822       779184        287        33456 UNKNOWN pooltag &#39;Pp  &#39;, please update pooltag.txt
DmaB        34       729088          0            0 UNKNOWN pooltag &#39;DmaB&#39;, please update pooltag.txt
Io       16786       693632        156         6480 general IO allocations , Binary: nt!io
Thre      1033       661120          0            0 Thread objects , Binary: nt!ps
File      3038       465648          0            0 File objects 
FMwi     10831       433240          0            0 Work item structures , Binary: fltmgr.sys
iAEC       183       361992          0            0 UNKNOWN pooltag &#39;iAEC&#39;, please update pooltag.txt
SEY4      2970       332752          0            0 UNKNOWN pooltag &#39;SEY4&#39;, please update pooltag.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见fltmgr的卷相关资源占用特别严重（tag名以&amp;rdquo;FM&amp;rdquo;开头的几项，如&amp;rdquo;FMvo&amp;rdquo;和&amp;rdquo;FMi&amp;rdquo;等）&lt;br /&gt;
fltmgr.sys是微软的文件过滤驱动，一般可以排除由它导致资源泄漏的可能性。于是想到可能是基于fltmgr的minifilter驱动引起此故障。&lt;br /&gt;
于是继续列举系统中目前以存在的minifilter驱动。&lt;/p&gt;

&lt;h1 id=&#34;fltkd-filters的输出&#34;&gt;!fltkd.filters的输出&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; !fltkd.filters

Filter List: 8999805c &amp;quot;Frame 1&amp;quot; 
   FLT_FILTER: 897e5ba8 &amp;quot;SEyeFilter&amp;quot; &amp;quot;382020&amp;quot;
      FLT_INSTANCE: 89965510 &amp;quot;SEyeFilter - Top Instance&amp;quot; &amp;quot;382020&amp;quot;
      FLT_INSTANCE: 89964b50 &amp;quot;SEyeFilter - Top Instance&amp;quot; &amp;quot;382020&amp;quot;
   FLT_FILTER: 89e8be68 &amp;quot;SPBBCDrv&amp;quot; &amp;quot;365100&amp;quot;
      FLT_INSTANCE: 89987420 &amp;quot;SPBBCDrv&amp;quot; &amp;quot;365100&amp;quot;
      FLT_INSTANCE: 89984008 &amp;quot;SPBBCDrv&amp;quot; &amp;quot;365100&amp;quot;
   FLT_FILTER: 89e4aba8 &amp;quot;eeCtrl&amp;quot; &amp;quot;329010&amp;quot;
      FLT_INSTANCE: 89ec5c28 &amp;quot;eeCtrl&amp;quot; &amp;quot;329010&amp;quot;
      FLT_INSTANCE: 899ba008 &amp;quot;eeCtrl&amp;quot; &amp;quot;329010&amp;quot;
   FLT_FILTER: 89ab9568 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
      FLT_INSTANCE: 89981de0 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
      FLT_INSTANCE: 89982270 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
      FLT_INSTANCE: 896dd780 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
      FLT_INSTANCE: 896be9d8 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
   FLT_FILTER: 893e0e30 &amp;quot;vfsmfd&amp;quot; &amp;quot;263410&amp;quot;
      FLT_INSTANCE: 893f6008 &amp;quot;VEAI&amp;quot; &amp;quot;263400&amp;quot;
      FLT_INSTANCE: 89649008 &amp;quot;VEAI&amp;quot; &amp;quot;263400&amp;quot;
      FLT_INSTANCE: 895ee008 &amp;quot;VEAI&amp;quot; &amp;quot;263400&amp;quot;
      FLT_INSTANCE: 895f0008 &amp;quot;VEAI&amp;quot; &amp;quot;263400&amp;quot;
      FLT_INSTANCE: 893f67c0 &amp;quot;Default&amp;quot; &amp;quot;263410&amp;quot;
   FLT_FILTER: 8971bb58 &amp;quot;WavxDMgr&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 89cf58b0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 8997b400 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 896de608 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 896d7998 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 89230cf0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 87018878 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 870076a8 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 87018b30 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 870032d0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 8700e970 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 87003008 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 87003580 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 86fffdb0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 86ff02d0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      ... 省略若干重复输出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现WavxDmgr这个minifilter对卷设备进行了上万次的挂载（有上万条“FLT_INSTANCE: XXXXXXXX &amp;ldquo;WavxDMgr Instance&amp;rdquo; &amp;ldquo;145300&amp;rdquo;”），&lt;br /&gt;
因此占用了大量的Nonpaged Pool资源。有理由猜测某种操作触发了WavxDmgr的BUG，导致它疯狂的进行挂载操作，最终导致系统资源耗尽而死机。&lt;/p&gt;

&lt;p&gt;以“WavxDmgr”为关键字搜索，可以找到这么一篇文章：&lt;a href=&#34;http://www.novell.com/zh-cn/documentation/zenworks11/readme/data/readme_zenworks11sp2.html&#34;&gt;Novell ZENworks 11 SP2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中有一段相关的说明：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2.6.3 数据加密与 Tablet PC 上的 Dell ControlPoint Security Manager 不兼容&lt;br /&gt;
如果将数据加密策略应用到使用 Dell ControlPoint Security Manager 的 Tablet PC，设备将无法重引导到操作系统。&lt;br /&gt;
此问题是因 Dell ControlPoint Security Manager 驱动程序 (WavxDMgr.sys) 过渡使用文件系统堆栈所致。对于任何使用名称解析且晚于该安全管理器驱动程序装载的文件系统过滤器驱动程序，都可能会发生同样的结果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而我的驱动正好符合“使用名称解析且晚于该安全管理器驱动程序装载的文件系统过滤器驱动程序”，于是触发了WavxDmgr的资源泄漏BUG。&lt;/p&gt;

&lt;h1 id=&#34;验证&#34;&gt;验证&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; !for_each_module s -a @#Base @#End &amp;quot;tsni&amp;quot;
a7e0f300  74 73 6e 69 14 02 00 00-68 c9 54 80 50 c9 54 80  tsni....h.T.P.T.
a7e10ba3  74 73 6e 69 68 14 02 00-00 53 53 53 68 e0 f2 e0  tsnih....SSSh...

0: kd&amp;gt; lm a a7e0f300
start    end        module name
a7ddb000 a7e14180   WavxDMgr   (deferred)             

0: kd&amp;gt; lm a a7e10ba3
start    end        module name
a7ddb000 a7e14180   WavxDMgr   (deferred)             

0: kd&amp;gt; !for_each_module s -a @#Base @#End &amp;quot;SBcx&amp;quot;
a7e0e114  53 42 63 78 00 00 00 00-00 00 00 00 00 00 00 00  SBcx............

0: kd&amp;gt; lm a a7e0e114
start    end        module name
a7ddb000 a7e14180   WavxDMgr   (deferred)             

0: kd&amp;gt; !for_each_module s -a @#Base @#End &amp;quot;Drti&amp;quot;
a7dde5ad  44 72 74 69 68 18 02 00-00 6a 00 ff 15 e8 df e0  Drtih....j......

0: kd&amp;gt; lm a a7dde5ad
start    end        module name
a7ddb000 a7e14180   WavxDMgr   (deferred)             
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是这厮！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>64位系统的对齐问题</title>
      <link>http://boxcounter.com/technique/2012-10-25-64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 25 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2012-10-25-64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;今天在技术群里有位童鞋问了一个问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;On 64-bit Windows, if a data structure is misaligned, routines that manipulate the structure, such as RtlCopyMemory and memcpy, will not fault. Instead, they will raise an exception. For example:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;  &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;#&lt;/span&gt;pragma pack (1) &lt;span style=&#34;color: #008000&#34;&gt;// also set by /Zp switch &lt;/span&gt;
&amp;gt;  &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Buffer {
&amp;gt;      ULONG size;
&amp;gt;      &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *ptr;
&amp;gt;  };
&amp;gt;
&amp;gt;  &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; SetPointer(&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *p) {
&amp;gt;      &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Buffer s;
&amp;gt;      s.ptr = p;  &lt;span style=&#34;color: #008000&#34;&gt;/* will cause alignment fault */&lt;/span&gt;
&amp;gt;      ...
&amp;gt;  }
&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You could use the UNALIGNED macro to fix this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;  &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; SetPointer(&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *p) {
&amp;gt;      &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; Buffer s;
&amp;gt;      *(UNALIGNED &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; *)&amp;amp;s.ptr = p;
&amp;gt;  }
&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;/blockquote&gt;

&lt;p&gt;　　我搜了一下，这段话来自&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/windows/hardware/ff559744.aspx&#34;&gt;Porting Issues Checklist&lt;/a&gt;这篇文章。&lt;/p&gt;

&lt;p&gt;　　他的问题是：「我对这句 s.ptr = p 不太明白。为什么会引发对齐错误，什么意思？」&lt;/p&gt;

&lt;p&gt;　　我的回答（当时的原话，貌似有点凌乱，群里讨论嘛，想一句说一句，见谅）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;因为s这个结构体的首地址是被编译器默认对齐的。由于「#pragma pack (1)」，s.ptr肯定不在对齐的地址上。所以访问s.ptr时会触犯x64 win的对齐规定，于是抛出异常。&lt;/li&gt;
&lt;li&gt;对于x86架构，对于类似这种没有对齐的地址访问，win内核会自动帮你处理好，用户感觉不到这个问题的存在。但实际上会导致系统性能下降。&lt;br /&gt;
到了x64架构，win决定不帮用户擦屁股了。于是就会抛出异常。&lt;/li&gt;
&lt;li&gt;x64是按照8字节对齐，&amp;amp;s是对齐的，那s.ptr是处在 （N*8 + 4）的地址上，于是没有对齐。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　这时另一位提了一个问题：「#pragma pack (1) 了，对齐地址是按1的倍数来的，为什么会s.ptr不在对齐的地址上啊？」&lt;br /&gt;
　　我的回答：「pragma pack的对齐只是影响编译器对结构体的padding，这个俗称的对齐，跟硬件手册里的对齐，不是一回事。」&lt;/p&gt;

&lt;p&gt;　　回答完后觉得心理有点不踏实，主要的不确定点是回答3中的「x64是按照8字节对齐」。翻了下手册，果然没这么简单。&lt;br /&gt;
　　（x64架构的）cpu的对齐是根据数据类型的不同而不同的，对于第一个问题，s.ptr是个指针，确实是按照8个字节来对齐的，所以我的回答没有问题。&lt;br /&gt;
　　更具体的对齐在《AMD64 Architecture Programmer&amp;rsquo;s Manual Volume 2: System Programming》的「8.2.17  #AC—Alignment-Check Exception (Vector 17)」，如下图：&lt;br /&gt;
　　&lt;img src=&#34;http://boxcounter.com/images/2012-10-25/Data-Type-Alignment.jpg&#34;/&gt;&lt;/p&gt;

&lt;p&gt;　　还有个问题，为什么不对齐就会影响性能？&lt;br /&gt;
　　以x64位下的void* 数据类型为例，void&lt;em&gt;是8个字节大小。如果某void&lt;/em&gt; p没有按照8字节对齐，比如下图所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;addr:      N*8           (N+1)*8
           |               |
offset:     0 1 2 3 4 5 6 7
          +-+-+-+-+-+-+-+-+-+
          | |X|X|X|X|X|X|X|X|
          +-----------------+
            ^
            |
            p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　如果按照8字节对齐，即ptr处在N*8的位置，那么当需要访问ptr的时候，把ptr的值从mem读到cpu cache，只需要一次读取操作（从N*8到N*8+7，正好8个字节）。&lt;br /&gt;
　　但是如果如上图所示，那么就不得不读两次，第一次也是从N*8到(N+1)*8，第二次读取(N+1)*8到(N+1)*8+7，然后还要把第一次读的后7个字节和第二次读的第一个字节拼起来。此外，在多核环境下，为了保证对ptr的读取操作的原子性，还必须额外消耗一个bus control。另外，unaligned的ptr还有可能分布在两个cache line中，导致更多额外的处理成本（每次对ptr的修改操作会影响两个cache line，造成更严重的&lt;a href=&#34;http://software.intel.com/en-us/articles/avoiding-and-identifying-false-sharing-among-threads/&#34;&gt;False Sharing&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;　　再多想想，有人可能会问：对于WORD类型，只要求2字节对齐，那如果具体的内存是这样呢：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;addr:      N*8
           |
offset:     0 1 2 3 4 5 6 7
          +-+-+-+-+-+-+-+-+
          | | |X|X| | | | |
          +---------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这样虽然是按照2字节对齐，但是并没有在N*8的位置，会不会有性能损耗？&lt;/p&gt;

&lt;p&gt;　　理论上是有的，因为读取到cpu cache后，还有个+2的操作（理论上有，但我不确定到电路那一层，+0和+2的耗时是不是就等价了）。但即便有这个+2的操作，也没太大影响，因为对cpu cache的操作是非常非常快的，而mem-&amp;gt;cpu cache这个操作相对来说就非常耗时了。&lt;br /&gt;
　　总结：性能损耗主要是因为多了一次mem-&amp;gt;cpu cache操作。&lt;/p&gt;

&lt;p&gt;　　注：&lt;br /&gt;
　　在整理这篇文章之前，我不确定多一次读操作是不是导致性能损耗的主要原因，于是请教sinster师傅，对话如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Boxcounter 18:43:11&lt;br /&gt;
贾佳师傅，请教个问题：&lt;br /&gt;
访问unaligned的数据会造成性能下降，比如64位系统，某个void*类型的数据如果是unaligned。那么访问它时会导致2次从内存到cpu cache的读操作，而如果它是aligned，则只需要一次。&lt;br /&gt;
是因为这个原因吗？&lt;/p&gt;

&lt;p&gt;sinister 18:43:55&lt;br /&gt;
是，有些系统直接CORE DUMP了。&lt;br /&gt;
sinister 18:44:44&lt;br /&gt;
一些RISC的，POWER,SPARC,EPIC 都这样&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　后记1：&lt;br /&gt;
　　提问的童鞋说在x64 WinXP系统里，即使不对齐也没有因为异常而中断下来。&lt;br /&gt;
　　我试了下，确实如此，x64 win7系统，挂着windbg内核调试，单步步过unaligned操作，并没有任何提示和中断等异样。恢复到一个没有任何调试设置的快照，也是如此。应用层也是一样。&lt;/p&gt;

&lt;p&gt;　　继续琢磨，在AMD手册里翻到这么几段资料：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;还是在「8.2.17  #AC—Alignment-Check Exception (Vector 17)」&lt;br /&gt;
&lt;blockquote&gt;
After a processor reset, #AC exceptions are disabled. Software enables the #AC exception by setting&lt;br /&gt;
the following register bits:&lt;br /&gt;
• CR0.AM=1.&lt;br /&gt;
• RFLAGS.AC=1.&lt;br /&gt;
When the above register bits are set, an #AC can occur only when CPL=3. #AC never occurs when&lt;br /&gt;
CPL &amp;lt; 3.&lt;br /&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CR0中AM标志在第18bit，RFLAGS的AC标志也是在18bit
查看了下我的虚拟机：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; r efl
efl=00000246

0: kd&amp;gt; .formats 0x246
  ......
  Binary:  00000000 00000000 00000000 00000000 00000000 00000000 00000010 01000110
  ......


0: kd&amp;gt; r cr0
cr0=0000000080050031

0: kd&amp;gt; .formats 0x0000000080050031 
  ......
  Binary:  11111111 11111111 11111111 11111111 10000000 00000101 00000000 00110001
  ......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见两个18bit都是0，并没有启用#AC异常。
为了避免是内核调试器对虚拟系统的干扰造成的，我用livekd抓了个本机系统DMP来分析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; r cr0
cr0=0000000080050033

0: kd&amp;gt; .formats 0000000080050033
  ......
  Binary:  11111111 11111111 11111111 11111111 10000000 00000101 00000000 00110011
  ......

0: kd&amp;gt; r efl
efl=00000286

0: kd&amp;gt; .formats 00000286
  ......
  Binary:  00000000 00000000 00000000 00000000 00000000 00000000 00000010 10000110
  ......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果是一样的，也没有启用#AC异常。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　不明白为什么，难道MSDN上那篇文章里的64bit仅指IA64？&lt;br /&gt;
　　目前暂没什么好的思路，先记到这里吧。（如果有朋友知道原因，请不吝赐教。）&lt;/p&gt;

&lt;p&gt;　　后记2：&lt;br /&gt;
　　发现一篇相关的文章：&lt;a href=&#34;http://stackoverflow.com/questions/5498102/how-to-debug-unaligned-accesses-on-amd64-using-visual-studio&#34;&gt;How to debug unaligned accesses on amd64 using Visual Studio?&lt;/a&gt;&lt;br /&gt;
　　其中有一条回复是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;How do real world Windows developers track unaligned accesses in their code?&amp;rdquo;. Being a primarily Windows developer myself, I think they just never do it, unless the code has to run on Itanium. And if it has to run on Itanium, the exception will tell the places. What is the real overhead of unaligned access on x86? BTW, you can still use assembly on x64, in .asm files, just not inline assembly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　后记3（2013-01-06）：&lt;br /&gt;
　　群里的朋友分享了新资料：&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms177389.aspx&#34;&gt;__unaligned&lt;/a&gt;，里面有这么一段话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The __unaligned modifier is valid for the x64 and Itanium compilers but affects only applications that target an IPF computer. This modifier describes the alignment of the addressed data only; the pointer itself is assumed to be aligned.&lt;br /&gt;
The Itanium processor generates an alignment fault when it accesses misaligned data, and the time to process the fault weakens performance. Use the __unaligned modifier to cause the processor to read data one byte at a time and avoid the fault. This modifier is not required for x64 applications because the x64 processor handles misaligned data without faulting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　也就是说，确实只有在IA64环境才会凸显出来。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>