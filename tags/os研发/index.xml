<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Os研发 on Boxcounter的烂笔头</title>
    <link>http://boxcounter.com/tags/os%E7%A0%94%E5%8F%91/index.xml</link>
    <description>Recent content in Os研发 on Boxcounter的烂笔头</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="http://boxcounter.com/tags/os%E7%A0%94%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>linux、osx下搭建操作系统开发环境 v1.1</title>
      <link>http://boxcounter.com/technique/2013-11-14-linux%E3%80%81osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83_v1.1/</link>
      <pubDate>Thu, 14 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-11-14-linux%E3%80%81osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83_v1.1/</guid>
      <description>

&lt;h1 id=&#34;一-前言&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　本文档记录的内容既适用于x86也适用于x64，只是对于后者有一些环境要求。&lt;br /&gt;
　　之前开发使用的方法是：自己的引导代码+虚拟软盘。优点是搭建简单，所有代码都是自己编写，可控性强。最近想试试使用grub的引导功能，于是花了些时间琢磨。搜出来的相​关资料有不少，但是要么是grub1的，要么太过零散，要么描述太过简略。总之，没有一篇文章详细的讲述整个配置过程。所以我就在搭建的过程中顺手整理了这么一篇完整的、​完全从零开始的方法，其中每一步都有较丰富的说明。&lt;br /&gt;
　　另外，本文档介绍的方法适用于osx和linux，实际上整个过程中大部分必须使用到linux。也就是说如果要按照本文档来搭建开发环境，linuxer只需要使用自己​的linux系统就行，而osxer还得备一套linux系统（比如虚拟机）。使用linux的主要原因是我选择了ext2作为文件系统，而osx上貌似只有读写ext2​的fuse-ext2，没有用于创建ext2分区的fdisk等工具（如果同好有osx的ext2创建工具推荐，劳烦分享给我(ns.boxcounter[at]gmail.com)吧，不胜感激）。如果改用fat32就没有这个烦恼，整个过程都可以在osx下完成，因为osx的fdisk就可以创建fat32分区。&lt;/p&gt;

&lt;p&gt;　　我使用的系统、软件情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;x86 ubuntu 12.04.2/x64 ubuntu 13.10、osx 10.8.4/osx 10.9&lt;/li&gt;
&lt;li&gt;nasm 2.10.09&lt;/li&gt;
&lt;li&gt;bochs 2.6.1&lt;/li&gt;
&lt;li&gt;grub2 2.0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　如果同好使用的环境不一样，可能需要根据情况自行调整一些细节。&lt;br /&gt;
　　另外，本文提供的命令在显示时候可能会自动折行，所以复制到剪贴板中之后（在折行处）可能会有多余的空格，请同好自行删减。&lt;/p&gt;

&lt;h1 id=&#34;二-创建虚拟磁盘-并分区&#34;&gt;二、创建虚拟磁盘，并分区&lt;/h1&gt;

&lt;p&gt;　　首先说明：&lt;br /&gt;
　　这里的目标磁盘的属性是：16 headers, 63 sectors per track, 512 bytes per sector。意味着每一个cylinder的大小是516096bytes（16 * 63 * 512）。&lt;br /&gt;
　　“#cylinders”表示柱面数，主要关系到磁盘大小。如果是10MB的磁盘，#cylinders=20。&lt;br /&gt;
　　需要在linux系统中进行，使用的工具是kpartx，系统默认没有自带，需要下载。&lt;/p&gt;

&lt;p&gt;　　好了，开始了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;dd if=/dev/zero of=antos.img bs=516096 count=#cylinders&lt;br /&gt;
创建虚拟磁盘。也可以使用bochs附带的bximage工具来完成。&lt;/li&gt;
&lt;li&gt;ps aux | grep loop&lt;br /&gt;
默认是搜索不到名为“[loopX]”进程的。如果有发现，那记住输出中的“[loopX]”进程。&lt;/li&gt;
&lt;li&gt;kpartx -av ./antos.img&lt;br /&gt;
挂载虚拟磁盘，可能没有输出。&lt;/li&gt;
&lt;li&gt;ps aux | grep loop&lt;br /&gt;
正常情况下，这里会发现一个名为“[loop0]”的进程。说明antos.img被挂载到了“/dev/loop0”设备上。如果前面搜索结果中已经有了“[loopX]”进程，那新增加的那个进程就是挂载的设备名。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fdisk -u -C#cylinders -S63 -H16 /dev/loop0&lt;br /&gt;
为磁盘分区。以#cylinders=20、单个分区为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# fdisk -u -C20 -S63 -H16 /dev/loop0
Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel
Building a new DOS disklabel with disk identifier 0x136d49ee.
Changes will remain in memory only, until you decide to write them.
After that, of course, the previous content won&#39;t be recoverable.

Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)

Command (m for help): o &amp;lt;&amp;lt;&amp;lt;=== Create a new empty DOS partition table
Building a new DOS disklabel with disk identifier 0x5bd665d5.
Changes will remain in memory only, until you decide to write them.
After that, of course, the previous content won&#39;t be recoverable.

Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)

Command (m for help): n &amp;lt;&amp;lt;&amp;lt;=== Create a new partition
Partition type:
p   primary (0 primary, 0 extended, 4 free)
e   extended
Select (default p): &amp;lt;&amp;lt;&amp;lt;=== 回车
Partition number (1-4, default 1): &amp;lt;&amp;lt;&amp;lt;=== 回车
First sector (2048-20159, default 2048): &amp;lt;&amp;lt;&amp;lt;=== 回车
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-20159, default 20159): &amp;lt;&amp;lt;&amp;lt;=== 回车
Using default value 20159

Command (m for help): a &amp;lt;&amp;lt;&amp;lt;=== Toggle the bootable flag (Optional)
Partition number (1-4): 1 &amp;lt;&amp;lt;&amp;lt;=== 分区1

Command (m for help): p &amp;lt;&amp;lt;&amp;lt;=== Print the partition table.

Disk /dev/loop0: 10 MB, 10321920 bytes
16 heads, 63 sectors/track, 20 cylinders, total 20160 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x5bd665d5

Device Boot      Start         End      Blocks   Id  System
/dev/loop0p1   *        2048       20159        9056   83  Linux
&amp;lt;&amp;lt;&amp;lt;=== 如果使用附录2记录的方法，需要记录Start和Blocks的值，本例子中分别是2048和9056。

Command (m for help): w &amp;lt;&amp;lt;&amp;lt;=== Write partition table to our &#39;disk&#39; and exit
The partition table has been altered!

Calling ioctl() to re-read partition table.

WARNING: Re-reading the partition table failed with error 22: Invalid argument.
The kernel still uses the old table. The new table will be used at
the next reboot or after you run partprobe(8) or kpartx(8)
Syncing disks.
&amp;lt;&amp;lt;&amp;lt;=== Ignore any errors about rereading the partition table. Since it&#39;s not a physical device we really don&#39;t care.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kpartx -dv ./antos.img&lt;br /&gt;
卸载磁盘，应该输出“loop deleted : /dev/loop0”。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kpartx -av ./antos.img&lt;br /&gt;
挂载分区磁盘，这次新创建的分区也会自动挂载。&lt;br /&gt;
正常会输出“add map loop0p1 (252:0): 0 18112 linear /dev/loop0 2048”，表示分区挂载到了“/dev/mapper/loop0p1”设备上。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mke2fs -b1024 /dev/mapper/loop0p1&lt;br /&gt;
格式化分区，&amp;rdquo;-b1024&amp;rdquo;表示使用1KB的block。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mkdir /tmp/antos&lt;br /&gt;
创建挂载目录。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mount -text2 /dev/mapper/loop0p1 /tmp/antos&lt;br /&gt;
挂载分区到目录。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ls /tmp/antos/&lt;br /&gt;
如果前面的步骤都成功，会看到名为“lost+found”的目录，说明磁盘和分区都正确的创建了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;三-安装grub2到虚拟磁盘&#34;&gt;三、安装grub2到虚拟磁盘&lt;/h1&gt;

&lt;p&gt;　　假设磁盘挂载到设备“/dev/loop0”上，分区挂载到“/tmp/antos”目录下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grub-install --no-floppy --modules=&amp;quot;biosdisk part_msdos ext2 configfile normal multiboot&amp;quot; --root-directory=/tmp/antos /dev/loop0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　安装过程中可能会报警告，只要最后输出“Installation finished. No error reported.”就表示安装成功了。&lt;br /&gt;
　　如果使用的系统是x64架构的，需要使用新一些的系统，比如ubuntu 13.10。具体原因请参考附录一。&lt;br /&gt;
　　（在fedora等redhat系中使用的名称是“grub2-install”）&lt;/p&gt;

&lt;h1 id=&#34;四-在bochs中使用虚拟磁盘&#34;&gt;四、在bochs中使用虚拟磁盘&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;确认虚拟磁盘的属性。&lt;br /&gt;
先挂载虚拟磁盘，然后执行“disk -u -l /dev/loop0”，正常会有如下输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 Disk /dev/loop0: 10 MB, 10321920 bytes
2 16 heads, 63 sectors/track, 20 cylinders, total 20160 sectors
3 Units = sectors of 1 * 512 = 512 bytes
4 Sector size (logical/physical): 512 bytes / 512 bytes
5 I/O size (minimum/optimal): 512 bytes / 512 bytes
6 Disk identifier: 0x6418cb2e
7
8       Device Boot      Start         End      Blocks   Id  System
9 /dev/loop0p1   *        2048       20159        9056   83  Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第2行说明了虚拟磁盘的属性。（前面使用fdisk为磁盘分区的时候也有输出同样的内容，如果记下来了，就可以不需要这一步）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建bochs虚拟机配置文件&lt;br /&gt;
不带参数运行bochs，应该会有这样的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. Restore factory default configuration
2. Read options from...
3. Edit options
4. Save options to...
5. Restore the Bochs state from...
6. Begin simulation
7. Quit now

Please choose one: [2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选择4，然后输入配置文件名，比如“antos.bxrc”，提示保存成功后退出bochs。这样就有了一份默认配置的bochs虚拟机配置文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改bochs虚拟机配置文件，以适应我们的需要&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加虚拟磁盘。&lt;br /&gt;
将这一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ata0-master: type=none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ata0-master: type=disk, path=&amp;quot;./antos.img&amp;quot;, cylinders=#cylinders,heads=#heads,spt=#sec-per-track
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应之前获取到的磁盘属性，这一行应该是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ata0-master: type=disk, path=&amp;quot;./antos.img&amp;quot;, cylinders=20,heads=16,spt=63
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改启动项为磁盘。&lt;br /&gt;
将这一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boot: floppy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boot: disk
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开启bochs的magic breakpoint。&lt;br /&gt;
将这一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;magic_break: enabled=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;magic_break: enabled=1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　到这里，就可以在bochs中运行了（命令是“bochs -f antos.bxrc”），并且看到grub2的命令提示符，如图：&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://boxcounter.com/images/2013-11-14/grub-cmdline.png&#34;/&gt;&lt;/p&gt;

&lt;h1 id=&#34;五-编写最简单的系统内核&#34;&gt;五、编写最简单的系统内核&lt;/h1&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;//&lt;/span&gt; kernel.asm&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;源码&lt;/span&gt;
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;section&lt;/span&gt; .kernel]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;bits&lt;/span&gt; 32]

load_base&lt;span style=&#34;color: #0000ff&#34;&gt; equ&lt;/span&gt; 0x100000

&lt;span style=&#34;color: #008000&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color: #008000&#34;&gt;; multiboot header&lt;/span&gt;
&lt;span style=&#34;color: #008000&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
multiboot_header:
MBH_magic&lt;span style=&#34;color: #0000ff&#34;&gt;            equ&lt;/span&gt; 0xE85250D6
MBH_architecture&lt;span style=&#34;color: #0000ff&#34;&gt;     equ&lt;/span&gt; 0            &lt;span style=&#34;color: #008000&#34;&gt;; 32-bit protected mode&lt;/span&gt;
MBH_header_length&lt;span style=&#34;color: #0000ff&#34;&gt;    equ&lt;/span&gt; multiboot_header_end - multiboot_header
MBH_checksum&lt;span style=&#34;color: #0000ff&#34;&gt;         equ&lt;/span&gt; -(MBH_header_length + MBH_magic + MBH_architecture)

&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_magic
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_architecture
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_header_length
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_checksum

&lt;span style=&#34;color: #008000&#34;&gt;; tags&lt;/span&gt;
info_request_tag:
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 1
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; info_request_tag_end - info_request_tag
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 5
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 6
info_request_tag_end:
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
address_tag:
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 2
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; address_tag_end - address_tag
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; load_base                 &lt;span style=&#34;color: #008000&#34;&gt;; header_addr&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; load_base                 &lt;span style=&#34;color: #008000&#34;&gt;; load_addr&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 0                         &lt;span style=&#34;color: #008000&#34;&gt;; load_end_addr&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 0                         &lt;span style=&#34;color: #008000&#34;&gt;; bss_end_addr&lt;/span&gt;
address_tag_end:
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
entry_address_tag:
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 3
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; entry_address_tag_end - entry_address_tag
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; load_base + kernel_entry
entry_address_tag_end:
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
&lt;span style=&#34;color: #008000&#34;&gt;; end tag&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 8
multiboot_header_end:

kernel_entry:
xchg bx, bx                 &lt;span style=&#34;color: #008000&#34;&gt;; magic breakpoint&lt;/span&gt;
jmp &lt;span style=&#34;color: #0000ff&#34;&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;br /&gt;
　　编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nasm kernel.asm -o kernel.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　编译过程中可能会报警告，无视它。&lt;br /&gt;
　　将虚拟磁盘挂载到某个目录，然后将kernel.bin拷贝到分区的根目录，即和/boot目录同一层目录。&lt;/p&gt;

&lt;h1 id=&#34;六-使用grub2启动自行编写的操作系统内核&#34;&gt;六、使用grub2启动自行编写的操作系统内核&lt;/h1&gt;

&lt;p&gt;　　假设分区挂载到“/tmp/antos”目录下，那么创建grub需要的配置文件“/tmp/antos/boot/grub/grub.cfg”，将以下几行文本贴进去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set default=0
insmod ext2
set root=(hd0,1)
set timeout=10
menuentry &amp;quot;antos 0.0.1&amp;quot; {
   insmod ext2
   set root=(hd0,1)
   multiboot2 (hd0,1)/kernel.bin
   boot
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　其中(hd0,1)表示咱之前创建的虚拟磁盘的第一个分区，kernel.bin就是前面编译的系统内核文件。&lt;/p&gt;

&lt;p&gt;　　现在可以启动咱的bochs虚拟机了，执行“bochs -f antos.bxrc”。&lt;br /&gt;
　　再输入c继续执行后，应该就能看到bochs从咱的虚拟磁盘引导，然后可以看见grub的选择界面，最后会中断到咱系统内核的“xchg bx, bx”指令，这是bochs内置的主动中断指令，即magic breakpoint机制。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o 00449811185i[CPU0 ] [449811185] Stopped on MAGIC BREAKPOINT
(0) Magic breakpoint
Next at t=449811185
(0) [0x000000100053] 0010:0000000000100053 (unk. ctxt): jmp .-2 (0x00100053) ; ebfe
00449811185i[XGUI ] Mouse capture off
&amp;lt;bochs:2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　ok，整个配置过程就完毕了，整个过程都是在linux中完成的。使用fat32的osx同好可以使用类似的方法来完成。整个过程每一步的功能都写的很清楚了，看到这里理​理思路应该就明白整个流程了。&lt;/p&gt;

&lt;h1 id=&#34;七-osx中读写ext2文件系统的虚拟磁盘&#34;&gt;七、osx中读写ext2文件系统的虚拟磁盘&lt;/h1&gt;

&lt;p&gt;　　最后说说osx相关的内容，因为我不想每次做开发的时候都需要开个linux虚拟机。以下是在osx下读写虚拟磁盘的方法，比如更新的kernel.bin等等。linu​xer可以无视这一步。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装osxfuse和fuse-ext2&lt;br /&gt;
fuse-ext2默认只能以只读方式挂载设备，所以需要进行以下修改使其默认以可读可写方式挂载设备：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo vi /System/Library/Filesystems/fuse-ext2.fs/fuse-ext2.util
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搜索定位到Mount函数，为其名为“OPTIONS”的变量增加额外的“rw+”选项。&lt;br /&gt;
比如：原内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mount ()
{
      LogDebug &amp;quot;[Mount] Entering function Mount...&amp;quot;
      # Setting both defer_auth and defer_permissions. The option was renamed
      # starting with MacFUSE 1.0.0, and there seems to be no backward
      # compatibility on the options.
      OPTIONS=&amp;quot;auto_xattr,defer_permissions&amp;quot;
      ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mount ()
{
      LogDebug &amp;quot;[Mount] Entering function Mount...&amp;quot;
      # Setting both defer_auth and defer_permissions. The option was renamed
      # starting with MacFUSE 1.0.0, and there seems to be no backward
      # compatibility on the options.
      OPTIONS=&amp;quot;auto_xattr,defer_permissions,rw+&amp;quot;
      ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;挂载磁盘到设备&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hdiutil attach -nomount antos.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是会输出如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dev/disk1              FDisk_partition_scheme
/dev/disk1s1            Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明虚拟磁盘已经挂载到/dev/disk1设备上了，分区已经挂载到/dev/disk1s1。（之所以加上-nomount参数，是因为hdiutil没法正确地挂载ext2分区到目录）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;挂载分区到目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sbin/mount_fuse-ext2 /dev/disk1s1 ./mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/dev/disk1s1是步骤3中得到的设备（分区)名。&lt;br /&gt;
到这里，就可以对分区内容进行修改了，比如更新kernel.bin等等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从目录卸载分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;umount ./mnt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;卸载虚拟磁盘&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hdiutil detach /dev/disk1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（注意是磁盘设备，不是分区设备disk1s1）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;八-附录一-x64-ubuntu-12-04-2中执行grub-install遇到的问题&#34;&gt;八、附录一：x64 ubuntu 12.04.2中执行grub-install遇到的问题&lt;/h1&gt;

&lt;p&gt;　　我在x64 ubuntu 12.04.2中执行“安装grub2到虚拟磁盘”操作时总是失败，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@x64:~# grub-install --no-floppy --modules=&amp;quot;biosdisk part_msdos ext2 configfile normal multiboot&amp;quot; --root-directory=/tmp/antos /dev/loop0
Path `/tmp/antos/boot/grub&#39; is not readable by GRUB on boot. Installation is impossible. Aborting.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　加上&amp;ndash;deubg选项后，发现grub-install输出了这么几行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ /usr/local/sbin/grub-probe -t fs /tmp/antos/boot/grub
+ return 1
+ gettext_printf Path `%s&#39; is not readable by GRUB on boot. Installation is impossible. Aborting.\n /tmp/antos/boot/grub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　手动执行grub-probe，输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# /usr/local/sbin/grub-probe -t fs /tmp/antos/boot/grub/usr/local/sbin/grub-probe: error: disk `lvm/loop0p1&#39; not found.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我查阅了很多资料，都没有明确的解决方案。经过了约莫20个小时的摸索，最终发现只需要使用新版本的系统自带的grub 2.0.0即可。（注：x64 ubuntu 12.04.2中的grub2是我源码编译的2.0.0版，也尝试过使用trunk源码编译或者使用系统自带的1.99，都会报错。）&lt;/p&gt;

&lt;h1 id=&#34;九-附录二-创建虚拟磁盘分区的另外一种方法-losetup&#34;&gt;九、附录二：创建虚拟磁盘分区的另外一种方法（losetup）&lt;/h1&gt;

&lt;p&gt;　　需要说明，这种方法较前面介绍的使用kpartx的方法要繁琐，所以并不推荐（特别是如果要使用多分区）。补充在这里的原因是我最开始搜索到的资料使用的就是losetu​p工具，摸索成功之后才发现kpartx。&lt;br /&gt;
　　另外，操作过程中有部分步骤和前面讲述的步骤一样，所以省略了那些步骤的说明。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;dd if=/dev/zero of=antos.img bs=516096 count=#cylinders&lt;/li&gt;
&lt;li&gt;losetup /dev/loop0 ./antos.img&lt;br /&gt;
这个时候执行“ps aux | grep loop”，会看到一个名为[loop0]的进程。（如果loop0被占用，可以换一个设备）&lt;/li&gt;
&lt;li&gt;fdisk -u -C#cylinders -S63 -H16 /dev/loop0&lt;/li&gt;
&lt;li&gt;losetup /dev/loop0 ./antos.img&lt;br /&gt;
这个时候执行“ps aux | grep loop”，会看到一个名为[loop0]的进程。（如果loop0被占用，可以换一个设备）&lt;/li&gt;
&lt;li&gt;losetup -d /dev/loop0&lt;br /&gt;
到这里，虚拟磁盘已经创建完毕了，从设备（“loop0”）上卸载虚拟磁盘，准备格式化。&lt;/li&gt;
&lt;li&gt;losetup -o1048576 /dev/loop0 ./antos.img&lt;br /&gt;
再次挂载，与前面挂载不同的是，这次使用了“-o1048576”参数，目的是跳过前1048576字节，来到分区的开始。前面提到要记住Start的值，即分区开始扇区号，这里就需要使用它了，1048576=20​48*512。&lt;/li&gt;
&lt;li&gt;mke2fs -b1024 /dev/loop0 9056&lt;br /&gt;
对加载到“loop0”设备上的*分区*（注意是分区，不是整个磁盘了，前面咱跳到了分区开始处）进行格式化，使用的是ext2文件系统。&lt;br /&gt;
”-b1024“表示使用1KB的block，9056就是之前的Blocks的值，即整个分区的blocks数。&lt;/li&gt;
&lt;li&gt;mkdir /tmp/antos&lt;/li&gt;
&lt;li&gt;mount -text2 /dev/loop0 /tmp/antos&lt;/li&gt;
&lt;li&gt;umount /dev/loop0&lt;/li&gt;
&lt;li&gt;losetup -d /dev/loop0&lt;br /&gt;
卸载目录和设备。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;十-主要参考资料&#34;&gt;十、主要参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The Multiboot Specification&lt;/li&gt;
&lt;li&gt;grub2源码&lt;/li&gt;
&lt;li&gt;Mac OS X下读写ext2/ext3文件系统&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;十一-版本记录&#34;&gt;十一、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-09-02，初始发布。&lt;/li&gt;
&lt;li&gt;v1.1 - 2013-11-14，增加x64系统下的说明。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-11-14/linux、osx下搭建操作系统开发环境的完整步骤_v1.1.pdf&#34;&gt;2013-11-14-linux、osx下搭建操作系统开发环境_v1.1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下搭建操作系统开发环境之64位交叉开发工具集（gcc&#43;gdb）v1.0</title>
      <link>http://boxcounter.com/technique/2013-11-08-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B64%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.0/</link>
      <pubDate>Fri, 08 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-11-08-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B64%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.0/</guid>
      <description>

&lt;h1 id=&#34;一-前言&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　《&lt;a href=&#34;http://boxcounter.com/2013/11/04/osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B32%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc+gdb%EF%BC%89v1.1&#34;&gt;osx下搭建操作系统开发环境之32位交叉开发工具集(gcc+gdb)&lt;/a&gt;》一文中讲解了32位交叉工具的构建。64位（专指x64，非IA64）的构建方法和32位基本相同。看过前文的朋友看本文会发现绝大多数内容都是一样的。没错，之所以不基于前文、只讲差异，是为了独立性，方便只关注x64构建方法的朋友。&lt;br /&gt;
　　我的环境：osx 10.9&lt;/p&gt;

&lt;h1 id=&#34;二-安装osx版的gcc&#34;&gt;二、安装osx版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;brew install gcc48
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　推荐下载最新的稳定版gcc。&lt;/p&gt;

&lt;h1 id=&#34;三-配置编译环境&#34;&gt;三、配置编译环境&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;下载gcc源码&lt;br /&gt;
根据参考资料1的建议，最好使用最新的gcc来进行编译，被编译的源码也推荐使用一样版本的。也就是说，用gcc 4.8.2来编译gcc 4.8.2的源码。&lt;br /&gt;
下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gcc&#34;&gt;源码包&lt;/a&gt;并解压，得到的目录名称之为“$gcc-4.8.2”。&lt;/li&gt;
&lt;li&gt;下载gcc依赖项&lt;br /&gt;
需要的依赖项有：

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gnu.org/software/binutils/&#34;&gt;GNU Binutils&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gmplib.org/&#34;&gt;GMP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mpfr.org/&#34;&gt;MPFR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://multiprecision.org/&#34;&gt;MPC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将它们都解压出来，把解压出来的b、c、d的目录都放到gcc源码目录下。都需要去掉版本号，比如解压出来的目录名为“mpc-1.0.1”，那么现在就是“$gcc-4.8.2/mpc”。a无需这么做，因为它需要单独编译，参考后续的步骤4。&lt;br /&gt;
   其中GMP源码包是lzip压缩格式，需要下载lzip工具解压（brew安装）。
3. 下载gdb源码&lt;br /&gt;
   下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gdb&#34;&gt;源码包&lt;/a&gt;并解压，得到的目录名称之为“$gdb-7.6.1”。
4. 设置环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export CC=/usr/local/bin/gcc-4.8
    export CXX=/usr/local/bin/g++-4.8
    export CPP=/usr/local/bin/cpp-4.8
    export LD=/usr/local/bin/gcc-4.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都是brew版gcc4.8.2的软链接。如果不设置，那么会使用系统中默认自带的工具，这些工具的版本可能比较老。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export PREFIX=$HOME/opt/cross
    export TARGET=x86_64-pc-linux-gnu
    export PATH=&amp;quot;$PREFIX/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是编译时候使用的选项。需要注意的是：osdev上的《&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler_for_x86_64&#34;&gt;GCC Cross-Compiler for x86 64&lt;/a&gt;》建议将TARGET宏定义为x86_64-elf，但是我实验发现这样行不通，编译gdb的时候会报错“configure: error: configuration x86_64-pc-elf is unsupported.”。
5. 编译交叉版的binutils&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    cd $binutils-x.y.z
    mkdir build-binutils
    cd build-binutils
    ../configure --target=$TARGET --prefix=$PREFIX --enable-64-bit-bfd --enable-werror=no
    make
    make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;四-编译交叉版的gcc&#34;&gt;四、编译交叉版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gcc-4.8.2
mkdir build-gcc
cd build-gcc
../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls --enable-languages=c,c++ --without-headers
make all-gcc
make all-target-libgcc
make install-gcc
make install-target-libgcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后，在“~/opt/cross/bin”下就能看到编译好的交叉版的编译套件了，包括“x86_64-pc-linux-gnu-gcc”、“x86_64-pc-linux-gnu-g++”和“x86_64-pc-linux-gnu-ld ”等等。可以用“$HOME/opt/cross/bin/$TARGET-gcc &amp;ndash;version”来验证一下版本是否正确。&lt;br /&gt;
　　另外，为了方便使用，可以在.bashrc或者.zshrc中调整环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=&amp;quot;$HOME/opt/cross/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;五-编译交叉版的gdb&#34;&gt;五、编译交叉版的gdb&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gdb-7.6.1
mkdir build-$TARGET
cd build-$TARGET
../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls --enable-64-bit-bfd --enable-werror=no CFLAGS=&amp;quot;-m64&amp;quot;
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后，在“~/opt/cross/bin”下就能看到编译好的交叉版的x86_64-pc-linux-gnu-gdb了。&lt;/p&gt;

&lt;p&gt;　　注：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;和x64的bochs配合调试的时候，需要切换到x86-64模式（默认模式是i386）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) set architecture i386:x86-64
The target architecture is assumed to be i386:x86-64
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在这个编译选项版本之前，我尝试了好几种其他的编译选项，虽然都能编译出gdb，但是都无法与x64的bochs进行配合调试。包括使用“../configure &amp;ndash;enable-targets=all &amp;ndash;enable-64-bit-bfd”。无法与x64的bochs进行配合调试的现象是，gdb能够下断，但是中断点都是错误的，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) target remote localhost:1234
Remote debugging using 192.168.1.16:1234
0x00000000 in ?? ()
(gdb) b *0x7c00
Breakpoint 1 at 0x7c00
(gdb) c
Continuing.
Program received signal SIGTRAP, Trace/breakpoint trap.
0x000e0000 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常应该是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) target remote 192.168.1.16:1234
Remote debugging using localhost:1234
0x000000000000fff0 in ?? ()
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结，gdb的TARGET要和bochs（而非被调试OS）的平台一致，即如果使用的是x64的bochs，那么gdb的编译TARGET也需要是x64的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;六-参考资料&#34;&gt;六、参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler&#34;&gt;GCC Cross-Compiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler_for_x86_64&#34;&gt;GCC Cross-Compiler for x86 64&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.utah.edu/~manua/sim_doc/simics-reference-manual-public-all/topic96.html&#34;&gt;gdb-remote&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sourceforge.net/p/bochs/discussion/39592/thread/a489c7f1&#34;&gt;bochs + GDB help&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;七-版本记录&#34;&gt;七、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-11-08，初始发布。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-11-08/osx下搭建操作系统开发环境之64位交叉开发工具集（gcc+gdb）v1.0.pdf&#34;&gt;osx下搭建操作系统开发环境之64位交叉开发工具集（gcc+gdb）v1.0.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下搭建操作系统开发环境之构建bochs v1.0</title>
      <link>http://boxcounter.com/technique/2013-11-05-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B%E6%9E%84%E5%BB%BAbochs_v1.0/</link>
      <pubDate>Tue, 05 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-11-05-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B%E6%9E%84%E5%BB%BAbochs_v1.0/</guid>
      <description>

&lt;h1 id=&#34;一-前言&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　我编译bochs的目的是为了启用gdb调试功能。bochs提供的调试器功能较简单，开发过程中还是gdb更趁手。本文记录的方法是我一点点尝试出来的，参考了网上一些零碎资料。整个过程虽然简单但是整体比较凌乱，特别是需要对bochs的官方源码包做好几处修改。目前不太想再花时间优化过程，能编译出来就好。如果有同好有更简单的方法，有劳和我分享一下吧。&lt;br /&gt;
　　我的环境：osx 10.9，bochs 2.6.2、使用x11作为界面库。&lt;/p&gt;

&lt;h1 id=&#34;二-安装x11&#34;&gt;二、安装X11&lt;/h1&gt;

&lt;p&gt;　　下载&lt;a href=&#34;http://xquartz.macosforge.org/trac&#34;&gt;XQuartz&lt;/a&gt;安装包，并安装。&lt;/p&gt;

&lt;h1 id=&#34;三-配置编译环境&#34;&gt;三、配置编译环境&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;export CC=/usr/bin/gcc
export CXX=/usr/bin/g++
export CPP=/usr/bin/cpp
export LD=/usr/bin/g++
export CFLAGS=-I/usr/X11/include
export PREFIX=/Users/boxcounter/opt/bochs-gdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　根据我的试验，使用brew安装的gcc编译会报错，使用系统自带的就可以正常编译，所以调整了CC等环境变量。PREFIX宏请根据需要自行修改。&lt;/p&gt;

&lt;h1 id=&#34;四-编译bochs&#34;&gt;四、编译bochs&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;下载&lt;a href=&#34;http://sourceforge.net/projects/bochs/files/bochs/&#34;&gt;源码包&lt;/a&gt;并解压，解压出来的目录名称之为“$bochs”。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改.conf.macosx&lt;br /&gt;
根据需要修改configure的参数，比如以下是我使用的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --enable-disasm \
            --disable-docbook \
            --enable-x86-64 \
            --enable-pci \
            --enable-all-optimizations \
            --enable-plugins \
            --enable-cdrom \
            --enable-a20-pin \
            --enable-fpu \
            --enable-alignment-check \
            --enable-large-ramfile \
            --enable-readline \
            --enable-iodebug \
            --enable-xpm \
            --enable-show-ips \
            --enable-logging \
            --enable-usb \
            --enable-ne2000 \
            --enable-cpu-level=6 \
            --enable-sb16 \
            --enable-clgd54xx \
            --with-term \
            --enable-ne2000 \
            --with-x11 \
            --enable-idle-hack \
            --enable-gdb-stub \
            --prefix=${PREFIX} \
            ${CONFIGURE_ARGS}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;chmod u+x ./.conf.macosx &amp;amp;&amp;amp; ./.conf.macosx&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改ldtl相关选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将$bochs/config.h中的“BX_HAVE_LTDL”宏的定义由1改为0，只有一处。&lt;/li&gt;
&lt;li&gt;将$bochs/Makefile中的“-lltdl”改为“ltdl.o”，有多处。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调整gui模块的编译选项&lt;br /&gt;
将$bochs/gui/Makefile中的“X_LIBS =  -lXpm -lXrandr”修改为“X_LIBS = -L/usr/X11/lib -lXpm -lXrandr”&lt;br /&gt;
如果不进行此项修改，在gui目录下进行链接的时候总会报错，提示无法找到Xmp库。使用LDFLAGS环境变量或者修改.conf.macosx中的LDFLAGS都没有用，因为gui模块链接过程中并没有使用到它们。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make &amp;amp;&amp;amp; make install&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;五-参考资料&#34;&gt;五、参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sourceforge.net/p/bochs/discussion/39592/thread/9c22887c&#34;&gt;No rule to make target `-lltdl&amp;rsquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;六-版本记录&#34;&gt;六、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-11-05，初始发布。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-11-05/osx下搭建操作系统开发环境之构建bochs_v1.0.pdf&#34;&gt;osx下搭建操作系统开发环境之构建bochs_v1.0.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下搭建操作系统开发环境之32位交叉开发工具集（gcc&#43;gdb）v1.1</title>
      <link>http://boxcounter.com/technique/2013-09-07-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B32%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.1/</link>
      <pubDate>Mon, 04 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-09-07-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B32%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.1/</guid>
      <description>

&lt;h1 id=&#34;一-前言&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　《&lt;a href=&#34;http://boxcounter.com/2013/11/14/linux%E3%80%81osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83_v1.1&#34;&gt;linux、osx下搭建操作系统开发环境的完整步骤&lt;/a&gt;》一文中讲解了一些基本的搭建方法，并提供了一个nasm汇编编写的简单的系统内核源码。实际开发过程中更多使用的是C语言，就需要有一个配套的C编译器。因为我使用的可执行文件是elf格式，所以我选择的是GCC。但是osx下安装的GCC生成的是osx的可执行文件格式，并不是elf。所以我需要一个能在osx下生成elf的GCC，俗称的交叉编译器。&lt;br /&gt;
　　我的环境：osx 10.8.4 &amp;amp; 10.9&lt;/p&gt;

&lt;h1 id=&#34;二-安装osx版的gcc&#34;&gt;二、安装osx版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;brew install gcc48
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　推荐下载最新的稳定版gcc。&lt;/p&gt;

&lt;h1 id=&#34;三-配置编译环境&#34;&gt;三、配置编译环境&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;下载gcc源码&lt;br /&gt;
根据&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler&#34; title=&#34;「GCC Cross-Compiler」&#34;&gt;参考资料1&lt;/a&gt;的建议，最好使用最新的gcc来进行编译，被编译的源码也推荐使用一样版本的。也就是说，用gcc 4.8.1来编译gcc 4.8.1的源码。&lt;br /&gt;
下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gcc/&#34;&gt;源码包&lt;/a&gt;并解压，得到的目录名称之为「$gcc-4.8.1」。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载依赖项&lt;br /&gt;
需要的依赖项有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://gnu.org/software/binutils/&#34;&gt;GNU Binutils&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gmplib.org/&#34;&gt;GMP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mpfr.org/&#34;&gt;MPFR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://multiprecision.org/&#34;&gt;MPC&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将它们都解压出来，把解压出来的2、3、4的目录都放到gcc源码目录下。都需要去掉版本号，比如解压出来的目录名为「mpc-1.0.1」，那么现在就是「$gcc-4.8.1/mpc」。1无需这么做，因为它需要单独编译，参考后续的步骤4。&lt;br /&gt;
   其中GMP源码包是lzip压缩格式，需要下载lzip工具解压（brew安装）。
3. 下载 gdb 源码&lt;br /&gt;
   下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gdb/&#34;&gt;源码包&lt;/a&gt;并解压,得到的目录名称之为「$gdb-7.6.1」。
4. 设置环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export CC=/usr/local/bin/gcc-4.8
    export CXX=/usr/local/bin/g++-4.8
    export CPP=/usr/local/bin/cpp-4.8
    export LD=/usr/local/bin/gcc-4.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都是brew版gcc4.8.1的软链接。如果不设置，那么会使用系统中默认自带的工具，这些工具版本都很陈旧。比如osx 10.8.4带的/usr/bin/gcc是4.2版本的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export PREFIX=$HOME/opt/cross
    export TARGET=i586-elf
    export PATH=&amp;quot;$PREFIX/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是编译时候使用的选项。
5. 编译交叉版的binutils&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    cd $binutils-x.y.z
    mkdir build-binutils
    cd build-binutils
    ../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls
    make
    make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;四-编译交叉版的gcc&#34;&gt;四、编译交叉版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gcc-4.8.1
mkdir build-gcc
cd build-gcc
../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls --enable-languages=c,c++ --without-headers
make all-gcc
make all-target-libgcc
make install-gcc
make install-target-libgcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后，在「~/opt/cross/bin」下就能看到编译好的交叉版的编译套件了，包括「i586-elf-gcc」、「i586-elf-g++」和「i586-elf-ld」等等。可以用「$HOME/opt/cross/bin/$TARGET-gcc &amp;ndash;version」来验证一下版本是否正确。&lt;br /&gt;
　　另外，为了方便使用，可以在.bashrc或者.zshrc中调整环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=&amp;quot;$HOME/opt/cross/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;五-测试源码&#34;&gt;五、测试源码&lt;/h1&gt;

&lt;p&gt;　　现在咱有了交叉编译器了，试试效果吧：
&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008000&#34;&gt;// kernel.c&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;&amp;quot;multiboot2.h&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;&lt;/span&gt;


&lt;span style=&#34;color: #0000ff&#34;&gt;#define INFO_REQ_COUNT  2&lt;/span&gt;

&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header_tag_information_request
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header_tag_information_request info_req __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
    multiboot_uint32_t req[INFO_REQ_COUNT];
} __attribute__((packed));


&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header header __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header_tag_information_request info_req __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header_tag end __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
} __attribute__((packed));


&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header amb =
{
    {
        MULTIBOOT2_HEADER_MAGIC,
        MULTIBOOT_ARCHITECTURE_I386,
        &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header),
        -(MULTIBOOT2_HEADER_MAGIC + MULTIBOOT_ARCHITECTURE_I386 + &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header))
    },

    {
        {
            MULTIBOOT_HEADER_TAG_INFORMATION_REQUEST,
            MULTIBOOT_HEADER_TAG_OPTIONAL,
            &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header_tag_information_request)
        },
        MULTIBOOT_TAG_TYPE_BASIC_MEMINFO,
        MULTIBOOT_TAG_TYPE_FRAMEBUFFER
    },

    {
        MULTIBOOT_HEADER_TAG_END,
        MULTIBOOT_HEADER_TAG_OPTIONAL,
        &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header_tag)
    }
};


&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; breakpoint()
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;asm&lt;/span&gt;(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;xchg %bx, %bx&amp;quot;&lt;/span&gt;);
}


&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; _start()
{
    breakpoint();
    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;　　multiboot2.h头文件是从grub2.0.0的源码里拷贝过来的，主要定义了符合multiboot2规范的数据结构。&lt;br /&gt;
　　编译方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/opt/cross/bin/i586-elf-gcc -c -o kernel.o kernel.c
~/opt/cross/bin/i586-elf-ld -Ttext=0x100000 -o kernel.bin kernel.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　「-Ttext=0x100000」是为了让代码段加载到0x100000，而不是默认的08048074（我的环境中），后者超出我的bochs虚拟机的物理内存空间。&lt;br /&gt;
　　然后用kernel.bin替换之前的虚拟磁盘中的同名文件，再运行bochs虚拟机就能看到熟悉的magic breakpoint了。&lt;/p&gt;

&lt;h1 id=&#34;六-编译交叉版的-gdb&#34;&gt;六、编译交叉版的 gdb&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gdb-7.6.1
mkdir build-$TARGET
cd build-$TARGET
../configure --target=$TARGET --prefix=$PREFIX --disable-nls
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后,在「~/opt/cross/bin」下就能看到编译好的交叉版的i586-elf-gdb 了。&lt;/p&gt;

&lt;h1 id=&#34;七-参考资料&#34;&gt;七、参考资料&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler&#34;&gt;GCC Cross-Compiler&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;八-版本记录&#34;&gt;八、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-09-07，初始发布。&lt;/li&gt;
&lt;li&gt;v1.1 - 2013-11-04，增加「编译交叉版的gdb」章节。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;九-网友补充&#34;&gt;九、网友补充&lt;/h1&gt;

&lt;p&gt;以下内容为热心网友补充，供同好参考。（我没有验证。暂记录在这里，后续验证过后我再补入正文。感谢这位网友被我之前老博客系统的验证码刁难了N次后，还依然告知我，非常感谢。）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;OSX10.9下使用gcc4.8编译binutils-2.24会报错：nm.c:1687:7: error: &amp;lsquo;sbrk&amp;rsquo; is deprecated (declared at /usr/include/unistd.h:582)&lt;br /&gt;
需要使用gcc4.9，编译时指定编译参数CFLAGS=-Wno-error=deprecated-declarations&lt;br /&gt;
gcc的依赖项GMP/FPMR/MPC也不需要手动下载，在gcc的源码下执行./contrib/download_prerequisites即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-09-17/osx下搭建操作系统开发环境之32位交叉开发工具集（gcc+gdb）v1.1.pdf&#34;&gt;osx下搭建操作系统开发环境之32位交叉开发工具集（gcc+gdb）v1.1.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>