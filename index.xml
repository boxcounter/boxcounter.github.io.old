<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Boxcounter的烂笔头</title>
    <link>http://boxcounter.com/</link>
    <description>Recent content on Boxcounter的烂笔头</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 03 Aug 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://boxcounter.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>书单</title>
      <link>http://boxcounter.com/essay/2015-08-03-%E4%B9%A6%E5%8D%95/</link>
      <pubDate>Mon, 03 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/essay/2015-08-03-%E4%B9%A6%E5%8D%95/</guid>
      <description>

&lt;p&gt;记录我读完的书，从2014年开始记录，每月起始更新上月读的书。主要记录有点厚度的，薄手册和零散资料不记。&lt;/p&gt;

&lt;h3 id=&#34;分类:36a4ad5affe1962fa40babf59276037c&#34;&gt;分类&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;评分&lt;/th&gt;
&lt;th&gt;简述&lt;/th&gt;
&lt;th&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;9~10&lt;/td&gt;
&lt;td&gt;经典书籍，值得反复阅读&lt;/td&gt;
&lt;td&gt;《史记》(10)、《TCP/IP详解》(10)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7~8&lt;/td&gt;
&lt;td&gt;好书，可能再读&lt;/td&gt;
&lt;td&gt;《大秦帝国》、《明朝那些事儿》、二月河的康雍乾&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5~6&lt;/td&gt;
&lt;td&gt;读完有点收获，应该不会再读&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;!-- 陈志武《金融的逻辑》 --&gt;

&lt;!-- 茅于轼《生活中的经济学》 --&gt;

&lt;!-- 许小年《从来就没有救世主》 --&gt;

&lt;!-- 薛兆丰《经济学通识》 --&gt;

&lt;!-- 索维尔《诡辩与真相——经济学入门》 --&gt;

&lt;!-- 贝克尔《生活中的经济学》 --&gt;

&lt;!-- 弗里德曼《资本主义与自由》 --&gt;

&lt;!-- 系统的： --&gt;

&lt;!-- 穆雷·N. 罗斯巴德《人、经济与国家》 --&gt;

&lt;!-- 茅于轼和岑科合著的《人文经济学》 --&gt;

&lt;!-- 张五常的《经济解释》 --&gt;

&lt;!-- 保罗·海恩等人著的《经济学的思维方式》 --&gt;

&lt;!-- 米塞斯的《人的行动》 --&gt;

&lt;!-- https://mp.weixin.qq.com/s?__biz=MjM5NjQ3MDMxMA==&amp;mid=217884728&amp;idx=3&amp;sn=fc915e09648c48e5d81e4cf3358a0ee2&amp;key=af154fdc40fed003c8a2d3d70a5d4cc787e6c79bb83dc3f8c15b882ae7ff4bcd5aa5192904537e33e0b97e4a4d33ad06&amp;ascene=1&amp;uin=NjQ4OTk1NTQy&amp;devicetype=iPhone+OS8.3&amp;version=16020211&amp;nettype=WIFI&amp;fontScale=109&amp;pass_ticket=OnHOxL02jchDp082n6Y3fvFh8AE3PugSmpcuxtd3exPO2C%2F5xaRWrihNM3tYEQFX --&gt;

&lt;h3 id=&#34;2015年:36a4ad5affe1962fa40babf59276037c&#34;&gt;2015年&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;书名&lt;/th&gt;
&lt;th&gt;作译编者&lt;/th&gt;
&lt;th&gt;读毕日期&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;评分&lt;/th&gt;
&lt;th&gt;其他&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;《南渡北归：南渡（上）》&lt;/td&gt;
&lt;td&gt;岳南&lt;/td&gt;
&lt;td&gt;01-13&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;《浪潮之巅(第2版)（上）》&lt;/td&gt;
&lt;td&gt;吴军&lt;/td&gt;
&lt;td&gt;01-27&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;《南渡北归：南渡（下）》&lt;/td&gt;
&lt;td&gt;岳南&lt;/td&gt;
&lt;td&gt;01-29&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;《南渡北归：北归（上）》&lt;/td&gt;
&lt;td&gt;岳南&lt;/td&gt;
&lt;td&gt;02-07&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;《南渡北归：北归（下）》&lt;/td&gt;
&lt;td&gt;岳南&lt;/td&gt;
&lt;td&gt;02-16&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;《南渡北归：离别（上）》&lt;/td&gt;
&lt;td&gt;岳南&lt;/td&gt;
&lt;td&gt;02-19&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;《南渡北归：离别（下）》&lt;/td&gt;
&lt;td&gt;岳南&lt;/td&gt;
&lt;td&gt;03-01&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;《失控》&lt;/td&gt;
&lt;td&gt;Kevin Kelly&lt;/td&gt;
&lt;td&gt;04-06&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;《浪潮之巅(第2版)（下）》&lt;/td&gt;
&lt;td&gt;吴军&lt;/td&gt;
&lt;td&gt;04-08&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;《饥饿的盛世》&lt;/td&gt;
&lt;td&gt;张宏杰&lt;/td&gt;
&lt;td&gt;04-12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;《柏杨版资治通鉴（第25卷 恐怖世界·恶妻恶女）》&lt;/td&gt;
&lt;td&gt;司马光/柏杨&lt;/td&gt;
&lt;td&gt;04-28&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;《柏杨版资治通鉴（第26卷 开元盛世·范阳兵变）》&lt;/td&gt;
&lt;td&gt;司马光/柏杨&lt;/td&gt;
&lt;td&gt;05-11&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;《柏杨版资治通鉴（第27卷 睢阳之围·皇后失踪）》&lt;/td&gt;
&lt;td&gt;司马光/柏杨&lt;/td&gt;
&lt;td&gt;05-20&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;《文明之光（上）》&lt;/td&gt;
&lt;td&gt;吴军&lt;/td&gt;
&lt;td&gt;06-02&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;《柏杨版资治通鉴（第28卷 泾原兵变·猪皇帝）》&lt;/td&gt;
&lt;td&gt;司马光/柏杨&lt;/td&gt;
&lt;td&gt;06-04&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;《投机者的扑克》&lt;/td&gt;
&lt;td&gt;扁虫鱼&lt;/td&gt;
&lt;td&gt;06-16&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;《三体》&lt;/td&gt;
&lt;td&gt;刘慈欣&lt;/td&gt;
&lt;td&gt;06-23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;《炒股的智慧》&lt;/td&gt;
&lt;td&gt;陈江挺&lt;/td&gt;
&lt;td&gt;06-29&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;《文明之光（中）》&lt;/td&gt;
&lt;td&gt;吴军&lt;/td&gt;
&lt;td&gt;07-03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;《三体——黑暗森林》&lt;/td&gt;
&lt;td&gt;刘慈欣&lt;/td&gt;
&lt;td&gt;07-07&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;《一课经济学》&lt;/td&gt;
&lt;td&gt;Henry Hazlitt&lt;/td&gt;
&lt;td&gt;07-14&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;《怦然心动的人生整理魔法》&lt;/td&gt;
&lt;td&gt;近藤麻理惠&lt;/td&gt;
&lt;td&gt;07-14&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;《三体——死神永生》&lt;/td&gt;
&lt;td&gt;刘慈欣&lt;/td&gt;
&lt;td&gt;07-17&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;《怦然心动的人生整理魔法2》&lt;/td&gt;
&lt;td&gt;近藤麻理惠&lt;/td&gt;
&lt;td&gt;07-22&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;《茶艺师——基础知识》&lt;/td&gt;
&lt;td&gt;陈文华&lt;/td&gt;
&lt;td&gt;07-28&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;2014年:36a4ad5affe1962fa40babf59276037c&#34;&gt;2014年&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;书名&lt;/th&gt;
&lt;th&gt;作译编者&lt;/th&gt;
&lt;th&gt;读毕日期&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;评分&lt;/th&gt;
&lt;th&gt;其他&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;《代码大全》&lt;/td&gt;
&lt;td&gt;Steve McConnell&lt;/td&gt;
&lt;td&gt;1月&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td&gt;3rd&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;《高效程序员的45个习惯：敏捷开发修炼之道》&lt;/td&gt;
&lt;td&gt;Venkat Subramaniam / Andy Hunt&lt;/td&gt;
&lt;td&gt;1月&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;《黑客与画家》&lt;/td&gt;
&lt;td&gt;Paul Graham&lt;/td&gt;
&lt;td&gt;2月&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;《代码的未来》&lt;/td&gt;
&lt;td&gt;松本行弘&lt;/td&gt;
&lt;td&gt;2月&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;《MacTalk·人生元编程（纸版）》&lt;/td&gt;
&lt;td&gt;池建强&lt;/td&gt;
&lt;td&gt;2月&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;《柏杨版资治通鉴》&lt;/td&gt;
&lt;td&gt;司马光/柏杨&lt;/td&gt;
&lt;td&gt;0101刘宋， 0301陈后主即将上台&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;《给你一个团队，你能怎么管？》&lt;/td&gt;
&lt;td&gt;赵伟&lt;/td&gt;
&lt;td&gt;03-07&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;《程序员的职业素养》&lt;/td&gt;
&lt;td&gt;Robert C.Martin&lt;/td&gt;
&lt;td&gt;03-14&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;《殷商玛雅征服史》&lt;/td&gt;
&lt;td&gt;马伯庸&lt;/td&gt;
&lt;td&gt;03-24&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;《关键对话：如何高效能沟通》&lt;/td&gt;
&lt;td&gt;Kerry Patterson/Joseph Grenny/Ron McMillan&lt;/td&gt;
&lt;td&gt;03-26&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;《简约至上》&lt;/td&gt;
&lt;td&gt;Giles Colborne&lt;/td&gt;
&lt;td&gt;04-01&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;《帝国最后的荣耀》&lt;/td&gt;
&lt;td&gt;马伯庸/汗青&lt;/td&gt;
&lt;td&gt;04-07&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;《浪潮之巅（第一版）》&lt;/td&gt;
&lt;td&gt;吴军&lt;/td&gt;
&lt;td&gt;04-17&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;《项目管理修炼之道》&lt;/td&gt;
&lt;td&gt;Johanna Rothman&lt;/td&gt;
&lt;td&gt;04-27&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;《Android开发精要》&lt;/td&gt;
&lt;td&gt;范怀宇&lt;/td&gt;
&lt;td&gt;05-15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;《代码整洁之道》&lt;/td&gt;
&lt;td&gt;Robert C.Martin&lt;/td&gt;
&lt;td&gt;05-21&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;《三国机密》&lt;/td&gt;
&lt;td&gt;马伯庸&lt;/td&gt;
&lt;td&gt;05-30&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;《我读书少你可别骗我》&lt;/td&gt;
&lt;td&gt;马伯庸&lt;/td&gt;
&lt;td&gt;06-03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;《精益开发实战》&lt;/td&gt;
&lt;td&gt;Henrik Kniberg&lt;/td&gt;
&lt;td&gt;06-24&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;《鬼吹灯（全）》&lt;/td&gt;
&lt;td&gt;天下霸唱&lt;/td&gt;
&lt;td&gt;06-29&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;《重来:更为简单有效的商业思维》&lt;/td&gt;
&lt;td&gt;Jason Fried/David Heinemeier Hansson&lt;/td&gt;
&lt;td&gt;07-03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;《悟空传·完美纪念版》&lt;/td&gt;
&lt;td&gt;今何在&lt;/td&gt;
&lt;td&gt;07-03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;《风起陇西》&lt;/td&gt;
&lt;td&gt;马伯庸&lt;/td&gt;
&lt;td&gt;07-07&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;《一座城池》&lt;/td&gt;
&lt;td&gt;韩寒&lt;/td&gt;
&lt;td&gt;07-11&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;《人月神话（32周年中文纪念版）》&lt;/td&gt;
&lt;td&gt;Frederick P.Brooks.Jr&lt;/td&gt;
&lt;td&gt;07-14&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;《程序员的思维修炼》&lt;/td&gt;
&lt;td&gt;Andy Hunt&lt;/td&gt;
&lt;td&gt;07-21&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;《柏杨版资治通鉴（第21卷 突厥可汗·南北统一）》&lt;/td&gt;
&lt;td&gt;司马光/柏杨&lt;/td&gt;
&lt;td&gt;08-03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;《柏杨版资治通鉴（第22卷 官逼民反·江都政变）》&lt;/td&gt;
&lt;td&gt;司马光/柏杨&lt;/td&gt;
&lt;td&gt;08-17&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;《参与感》&lt;/td&gt;
&lt;td&gt;黎万强&lt;/td&gt;
&lt;td&gt;08-22&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;《柏杨版资治通鉴（第23卷 玄武门·贞观之治）》&lt;/td&gt;
&lt;td&gt;司马光/柏杨&lt;/td&gt;
&lt;td&gt;09-02&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;31&lt;/td&gt;
&lt;td&gt;《柏杨版资治通鉴（第24卷 黄金时代·武后夺权）》&lt;/td&gt;
&lt;td&gt;司马光/柏杨&lt;/td&gt;
&lt;td&gt;09-07&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;《南明那些事儿》&lt;/td&gt;
&lt;td&gt;洪兵&lt;/td&gt;
&lt;td&gt;09-18&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;33&lt;/td&gt;
&lt;td&gt;《敏捷软件开发——原则、模式与实践作者》&lt;/td&gt;
&lt;td&gt;Robert C·Martin&lt;/td&gt;
&lt;td&gt;09-21&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;34&lt;/td&gt;
&lt;td&gt;《人件》&lt;/td&gt;
&lt;td&gt;Tom DeMarco/Timothy Lister&lt;/td&gt;
&lt;td&gt;09-28&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;td&gt;《最简单的图形与最复杂的信息》&lt;/td&gt;
&lt;td&gt;黄慧敏&lt;/td&gt;
&lt;td&gt;10-09&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;36&lt;/td&gt;
&lt;td&gt;《敏捷武士——看敏捷高手交付卓越软件》&lt;/td&gt;
&lt;td&gt;Jonathan　Rasmusson&lt;/td&gt;
&lt;td&gt;10月&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;37&lt;/td&gt;
&lt;td&gt;《红顶商人胡雪岩》&lt;/td&gt;
&lt;td&gt;高阳&lt;/td&gt;
&lt;td&gt;12-09&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Android下列表视图的性能优化</title>
      <link>http://boxcounter.com/technique/2015-08-01-Android%E4%B8%8B%E5%88%97%E8%A1%A8%E8%A7%86%E5%9B%BE%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 01 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2015-08-01-Android%E4%B8%8B%E5%88%97%E8%A1%A8%E8%A7%86%E5%9B%BE%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>

&lt;h2 id=&#34;前言:8c4b42c7fcdddc798bef89a3decbbb54&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;Android下使用列表控件，如&lt;code&gt;RecyclerView&lt;/code&gt;和&lt;code&gt;ListView&lt;/code&gt;，很容易遇到滚动不流畅的问题。本文记录我的一次性能优化过程。&lt;/p&gt;

&lt;h2 id=&#34;常见范式:8c4b42c7fcdddc798bef89a3decbbb54&#34;&gt;常见范式&lt;/h2&gt;

&lt;p&gt;我们经常这样使用列表控件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;（使用&lt;code&gt;ListView&lt;/code&gt;）重写&lt;code&gt;Adapter.getView()&lt;/code&gt;，在其中创建或重用View和ViewHolder，将业务数据结构显示到View中。&lt;/li&gt;
&lt;li&gt;（使用&lt;code&gt;RecylerView&lt;/code&gt;）重写&lt;code&gt;Adapter.onCreateViewHolder()&lt;/code&gt;和&lt;code&gt;Adapter.onBindViewHolder()&lt;/code&gt;，在前者中创建View和ViewHolder，在后者中将业务数据结构显示到View中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个范式用了一种优化技术：View重用。避免了频繁的create view和find view过程，这两个过程都是很耗时的。但仅这一种优化手段不足以解决所有的性能问题。&lt;/p&gt;

&lt;h2 id=&#34;优化过程:8c4b42c7fcdddc798bef89a3decbbb54&#34;&gt;优化过程&lt;/h2&gt;

&lt;p&gt;接下来，我将基于一个实际项目的简化版来说明如何进行优化。&lt;/p&gt;

&lt;h3 id=&#34;一-减少overdraw:8c4b42c7fcdddc798bef89a3decbbb54&#34;&gt;一、减少Overdraw&lt;/h3&gt;

&lt;p&gt;Overdraw是常见性能损耗点，且多是无谓的性能损耗。相关资料非常丰富，这里不赘述。只提醒一点：善用&lt;code&gt;Window.setBackgroundDrawable*()&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;二-内存优化:8c4b42c7fcdddc798bef89a3decbbb54&#34;&gt;二、内存优化&lt;/h3&gt;

&lt;p&gt;优化内存使用也是一种常用的性能优化手段。它的机理是：GC会暂停所有线程，而频繁触发GC会加剧掉帧问题。&lt;/p&gt;

&lt;p&gt;来看一下主题的设计图，其中图片矩阵可以容纳0~9张图片。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://boxcounter.com/images/2015-08-01/memorySample.png&#34; width=&#34;300&#34;/&gt;&lt;/p&gt;

&lt;p&gt;优化方法是：尽量缓存、重用ImageView。比如：在&lt;code&gt;onBindViewHolder()&lt;/code&gt;中发现图片矩阵控件中已经包含了7个ImageView（上次该控件显示的主题有7张图片），当前要显示的主题有5张图片，那么直接重用前5个ImageView，隐藏剩下的2个ImageView。&lt;/p&gt;

&lt;h3 id=&#34;三-精简布局:8c4b42c7fcdddc798bef89a3decbbb54&#34;&gt;三、精简布局&lt;/h3&gt;

&lt;p&gt;来看一下主题的赞和评论区域。其中赞区域会有两种展现形式（针对不同的应用场景）。想想如果是你来实现，会怎么布局。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://boxcounter.com/images/2015-08-01/hierachySample1.png&#34; width=&#34;300&#34;/&gt;
&lt;img src=&#34;http://boxcounter.com/images/2015-08-01/hierachySample2.png&#34; width=&#34;300&#34;/&gt;&lt;/p&gt;

&lt;p&gt;布局方式可能会是这样：&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&amp;lt;LinearLayout android:orientation=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;vertical&amp;quot;&lt;/span&gt; &amp;gt;

    &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 赞区域 --&amp;gt;&lt;/span&gt;
    &amp;lt;LinearLayout android:orientation=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;horizontal&amp;quot;&lt;/span&gt; &amp;gt;
        &amp;lt;ImageView /&amp;gt;   &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 心形图标 --&amp;gt;&lt;/span&gt;
        &amp;lt;GridLayout /&amp;gt;  &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 头像形式的赞 --&amp;gt;&lt;/span&gt;
        &amp;lt;TextView /&amp;gt;    &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 文字形式的赞 --&amp;gt;&lt;/span&gt;
    &amp;lt;/LinearLayout&amp;gt;

    &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 评论区域 --&amp;gt;&lt;/span&gt;
    &amp;lt;LinearLayout android:orientation=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;horizontal&amp;quot;&lt;/span&gt; &amp;gt;
        &amp;lt;ImageView /&amp;gt;   &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 评论图标 --&amp;gt;&lt;/span&gt;
        &amp;lt;LinearLayout
            android:orientation=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;vertical&amp;quot;&lt;/span&gt;
            /&amp;gt; &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 评论列表容器 --&amp;gt;&lt;/span&gt;
    &amp;lt;/LinearLayout&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;根据赞的显示方式来设置&lt;code&gt;GridLayout&lt;/code&gt;和&lt;code&gt;TextView&lt;/code&gt;的Visibility。&lt;/p&gt;

&lt;p&gt;我的方法是：根据需要动态改变布局结构、保正显示效果的同时精简数量和层级。优化后是这样：&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&amp;lt;LinearLayout android:orientation=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;vertical&amp;quot;&lt;/span&gt; &amp;gt;

    &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 赞区域 --&amp;gt;&lt;/span&gt;
    &amp;lt;ViewStub android:background=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;heart.9.png&amp;quot;&lt;/span&gt; /&amp;gt;

    &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 评论区域 --&amp;gt;&lt;/span&gt;
    &amp;lt;LinearLayout
        android:orientation=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;vertical&amp;quot;&lt;/span&gt;
        android:background=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;comment.9.png&amp;quot;&lt;/span&gt;
        android:paddingStart=&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;?dp&amp;quot;&lt;/span&gt;
        /&amp;gt; &lt;span style=&#34;color: #008000&#34;&gt;&amp;lt;!-- 评论列表容器 --&amp;gt;&lt;/span&gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;首先，原赞区域的&lt;code&gt;GridLayout&lt;/code&gt;和&lt;code&gt;TextView&lt;/code&gt;都放到单独的布局文件中，原布局中换上&lt;code&gt;ViewStub&lt;/code&gt;，根据需要动态inflate。其次，赞和评论图标改成.9图作为&lt;code&gt;Background&lt;/code&gt;、并辅以&lt;code&gt;paddingStart&lt;/code&gt;（具体数值由评论图标的宽度计算得到）。&lt;/p&gt;

&lt;p&gt;后者的缺点是.9图可能因为拉伸变得不够清晰，但实测下来效果满足需要。&lt;/p&gt;

&lt;h3 id=&#34;四-预处理:8c4b42c7fcdddc798bef89a3decbbb54&#34;&gt;四、预处理&lt;/h3&gt;

&lt;p&gt;需要引入一点业务数据结构来辅助说明。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000&#34;&gt;// 约定：为了行文简洁，本文中所有代码都隐藏了诸如public关键字、构造函数等非核心内容。&lt;/span&gt;

&lt;span style=&#34;color: #008000&#34;&gt;// 主题&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;Topic&lt;/span&gt; {
    String mText;               &lt;span style=&#34;color: #008000&#34;&gt;// 文字内容。&lt;/span&gt;
    List&amp;lt;String&amp;gt; mImages;       &lt;span style=&#34;color: #008000&#34;&gt;// 图片链接。&lt;/span&gt;
    List&amp;lt;User&amp;gt; mLikes;          &lt;span style=&#34;color: #008000&#34;&gt;// 点赞的用户。&lt;/span&gt;
    List&amp;lt;Comment&amp;gt; mComments;    &lt;span style=&#34;color: #008000&#34;&gt;// 评论。&lt;/span&gt;
    User mCreater;              &lt;span style=&#34;color: #008000&#34;&gt;// 发表人。&lt;/span&gt;
    &lt;span style=&#34;color: #2b91af&#34;&gt;long&lt;/span&gt; mCreateTime;           &lt;span style=&#34;color: #008000&#34;&gt;// 发表的时间戳。&lt;/span&gt;
}

&lt;span style=&#34;color: #008000&#34;&gt;// 评论&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;Comment&lt;/span&gt; {
    String mText;   &lt;span style=&#34;color: #008000&#34;&gt;// 文字内容。&lt;/span&gt;
    User mCreater;  &lt;span style=&#34;color: #008000&#34;&gt;// 发表人。&lt;/span&gt;
}

&lt;span style=&#34;color: #008000&#34;&gt;// 用户&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;User&lt;/span&gt; {
    String mName;       &lt;span style=&#34;color: #008000&#34;&gt;// 用户名称。&lt;/span&gt;
    String mAvatarUrl;  &lt;span style=&#34;color: #008000&#34;&gt;// 头像的下载地址。&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;这其中有部分数据是可以预处理的，得到的数据结构如下：&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;PreprocessResult&lt;/span&gt; {
    CharSequence mText;             &lt;span style=&#34;color: #008000&#34;&gt;// 包含Spannable（比如超链接）的正文。&lt;/span&gt;
    String mLikes;                  &lt;span style=&#34;color: #008000&#34;&gt;// 用逗号分隔的文字形式的点赞用户的名称。&lt;/span&gt;
    List&amp;lt;CharSequence&amp;gt; mComments;   &lt;span style=&#34;color: #008000&#34;&gt;// 包含Spannable的评论列表。&lt;/span&gt;
    String mCreateTime;             &lt;span style=&#34;color: #008000&#34;&gt;// 发表时间。&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;然后在&lt;code&gt;onBindViewHolder()&lt;/code&gt;中就可以直接将&lt;code&gt;PreprocessResult&lt;/code&gt;的内容设置到相应的view上，避免在UI线程中动态处理造成掉帧。&lt;/p&gt;

&lt;p&gt;这种方法的缺点是增加了复杂度：PreprocessResult需要和Topic保持同步更新。比如用户点赞、发表评论之后，需要同步修改PreprocessResult和Topic。&lt;/p&gt;

&lt;h3 id=&#34;五-预创建:8c4b42c7fcdddc798bef89a3decbbb54&#34;&gt;五、预创建&lt;/h3&gt;

&lt;p&gt;分析发现，滚动过程会因为动态创建TopicView而卡顿。TopicView是用来显示整个主题的自定义View，包含前述的赞和评论等子布局。即便经过精简，整个布局依然比较复杂，inflate过程很耗时。于是预先创建了一些TopicView备用，在&lt;code&gt;onCreateViewHolder()&lt;/code&gt;中尽量使用它们，如果备用已经用完再动态创建。&lt;/p&gt;

&lt;h3 id=&#34;六-优化textview:8c4b42c7fcdddc798bef89a3decbbb54&#34;&gt;六、优化TextView&lt;/h3&gt;

&lt;p&gt;经过上述这几步优化之后，流畅度提升了很多，但偶尔还是会出现较明显的卡顿现象。分析发现是&lt;code&gt;TextView.setText()&lt;/code&gt;耗时过长导致的，在高强度测试下（长文主题，并且有很多评论），平均一次长文的调用就可能耗时22ms，已经超过了保证帧率的16ms上限。&lt;/p&gt;

&lt;p&gt;因为这个项目的业务逻辑决定了主题、评论的文字内容不会被修改，只有增删。于是采用的优化方法是：对于主题正文和评论，用&lt;code&gt;StaticLayout&lt;/code&gt;配合自定义View展示文字。自定义View代码如下：&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;StaticLayoutView&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;extends&lt;/span&gt; View {
    &lt;span style=&#34;color: #0000ff&#34;&gt;private&lt;/span&gt; StaticLayout mLayout;

    &lt;span style=&#34;color: #0000ff&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; setLayout(StaticLayout layout) {
        mLayout = layout;

        &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; height = layout.getHeight();
        &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; ((mLayout.getWidth() != layout.getWidth()) ||
                (mLayoutHeight != height)) {
            requestLayout();
        }

        mLayoutHeight = height;
    }

    @Override
    &lt;span style=&#34;color: #0000ff&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; onDraw(Canvas canvas) {
        &lt;span style=&#34;color: #0000ff&#34;&gt;super&lt;/span&gt;.onDraw(canvas);

        canvas.save();
        &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #0000ff&#34;&gt;null&lt;/span&gt; != mLayout) {
            canvas.translate(getPaddingLeft(), getPaddingTop());
            mLayout.draw(canvas);
        }
        canvas.restore();
    }

    @Override
    &lt;span style=&#34;color: #0000ff&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; onMeasure(&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; heightMeasureSpec) {
        &lt;span style=&#34;color: #0000ff&#34;&gt;super&lt;/span&gt;.onMeasure(widthMeasureSpec, heightMeasureSpec);
        &lt;span style=&#34;color: #0000ff&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #0000ff&#34;&gt;null&lt;/span&gt; != mLayout) {
            setMeasuredDimension(getMeasuredWidth(),
                    mLayoutHeight + getPaddingTop() + getPaddingBottom());
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;StaticLayoutView相比TextView简单、高效很多，更重要的是&lt;code&gt;StaticLayout&lt;/code&gt;可以在非UI线程创建、初始化。于是前述「预处理」过程中的数据结构变为：&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #2b91af&#34;&gt;PreprocessResult&lt;/span&gt; {
    StaticLayout mText;             &lt;span style=&#34;color: #008000&#34;&gt;// &amp;lt;= 之前是CharSequence&lt;/span&gt;
    String mLikes;
    List&amp;lt;StaticLayout&amp;gt; mComments;   &lt;span style=&#34;color: #008000&#34;&gt;// &amp;lt;= 之前是List&amp;lt;CharSequence&amp;gt;&lt;/span&gt;
    String mCreateTime;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;优化后，在高强度测试环境下，平均帧率从34上升至47。实际环境中的平均帧率约为51。&lt;/p&gt;

&lt;h2 id=&#34;总结:8c4b42c7fcdddc798bef89a3decbbb54&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;整个优化过程的核心思想是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;尽量减少滚动时UI线程中的耗时操作。能挪到后台线程的就不在UI线程中做，必须在UI线程做、但能预先处理的就提早处理；&lt;/li&gt;
&lt;li&gt;以空间换时间。用缓存来减少GC、创建等耗时操作；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要说明的是，一些优化方法是有代价的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;预处理可能增加用户的等待时间。以这个项目为例，进入某Activity后，一边显示进度条，一边从服务端获取一批Topic显示给用户。预处理和预先创建会较明显地增加用户的等待时间；&lt;/li&gt;
&lt;li&gt;缓存数据越多，OOM的风险越大；&lt;/li&gt;
&lt;li&gt;增加了复杂度；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;后记:8c4b42c7fcdddc798bef89a3decbbb54&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;除前述优化方法之外，还有一些零星的、未能实际应用的优化方法。比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;onBindViewHolder()&lt;/code&gt;中检查之前显示的内容是否就是当前将要显示的内容。如果是，return即可。这种方法可以在反方向滚动时，避免不必要的更新view操作。但前提条件是内容不会动态改变，在这个项目中Topic的内容是可能动态改变的，使用这个方法后反而增加了复杂度，权衡得失后，放弃了这个优化方法；&lt;/li&gt;
&lt;li&gt;使用Tracer for OpenGL检查OpenGL渲染过程；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，即便经过这一系列的优化，卡顿问题也未能根除。后续我可能会继续改进优化方案，如果有新的心得体会，再补上。也希望有同好分享经验，相互交流，共同进步，谢谢。&lt;/p&gt;

&lt;p&gt;最后，聊一下我对性能优化的一些建议：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先分析性能瓶颈，再对症下药。对于有经验的研发，这个过程可以适当地借助自己的经验法则。忌讳想当然的「优化」。&lt;/li&gt;
&lt;li&gt;善用工具。比如Traceview、Memory Monitor、Hierarchy Viewer。本文所述的优化过程重度依赖这些工具。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考资料:8c4b42c7fcdddc798bef89a3decbbb54&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://android-developers.blogspot.com/2010/10/traceview-war-story.html&#34;&gt;Traceview War Story&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://developer.android.com/intl/zh-cn/tools/debugging/debugging-ui.html&#34;&gt;Optimizing Your UI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&#34;&gt;Android Performance Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.curious-creature.com/2012/12/01/android-performance-case-study/&#34;&gt;Android Performance Case Study&lt;/a&gt; by Romain Guy&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.curious-creature.com/docs/android-performance-case-study-1.html&#34;&gt;Android Performance Case Study（同名不同文）&lt;/a&gt; by Romain Guy&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hukai.me/android-performance-patterns/&#34;&gt;Android性能优化典范&lt;/a&gt; by 胡凯&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ragnraok.github.io/textview-pre-render-research.html&#34;&gt;TextView预渲染研究&lt;/a&gt; by Ragnarok&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://instagram-engineering.tumblr.com/post/114508858967/improving-comment-rendering-on-android&#34;&gt;Improving Comment Rendering on Android&lt;/a&gt; by Instagram&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>机械键盘之「Kinesis Contoured Advantage」</title>
      <link>http://boxcounter.com/essay/2014-01-25-%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98/</link>
      <pubDate>Sat, 25 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/essay/2014-01-25-%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98/</guid>
      <description>&lt;p&gt;分享一点我的机械键盘体验。目前正在使用「Kinesis Contoured Advantage」。如图：
　　&lt;img src=&#34;http://boxcounter.com/images/2013-01-25/Kinesis-Contoured-Advantage.jpg&#34;/&gt;&lt;/p&gt;

&lt;p&gt;　　2013年的愚人节我在amazon.com上入的这把键盘（感谢BT姐的美帝仓储），用到现在差不多9个月了。顺嘴说一句，试了几次海淘，感觉不一定比淘宝实惠。比如关税、运费、等待时间等等。&lt;br /&gt;
　　入这把键盘的缘由是为了缓解左右小拇指的压力，更根本的缘由是因为我是重度的emacs使用者。从头开始讲吧，顺便也分享一点体会：&lt;br /&gt;
　　我大概是两年前开始使用emacs，之前使用的是vim，再之前是各种编辑器和IDE（估计有上十款）。截至到目前，emacs是我最满意的一款。编辑器很容易惹口水，还是扯回来说我的体验吧。&lt;br /&gt;
　　emacs的快捷键几乎都以ctrl或alt与其它键的组合，特别是ctrl，常用的快捷键一多半都用它。比如：打开文件「ctrl+x ctrl+f」，保存文件「ctrl+x ctrl+s」。所以蛮多emacser都会将ctrl键和caps-lock键对调。这样左小拇指敲ctrl的时候会舒适一些。此外，emacs的「上一行」的快捷键是「ctrl+p」。于是emacser的左右小拇指的压力会比一般人更大一些。&lt;br /&gt;
　　绝大多数人使用的键盘布局都是qwerty，这个键盘布局并不是一个好的设计，而是为了解决一个挺让人无语的问题的产物。有兴趣的朋友可以看看&lt;a href=&#34;http://zh.wikipedia.org/wiki/QWERTY%E9%8D%B5%E7%9B%A4&#34;&gt;维基上qwerty的介绍&lt;/a&gt;。更加剧了手指负荷的不均，比如最有力的大拇指基本只用来敲「space alt」。而小拇指却要负责多上许多的键，比如右小拇指需要负责：「0 p : &amp;ldquo; ? delete enter」等。对码农而言就更惨了，因为要负责更多的高频键，比如「) = { }」等。&lt;br /&gt;
　　我个人感觉会更明显，因为我敲键盘比较用力。我倒不是喜欢把手指抬高然后猛敲下去，而是手指贴着键盘，按下去的时候会很用力，要不总担心没按到位。时间长了，大概1年多之后，在高强度码代码之后小拇指会出现疲劳酸涨的感觉。思索了一些解决方案，包括换键盘映射，比如dvorak。但是反复思量、体验，最终还是放弃了。于是开始留心人体工学键盘，偶然间发现了这款键盘。&lt;/p&gt;

&lt;p&gt;　　这款键盘应该是相当小众的一款，google上搜不到太多的资料，中文的使用体验貌似就一两篇。我入的时候也抱着有赌的想法。来说说这款键盘的特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;为最有力的大拇指准备了很多键。&lt;br /&gt;
而且考虑到了大拇指的尺寸和位置，将最贴合大拇指的四个键做得很大。极大的提升了大拇指的功效和输入的整体舒适性。比如我就把这些键设置到了大拇指区域：左手「ctrl alt」，右手「enter space delete」。&lt;/li&gt;
&lt;li&gt;左右分布和手托设计更合理。&lt;br /&gt;
左右手的工作区域分隔的更开了，配合手托，双手可以自然伸直，不用别手腕。小臂也可以基本平行，摆放更舒服。&lt;/li&gt;
&lt;li&gt;方向键位置更合理。&lt;br /&gt;
方向键都放在食指和中指区，非常方便使用。常规键盘的方向键都是单独放在右下角，需要使用的时候右手需要移出主工作区域。对我个人来说操作起来很别扭，需要低头找方向键，敲完了还要再摸索回主工作区。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　上面两点是这款键盘最突出的几个优点。可以算是它区别于其它机械键盘的杀手级优点。有的网评还列举了一些其它的优点，我倒感觉一般般，比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更符合人体工学的「凹陷的键区」。&lt;br /&gt;
目前我还没有明显感觉到它的凹陷设计比其它机械键盘更舒适。&lt;/li&gt;
&lt;li&gt;高度可定制，并且自带记忆效果。&lt;br /&gt;
前者我用的少，只是重设定了几个键之后就再也不改了。宏定义我一次也没用过。记忆效果也没什么感觉，因为这货体积庞大，并不适合随身携带。估计大部分用户都只用来配合一台机器使用吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　再来说一下它的缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fx键基本没法用。&lt;br /&gt;
最上面一排的Fx键尺寸太小，而且间隔特均匀。不低头瞄一眼，根本找不着目标键。&lt;/li&gt;
&lt;li&gt;制作工艺一般。&lt;br /&gt;
相对我使用的另一款filco而言。键帽的手感等等要差一些。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　总结：&lt;br /&gt;
　　如果是重度的emacser，推荐入一把。如果是键盘操作流，可以考虑入一把。如果是轻度机械键盘爱好者，慎重考虑。&lt;/p&gt;

&lt;p&gt;　　对了，这货有原厂脚踏板可选购。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>隔栏、断言、防御型和攻击型编程的思考</title>
      <link>http://boxcounter.com/technique/2014-01-12-assert-defensive-offensive-programming/</link>
      <pubDate>Sun, 12 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2014-01-12-assert-defensive-offensive-programming/</guid>
      <description>

&lt;h1 id=&#34;一-前言:03abadb4947350f837a3f50c1387e0d7&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　本文的内容最初源自我重温《代码大全》时候读到的一段内容，然后和同事讨论又引发了自己的一些思索。最后觉得这值得写下来，一来我一直很喜欢琢磨编码风格，有一些这方面的​思考，但都是一些存放在脑子里的思维碎片，（部分）整理成文对我自己是件好事。二来抛砖引玉，希望能找到一些同好探讨。&lt;/p&gt;

&lt;h1 id=&#34;二-常用的断言宏:03abadb4947350f837a3f50c1387e0d7&#34;&gt;二、常用的断言宏&lt;/h1&gt;

&lt;p&gt;　　先贴一段我常用的断言宏，后面讲述的时候所说的ASSERT是通指下面这一组ASSERT*。
&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;#ifdef DEBUG&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT(x) assert(x)&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#else&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT(x)&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#endif&lt;/span&gt;

&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_RETURN(x)            {ASSERT(x); if(!(x)) {return;}}&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_RETURN_VAL(x, ret)   {ASSERT(x); if(!(x)) {return ret;}}&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_GOTO(x, label)       {ASSERT(x); if(!(x)) {goto label;}}&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_BREAK(x)             {ASSERT(x); if(!(x)) {break;}}&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#define ASSERT_CONTINUE(x)          {ASSERT(x); if(!(x)) {continue;}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;三-隔栏与断言:03abadb4947350f837a3f50c1387e0d7&#34;&gt;三、隔栏与断言&lt;/h1&gt;

&lt;p&gt;　　《代码大全》里有这么一段“隔栏与断言的关系”：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;隔栏外部的程序应使用错误处理技术，在那里对数据做的任何假定都是不安全的。&lt;br /&gt;
隔栏内部的程序应使用断言技术，因为传进来的数据应该已在通过隔栏时被清理过了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　这里的“隔栏”我理解为一些接口，比如类的public函数。按照上述说法，应该在public函数的对参数进行合法性验证“if (!x) return”，在private函数的开头使用ASSERT。&lt;/p&gt;

&lt;p&gt;　　感觉也有点道理。但是觉得又不太习惯。我习惯这么做：&lt;br /&gt;
　　public和private函数都用ASSERT，既把问题反馈给外部使用者，又反馈自身内部的问题。&lt;/p&gt;

&lt;p&gt;　　曾经和同事讨论过这个问题，同事没我这么挑（或者“钻牛角尖”？），他一般的做法是：在public函数里做参数检查，private里不对参数做检查。一来是priva​te里没必要做判断（public已经判断过了），二来是影响效率。&lt;/p&gt;

&lt;p&gt;　　我尝试了一段时间，但是还是觉得不合我的习惯，原因是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;即便public函数做了参数检查，也难保开发者不引入别的问题。比如传递参数过程中误改。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;所谓“内部”、“外部”，只是个相对的概念。多人协作来开发、使用这些类的过程中，一个模块中的函数可能由不同的开发者编写，相互都可以理解为“外部”（甚至不同函数也可​以认为互为“外部”）。即便在做设计时已经约定好相互之间的数据要求，也难免实现过程中会偏离。更不用说使用极端敏捷开发、基本不做文档化设计的小团队协作。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如“隔栏和断言的关系”所述：“隔栏内部的程序应使用断言技术，因为传进来的数据应该已在通过隔栏时被清理过了”。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;担忧的那部分性能损耗极有可能微乎其微。（后面有一些性能优化的想法分享。）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　又琢磨了琢磨，感觉《代码大全》里说的也有道理。隔栏处确实更适合做过滤，而不是断言。&lt;br /&gt;
　　因为隔栏外部的程序未必需要隔栏内部的反馈。比如单元测试时，测试程序可能会有意的传入非法的参数。&lt;/p&gt;

&lt;h1 id=&#34;四-一个讨论引发的思索:03abadb4947350f837a3f50c1387e0d7&#34;&gt;四、一个讨论引发的思索&lt;/h1&gt;

&lt;p&gt;　　另外，同事分享了一个讨论贴，主贴里楼主愤怒地吐槽：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;昨天线上的一个服务程序问了点问题，程序无限重启。&lt;br /&gt;
通过gdb调试发现该程序在某个函数里调用空指针，然后造成了段错误。因为有守护进程监控，所以有了无限重启的现像。&lt;br /&gt;
我把引起段错误的地方告诉了程序的作者，此人竟然说，这个指针应该不为空才对，现在指针为空说明了数据有问题，应该让数据的生产者去修改，他拒绝修改。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　跟帖的有支持楼主的（后简称A），也有认同文中“程序的作者”（B）。&lt;/p&gt;

&lt;p&gt;　　回帖里支持双方的都有。比如支持B的典型说法有：“strcpy不就这样么？”、“野指针同样会照成崩溃，所以是否检查空指针完全看程序各个模块之间的约定”。&lt;/p&gt;

&lt;p&gt;　　我是毫不犹豫的支持A的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;错误应该尽早暴露。&lt;br /&gt;
  并且应该尽可能由开发者可控的引爆，而不是被动的爆掉，然后没头脑地分析爆炸现场。简单来说，一个好的开发人员应该让修正问题的代价尽可能的小。&lt;/li&gt;
&lt;li&gt;参数检查不是银弹，但即便如此，对一些普遍的错误做处理也是必要且高效的。&lt;br /&gt;
  比如常见的NULL指针。这些常见的错误可能占各种参数错误发生总量的一半，解决掉它们带来的收益是很可观的。很多事情很难做到100%完美，但是度量（很多时候靠经验）​面对的问题，整理出解决这些问题的收益比曲线，然后处理掉那些收益比最高的问题，就是一个很好的方法。而不是嚷嚷“我没办法解决100%的问题，所以我就不解决了。问题出​现了再说”。激进一点说，在我看来，这是不负责的想法。&lt;/li&gt;
&lt;li&gt;标准库的做法并不一定是正确的，比如臭名昭著的realloc。&lt;br /&gt;
  具体的缺点很多文章里有讨论，《代码大全》里也有提到。&lt;/li&gt;
&lt;li&gt;函数都需要检查参数。&lt;br /&gt;
  至于如何检查参数（比如是否需要检查空指针），主要取决于函数本身对参数的期望，而不应只取决“模块之间的约定”。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　说的远一些，我很喜欢有调试开关或者调试功能的开发库和工具。比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;*nix平台下的glibc中的MALLOC_CHECK_宏、valgrind，还有electric-fence（貌似这货会误报，哪位朋友分享一个更好的？）等等。&lt;/li&gt;
&lt;li&gt;windows下的application verifier、driver verifier，还有checked版本的系统等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　对我来说，我甚至希望所有的开发库都有类似的机制。我希望某天开发者能通过某个开关让strcpy检查空指针，检查源、目的覆盖问题等等。&lt;/p&gt;

&lt;p&gt;　　此外，还有一些涉及到防御型编程和“攻击型编程”（好像没有约定俗成的名称？姑且这么称呼吧）的想法。&lt;/p&gt;

&lt;p&gt;　　我个人推荐的做法是：对自己狠一点，对最终用户温柔一些。精确点说是“开发和内测版本中多用攻击型技术，让故障尽早（并且可控地）被引爆。发布版本里多用防御行编程，以包​容一些非致命的问题。”&lt;/p&gt;

&lt;p&gt;　　举例来说，本文最开始的ASSERT_RETURN宏就是这种方法的一个典型：&lt;/p&gt;

&lt;p&gt;　　在开发版本（#ifdef DEBUG分支）中，启用了assert，一旦不符合研发人员的预期，就会立刻引爆，让研发能够发现问题。而发布版本中则只是做了&amp;rdquo;if return/break/continue&amp;rdquo;等，包容了错误。让程序能够正常的运行下去。&lt;/p&gt;

&lt;p&gt;　　另外在发布版本中是包容还是优雅的退出，取决于具体的问题。比如office中发现用户通过剪贴板复制过来的数据不合要求，如果此时“优雅的退出”，用户可能杀人的心都有​了。&lt;/p&gt;

&lt;h1 id=&#34;五-性能优化相关的一些想法:03abadb4947350f837a3f50c1387e0d7&#34;&gt;五、性能优化相关的一些想法&lt;/h1&gt;

&lt;p&gt;　　这个话题也是一个很庞大的话题，我只说说我个人的想法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;优化的前提是掌握了准确的性能分析数据，明确了性能瓶颈。没有进行科学的性能分析就着手进行的优化都是耍流氓。&lt;br /&gt;
  当然，开发过程中就拍脑袋想出来的“性能瓶颈”更是地球人愚蠢的想法（我自己犯过好几次，而且还是在我高举“过早优化是一切罪恶之源”大旗的情况下。最后都证明是捡了芝麻​丢了西瓜，感谢我的同事点醒了我）。&lt;br /&gt;
  开发阶段需要做的事是尽量的模块化和抽象，当后续诊断出性能瓶颈后可以很方便的替换、调优那些模块。&lt;/li&gt;
&lt;li&gt;自上而下，先考虑架构，再考虑层、模块，最后考虑底层的实现。&lt;br /&gt;
  切莫为“这个密集调用的函数里这条检查语句很复杂，可能会影响整体性能”而“优化”。首先，参考上述的1，别耍流氓。其次，优化也有收益比曲线，先优化收益比最高的那些瓶​颈，那些才是金矿。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　最后，广而告之：《代码大全》，你值得拥有。&lt;/p&gt;

&lt;h1 id=&#34;六-版本记录:03abadb4947350f837a3f50c1387e0d7&#34;&gt;六、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2014-01-05, 初始发布。&lt;/li&gt;
&lt;li&gt;v1.1 - 2014-01-12, 增加了隔栏处的新思考。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>一起疑似内存泄漏</title>
      <link>http://boxcounter.com/technique/2014-01-12-suspected-memory-leak/</link>
      <pubDate>Sun, 12 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2014-01-12-suspected-memory-leak/</guid>
      <description>&lt;p&gt;上周遇到一起极其诡异的内存泄漏。现象是：&lt;br /&gt;
某种测试方法可以使程序物理内存使用量（top命令的RES列）持续上升。当停止测试之后，程序内存使用量稳定在测试过程中的最高值不变。从现象上看就是一典型的内存泄漏。&lt;/p&gt;

&lt;p&gt;我的诊断步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用valgrind的memcheck检查泄漏。故障重现后让程序自然退出。memcheck提示资源泄漏量为0.&lt;br /&gt;
所以，该内存应该没有被泄漏，程序中对它们还有引用，在程序退出时被正常释放掉了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用valgrind的massif分析内存使用。找到了一处可疑的「泄漏」点，90%的内存都是在该处分配。&lt;br /&gt;
但是调试发现该处分配（通过malloc）的内存都被正确的释放（通过free）掉了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用malloc_info函数查看程序运行过程中的内存情况。
这是在程序物理内存占用2G后我停止测试以后一段时间（大概5分钟）的输出：&lt;/p&gt;

&lt;p&gt;arena(462848), ordblks(2), smblks(1), hblks(5), hblkhd(104857600), usmblks(0), fsmblks(32), uordblks(459424), fordblks(3424), keepcost(3360).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从上面看，从heap中申请了462848(arena的值，约46KB)，mmap申请的内存是104857600（hblkhd的值，约100MB）。这俩值加在一起和top里显示的2G差很远啊。
   注，arena和hblkhd的man注解：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; arena   The total amount of memory allocated by means other than
         mmap(2) (i.e., memory allocated on the heap).  This figure
         includes both in-use blocks and blocks on the free list.
 hblkhd  The number of bytes in blocks currently allocated using
         mmap(2).
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;决定统计内存分配释放的次数和尺寸，目的是检查是否严重失衡。因为new/delete不太好跟踪，所以只处理了malloc/free。&lt;br /&gt;
使用的方法是wrap（gcc/g++的「-Wl,&amp;ndash;wrap,malloc」选项），看了一眼glibc的源码，以在free时候得到待释放内存的尺寸。最后的结果是没有严重失衡，应该不是显式的内存释放。&lt;br /&gt;
其实这个实验原本就没有报很大的希望，一来new/delete没有照顾到，不够精确。二来如果是显式的泄漏memcheck早就报告了。但是当时没有思路了，姑且一试，看能不能找到点面包屑。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;搜索了一些资料。有些提到glibc内部使用brk和mmap来进行内存分配，其中brk可能会造成这种泄漏假象。&lt;br /&gt;
于是在程序的开始设置了M_MMAP_THRESHOLD，发现故障依然存在。&lt;/p&gt;

&lt;p&gt;mallopt(M_MMAP_THRESHOLD, 1024*1024*1024); // 1G&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原本还想在不同的模块里使用不同的堆，然后反复根据堆的尺寸细分堆，来精确定位。却发现linux下没有类似HeapCreate的函数。&lt;/p&gt;

&lt;p&gt;技穷了。于是我邀请一位同事来协助分析，在协作中我发现我犯了个错误：尝试方法5的时候，我理解反了M_MMAP_THRESHOLD的含义，于是提供错了参数。实际上应该是这样：&lt;/p&gt;

&lt;p&gt;mallopt(M_MMAP_THRESHOLD, 0);&lt;/p&gt;

&lt;p&gt;然后故障消失了。也就是说，这次的故障实际并不是我们程序实现的资源泄漏，而是glibc堆管理机制导致的「资源泄漏」。我很奇怪为什么glibc没有重用程序调用free释放掉的空间，而是继续扩充堆。这个问题值得继续琢磨。&lt;/p&gt;

&lt;p&gt;总结：本次故障的分析过程里我的粗心大意又给自己惹了大麻烦。原本思路是正确的，结果走歪了。。。 自作孽啊。。。&lt;/p&gt;

&lt;p&gt;但是，即便这个故障不是程序实现BUG所导致的，实际上还是会对程序造成不好的影响：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果调整M_MMAP_THRESHOLD让程序不「泄漏」，那么资源占用和性能会变差。原因参考帮助文档中对该参数的描述。&lt;/li&gt;
&lt;li&gt;如果放任不管，程序会不停地吃内存，并且占住不释放。我尝试让程序持续吃内存，最后稳定在3GB的物理内存（共4G）和2.6G的swap空间（共4G）的消耗。（但没有被oom killer干掉）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再琢磨琢磨吧。&lt;/p&gt;

&lt;p&gt;最后，感谢我的同事cntrump。并附上《代码大全》里的一段话，我前些天重温的时候才看过：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;23.2 &lt;strong&gt;寻找缺陷&lt;/strong&gt; - &lt;em&gt;同他人讨论问题&lt;/em&gt;&lt;br /&gt;
　　有人会把这种方法称之为“忏悔式调试”。当你向别人解释自己的程序时，常常能发现自己犯下的一些错误。举个例子，如果你向别人解释上面的关于薪水的例子，你或许会这样对别人说：&lt;br /&gt;
　　嗨，jennifer，你有空么？我现在遇到一个麻烦。这张员工薪水列表本来应当是按照顺序排列的，但里面有些名字乱序了。我原本打算看看是不是新输入的名字就会这种情况，但有时是对的，有时又不是。我向这些数据在我输入他们的时候就应当被排序，因为程序会在我输入数据的时候对其排序，然后在数据保存的时候再排一遍。等一下，不对，它没有在输入数据的时候对其排序。就是这里。程序只是粗略地对这些数据进行了排序。谢谢你，jennifer，你帮了我个大忙。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>搬家咯</title>
      <link>http://boxcounter.com/essay/2014-01-08-migration/</link>
      <pubDate>Wed, 08 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/essay/2014-01-08-migration/</guid>
      <description>&lt;p&gt;新年新气象，blog搬个家庆祝下~&lt;/p&gt;

&lt;p&gt;　　好吧，上面开玩笑的。若非不得已，我才不愿意迁移blog。之前blog系统用的是MyBB，这是个论坛系统。之所以用一个论坛系统作为blog系统，主要是我喜欢论坛的宽版面。码农经常需要贴代码，强制折行之后那个显式效果怎一个惨绝人寰了得。A总说论坛系统里MyBB还不错，比如轻巧。于是就从WordPress迁移到了MyBB。当时就希望是最后一次迁移blog，没想到过了两三年又要来这么一遭，又要脱层皮。&lt;/p&gt;

&lt;p&gt;　　这次选择jekyll也是因为A总推荐。尝试了一下，发现貌似不错，很符合码农的操作习惯。其实我更希望有一个完全支持latex或者org-mode的博客系统。前者我估计只能是个梦，毕竟latex学习成本比较高，大多数blogger都不会愿意学。org-mode貌似jekyll支持，但是搜索了一下，发现网上有人说org-mode导出的html有时候jekyll支持的并不好。所以，为了避免日后迁移到一半才发现问题再推倒重来，就放弃了这个想法。老老实实用markdown吧。不过隐约觉得markdown的貌似过于轻量了，比较担心不够用。希望这是我杞人忧天。&lt;/p&gt;

&lt;p&gt;　　无奈。再重复一次吧：希望这是最后一次迁移blog～&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2013读书小结</title>
      <link>http://boxcounter.com/essay/2014-01-01-2013%E8%AF%BB%E4%B9%A6%E5%B0%8F%E7%BB%93/</link>
      <pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/essay/2014-01-01-2013%E8%AF%BB%E4%B9%A6%E5%B0%8F%E7%BB%93/</guid>
      <description>&lt;p&gt;大概是在8月份，我突然想起要给今年读过的书建一个列表，于是拿着kindle、手机整理了一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;已完成

&lt;ul&gt;
&lt;li&gt;杂书

&lt;ul&gt;
&lt;li&gt;《细说秦汉》黎东方/王子今&lt;/li&gt;
&lt;li&gt;《细说两晋南北朝》沈起炜&lt;/li&gt;
&lt;li&gt;《吕著三国通史》吕思勉&lt;/li&gt;
&lt;li&gt;《易中天中华史：国家》易中天&lt;/li&gt;
&lt;li&gt;《易中天中华史：奠基》易中天&lt;/li&gt;
&lt;li&gt;《如果现在是历史》吴空&lt;/li&gt;
&lt;li&gt;《万历十五年》黄仁宇（3rd。毫无疑问这是一本好书，只是不太懂为什么地位那么高）&lt;/li&gt;
&lt;li&gt;《如果这是宋史 1-7》高天流云&lt;/li&gt;
&lt;li&gt;《中国史纲》张荫麟/吕思勉/蒋廷黻&lt;/li&gt;
&lt;li&gt;《MacTalk 人生元编程》池建强&lt;/li&gt;
&lt;li&gt;《看见》柴静&lt;/li&gt;
&lt;li&gt;《重说中国近代史》张鸣&lt;/li&gt;
&lt;li&gt;《三国配角演义》马伯庸&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;技术（部分缺失）

&lt;ul&gt;
&lt;li&gt;《The Art of Debugging with GDB, DDD, and Eclipse》Norman Matloff/Peter Jay Salzman&lt;/li&gt;
&lt;li&gt;《LINUX System Pogramming》Robert Love&lt;/li&gt;
&lt;li&gt;《Linux内核设计与实现》Rebert Love&lt;/li&gt;
&lt;li&gt;《Debug.Hacks中文版_深入调试的技术和工具》吉岡弘隆/大和一洋/大岩尚宏/安部東洋/吉田俊輔（只读了应用层的部分）&lt;/li&gt;
&lt;li&gt;《软件调试修炼之道》Paul Butcher（我很喜欢，但是朋友觉得一般）&lt;/li&gt;
&lt;li&gt;《程序员的自我修养》俞甲子/石凡/潘爱民（去年还是前年读了windows部分，当时没想到还会有机会把linux部分也读完 \^_\^）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;进行中

&lt;ul&gt;
&lt;li&gt;《柏杨版资治通鉴》司马光/柏杨 （目前读到刘宋末期，感谢bookworm兄制作了精排电子版）&lt;/li&gt;
&lt;li&gt;《古代汉语》王立 （自学第一册，期望每篇都能背诵）&lt;/li&gt;
&lt;li&gt;《大话设计模式》程杰&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;中断

&lt;ul&gt;
&lt;li&gt;《时间的形状》汪洁（30%）&lt;/li&gt;
&lt;li&gt;《怪诞行为学2》Dan Ariely（看了60%，后半段没吸引力）&lt;/li&gt;
&lt;li&gt;《中国哲学简史》冯友兰（看了40%，不是这块料~）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　总得来说，去年阅读总量少，技术书更少，仅读的那几本还都是下半年读的。&lt;/p&gt;

&lt;p&gt;　　新年新列表，除了还在进行中的书之外，现在排在阅读列表上的有这些：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;杂书

&lt;ul&gt;
&lt;li&gt;《易中天中华史：祖先》易中天（易先生貌似在写一套中华史，我应该每本都会读）&lt;/li&gt;
&lt;li&gt;《布局天下：中国古代军事地理大势》饶胜文&lt;/li&gt;
&lt;li&gt;《慈禧全传》高阳&lt;/li&gt;
&lt;li&gt;《胡雪岩全传》高阳&lt;/li&gt;
&lt;li&gt;《大秦帝国》孙皓晖  （3rd。之前读了两遍，都是当年在320*240的htc上完成的，500W字著作，真是难为我高度近视的双眼）&lt;/li&gt;
&lt;li&gt;《史记》司马迁 （重读，不知道第几遍，算作3rd吧）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;技术

&lt;ul&gt;
&lt;li&gt;《代码大全》Steve McConnell（3rd。推荐愿意把coding当作艺术的朋友读读）&lt;/li&gt;
&lt;li&gt;《敏捷软件开发：原则、模式与实践》Robert C. Martin&lt;/li&gt;
&lt;li&gt;《敏捷技能修炼：敏捷软件开发与设计的最佳实践》Alan Shalloway/Scott Bain/Ken Pugh/Amir Kolsky&lt;/li&gt;
&lt;li&gt;《高效程序员的45个习惯：敏捷开发修炼之道》Venkat Subramaniam/Andy Hunt&lt;/li&gt;
&lt;li&gt;《代码之美Beautiful Code》Grey Wilson&lt;/li&gt;
&lt;li&gt;《操作系统设计与实现》Andrew S. Tanenbaum/Albert S. Woodhull&lt;/li&gt;
&lt;li&gt;《操作系统：精髓与设计原理》William Stallings&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>linux、osx下搭建操作系统开发环境 v1.1</title>
      <link>http://boxcounter.com/technique/2013-11-14-linux%E3%80%81osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83_v1.1/</link>
      <pubDate>Thu, 14 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-11-14-linux%E3%80%81osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83_v1.1/</guid>
      <description>

&lt;h1 id=&#34;一-前言:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　本文档记录的内容既适用于x86也适用于x64，只是对于后者有一些环境要求。&lt;br /&gt;
　　之前开发使用的方法是：自己的引导代码+虚拟软盘。优点是搭建简单，所有代码都是自己编写，可控性强。最近想试试使用grub的引导功能，于是花了些时间琢磨。搜出来的相​关资料有不少，但是要么是grub1的，要么太过零散，要么描述太过简略。总之，没有一篇文章详细的讲述整个配置过程。所以我就在搭建的过程中顺手整理了这么一篇完整的、​完全从零开始的方法，其中每一步都有较丰富的说明。&lt;br /&gt;
　　另外，本文档介绍的方法适用于osx和linux，实际上整个过程中大部分必须使用到linux。也就是说如果要按照本文档来搭建开发环境，linuxer只需要使用自己​的linux系统就行，而osxer还得备一套linux系统（比如虚拟机）。使用linux的主要原因是我选择了ext2作为文件系统，而osx上貌似只有读写ext2​的fuse-ext2，没有用于创建ext2分区的fdisk等工具（如果同好有osx的ext2创建工具推荐，劳烦分享给我(ns.boxcounter[at]gmail.com)吧，不胜感激）。如果改用fat32就没有这个烦恼，整个过程都可以在osx下完成，因为osx的fdisk就可以创建fat32分区。&lt;/p&gt;

&lt;p&gt;　　我使用的系统、软件情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;x86 ubuntu 12.04.2/x64 ubuntu 13.10、osx 10.8.4/osx 10.9&lt;/li&gt;
&lt;li&gt;nasm 2.10.09&lt;/li&gt;
&lt;li&gt;bochs 2.6.1&lt;/li&gt;
&lt;li&gt;grub2 2.0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　如果同好使用的环境不一样，可能需要根据情况自行调整一些细节。&lt;br /&gt;
　　另外，本文提供的命令在显示时候可能会自动折行，所以复制到剪贴板中之后（在折行处）可能会有多余的空格，请同好自行删减。&lt;/p&gt;

&lt;h1 id=&#34;二-创建虚拟磁盘-并分区:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;二、创建虚拟磁盘，并分区&lt;/h1&gt;

&lt;p&gt;　　首先说明：&lt;br /&gt;
　　这里的目标磁盘的属性是：16 headers, 63 sectors per track, 512 bytes per sector。意味着每一个cylinder的大小是516096bytes（16 * 63 * 512）。&lt;br /&gt;
　　“#cylinders”表示柱面数，主要关系到磁盘大小。如果是10MB的磁盘，#cylinders=20。&lt;br /&gt;
　　需要在linux系统中进行，使用的工具是kpartx，系统默认没有自带，需要下载。&lt;/p&gt;

&lt;p&gt;　　好了，开始了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;dd if=/dev/zero of=antos.img bs=516096 count=#cylinders&lt;br /&gt;
创建虚拟磁盘。也可以使用bochs附带的bximage工具来完成。&lt;/li&gt;
&lt;li&gt;ps aux | grep loop&lt;br /&gt;
默认是搜索不到名为“[loopX]”进程的。如果有发现，那记住输出中的“[loopX]”进程。&lt;/li&gt;
&lt;li&gt;kpartx -av ./antos.img&lt;br /&gt;
挂载虚拟磁盘，可能没有输出。&lt;/li&gt;
&lt;li&gt;ps aux | grep loop&lt;br /&gt;
正常情况下，这里会发现一个名为“[loop0]”的进程。说明antos.img被挂载到了“/dev/loop0”设备上。如果前面搜索结果中已经有了“[loopX]”进程，那新增加的那个进程就是挂载的设备名。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fdisk -u -C#cylinders -S63 -H16 /dev/loop0&lt;br /&gt;
为磁盘分区。以#cylinders=20、单个分区为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# fdisk -u -C20 -S63 -H16 /dev/loop0
Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel
Building a new DOS disklabel with disk identifier 0x136d49ee.
Changes will remain in memory only, until you decide to write them.
After that, of course, the previous content won&#39;t be recoverable.


Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)


Command (m for help): o &amp;lt;&amp;lt;&amp;lt;=== Create a new empty DOS partition table
Building a new DOS disklabel with disk identifier 0x5bd665d5.
Changes will remain in memory only, until you decide to write them.
After that, of course, the previous content won&#39;t be recoverable.


Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)


Command (m for help): n &amp;lt;&amp;lt;&amp;lt;=== Create a new partition
Partition type:
p   primary (0 primary, 0 extended, 4 free)
e   extended
Select (default p): &amp;lt;&amp;lt;&amp;lt;=== 回车
Partition number (1-4, default 1): &amp;lt;&amp;lt;&amp;lt;=== 回车
First sector (2048-20159, default 2048): &amp;lt;&amp;lt;&amp;lt;=== 回车
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-20159, default 20159): &amp;lt;&amp;lt;&amp;lt;=== 回车
Using default value 20159


Command (m for help): a &amp;lt;&amp;lt;&amp;lt;=== Toggle the bootable flag (Optional)
Partition number (1-4): 1 &amp;lt;&amp;lt;&amp;lt;=== 分区1


Command (m for help): p &amp;lt;&amp;lt;&amp;lt;=== Print the partition table.


Disk /dev/loop0: 10 MB, 10321920 bytes
16 heads, 63 sectors/track, 20 cylinders, total 20160 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x5bd665d5


Device Boot      Start         End      Blocks   Id  System
/dev/loop0p1   *        2048       20159        9056   83  Linux
&amp;lt;&amp;lt;&amp;lt;=== 如果使用附录2记录的方法，需要记录Start和Blocks的值，本例子中分别是2048和9056。


Command (m for help): w &amp;lt;&amp;lt;&amp;lt;=== Write partition table to our &#39;disk&#39; and exit
The partition table has been altered!


Calling ioctl() to re-read partition table.


WARNING: Re-reading the partition table failed with error 22: Invalid argument.
The kernel still uses the old table. The new table will be used at
the next reboot or after you run partprobe(8) or kpartx(8)
Syncing disks.
&amp;lt;&amp;lt;&amp;lt;=== Ignore any errors about rereading the partition table. Since it&#39;s not a physical device we really don&#39;t care.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kpartx -dv ./antos.img&lt;br /&gt;
卸载磁盘，应该输出“loop deleted : /dev/loop0”。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kpartx -av ./antos.img&lt;br /&gt;
挂载分区磁盘，这次新创建的分区也会自动挂载。&lt;br /&gt;
正常会输出“add map loop0p1 (252:0): 0 18112 linear /dev/loop0 2048”，表示分区挂载到了“/dev/mapper/loop0p1”设备上。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mke2fs -b1024 /dev/mapper/loop0p1&lt;br /&gt;
格式化分区，&amp;rdquo;-b1024&amp;rdquo;表示使用1KB的block。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mkdir /tmp/antos&lt;br /&gt;
创建挂载目录。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mount -text2 /dev/mapper/loop0p1 /tmp/antos&lt;br /&gt;
挂载分区到目录。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ls /tmp/antos/&lt;br /&gt;
如果前面的步骤都成功，会看到名为“lost+found”的目录，说明磁盘和分区都正确的创建了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;三-安装grub2到虚拟磁盘:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;三、安装grub2到虚拟磁盘&lt;/h1&gt;

&lt;p&gt;　　假设磁盘挂载到设备“/dev/loop0”上，分区挂载到“/tmp/antos”目录下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grub-install --no-floppy --modules=&amp;quot;biosdisk part_msdos ext2 configfile normal multiboot&amp;quot; --root-directory=/tmp/antos /dev/loop0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　安装过程中可能会报警告，只要最后输出“Installation finished. No error reported.”就表示安装成功了。&lt;br /&gt;
　　如果使用的系统是x64架构的，需要使用新一些的系统，比如ubuntu 13.10。具体原因请参考附录一。&lt;br /&gt;
　　（在fedora等redhat系中使用的名称是“grub2-install”）&lt;/p&gt;

&lt;h1 id=&#34;四-在bochs中使用虚拟磁盘:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;四、在bochs中使用虚拟磁盘&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;确认虚拟磁盘的属性。&lt;br /&gt;
先挂载虚拟磁盘，然后执行“disk -u -l /dev/loop0”，正常会有如下输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 Disk /dev/loop0: 10 MB, 10321920 bytes
2 16 heads, 63 sectors/track, 20 cylinders, total 20160 sectors
3 Units = sectors of 1 * 512 = 512 bytes
4 Sector size (logical/physical): 512 bytes / 512 bytes
5 I/O size (minimum/optimal): 512 bytes / 512 bytes
6 Disk identifier: 0x6418cb2e
7
8       Device Boot      Start         End      Blocks   Id  System
9 /dev/loop0p1   *        2048       20159        9056   83  Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第2行说明了虚拟磁盘的属性。（前面使用fdisk为磁盘分区的时候也有输出同样的内容，如果记下来了，就可以不需要这一步）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建bochs虚拟机配置文件&lt;br /&gt;
不带参数运行bochs，应该会有这样的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. Restore factory default configuration
2. Read options from...
3. Edit options
4. Save options to...
5. Restore the Bochs state from...
6. Begin simulation
7. Quit now


Please choose one: [2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选择4，然后输入配置文件名，比如“antos.bxrc”，提示保存成功后退出bochs。这样就有了一份默认配置的bochs虚拟机配置文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改bochs虚拟机配置文件，以适应我们的需要&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加虚拟磁盘。&lt;br /&gt;
将这一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ata0-master: type=none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ata0-master: type=disk, path=&amp;quot;./antos.img&amp;quot;, cylinders=#cylinders,heads=#heads,spt=#sec-per-track
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应之前获取到的磁盘属性，这一行应该是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ata0-master: type=disk, path=&amp;quot;./antos.img&amp;quot;, cylinders=20,heads=16,spt=63
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改启动项为磁盘。&lt;br /&gt;
将这一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boot: floppy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boot: disk
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开启bochs的magic breakpoint。&lt;br /&gt;
将这一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;magic_break: enabled=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;magic_break: enabled=1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　到这里，就可以在bochs中运行了（命令是“bochs -f antos.bxrc”），并且看到grub2的命令提示符，如图：&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://boxcounter.com/images/2013-11-14/grub-cmdline.png&#34;/&gt;&lt;/p&gt;

&lt;h1 id=&#34;五-编写最简单的系统内核:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;五、编写最简单的系统内核&lt;/h1&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;//&lt;/span&gt; kernel.asm&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;源码&lt;/span&gt;
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;section&lt;/span&gt; .kernel]
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;bits&lt;/span&gt; 32]

load_base&lt;span style=&#34;color: #0000ff&#34;&gt; equ&lt;/span&gt; 0x100000

&lt;span style=&#34;color: #008000&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color: #008000&#34;&gt;; multiboot header&lt;/span&gt;
&lt;span style=&#34;color: #008000&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
multiboot_header:
MBH_magic&lt;span style=&#34;color: #0000ff&#34;&gt;            equ&lt;/span&gt; 0xE85250D6
MBH_architecture&lt;span style=&#34;color: #0000ff&#34;&gt;     equ&lt;/span&gt; 0            &lt;span style=&#34;color: #008000&#34;&gt;; 32-bit protected mode&lt;/span&gt;
MBH_header_length&lt;span style=&#34;color: #0000ff&#34;&gt;    equ&lt;/span&gt; multiboot_header_end - multiboot_header
MBH_checksum&lt;span style=&#34;color: #0000ff&#34;&gt;         equ&lt;/span&gt; -(MBH_header_length + MBH_magic + MBH_architecture)

&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_magic
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_architecture
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_header_length
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; MBH_checksum

&lt;span style=&#34;color: #008000&#34;&gt;; tags&lt;/span&gt;
info_request_tag:
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 1
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; info_request_tag_end - info_request_tag
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 5
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 6
info_request_tag_end:
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
address_tag:
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 2
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; address_tag_end - address_tag
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; load_base                 &lt;span style=&#34;color: #008000&#34;&gt;; header_addr&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; load_base                 &lt;span style=&#34;color: #008000&#34;&gt;; load_addr&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 0                         &lt;span style=&#34;color: #008000&#34;&gt;; load_end_addr&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 0                         &lt;span style=&#34;color: #008000&#34;&gt;; bss_end_addr&lt;/span&gt;
address_tag_end:
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
entry_address_tag:
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 3
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; entry_address_tag_end - entry_address_tag
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; load_base + kernel_entry
entry_address_tag_end:
&lt;span style=&#34;color: #0000ff&#34;&gt;align&lt;/span&gt; 8
&lt;span style=&#34;color: #008000&#34;&gt;; end tag&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dw&lt;/span&gt; 0
&lt;span style=&#34;color: #0000ff&#34;&gt;dd&lt;/span&gt; 8
multiboot_header_end:

kernel_entry:
xchg bx, bx                 &lt;span style=&#34;color: #008000&#34;&gt;; magic breakpoint&lt;/span&gt;
jmp &lt;span style=&#34;color: #0000ff&#34;&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;br /&gt;
　　编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nasm kernel.asm -o kernel.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　编译过程中可能会报警告，无视它。&lt;br /&gt;
　　将虚拟磁盘挂载到某个目录，然后将kernel.bin拷贝到分区的根目录，即和/boot目录同一层目录。&lt;/p&gt;

&lt;h1 id=&#34;六-使用grub2启动自行编写的操作系统内核:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;六、使用grub2启动自行编写的操作系统内核&lt;/h1&gt;

&lt;p&gt;　　假设分区挂载到“/tmp/antos”目录下，那么创建grub需要的配置文件“/tmp/antos/boot/grub/grub.cfg”，将以下几行文本贴进去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set default=0
insmod ext2
set root=(hd0,1)
set timeout=10
menuentry &amp;quot;antos 0.0.1&amp;quot; {
   insmod ext2
   set root=(hd0,1)
   multiboot2 (hd0,1)/kernel.bin
   boot
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　其中(hd0,1)表示咱之前创建的虚拟磁盘的第一个分区，kernel.bin就是前面编译的系统内核文件。&lt;/p&gt;

&lt;p&gt;　　现在可以启动咱的bochs虚拟机了，执行“bochs -f antos.bxrc”。&lt;br /&gt;
　　再输入c继续执行后，应该就能看到bochs从咱的虚拟磁盘引导，然后可以看见grub的选择界面，最后会中断到咱系统内核的“xchg bx, bx”指令，这是bochs内置的主动中断指令，即magic breakpoint机制。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o 00449811185i[CPU0 ] [449811185] Stopped on MAGIC BREAKPOINT
(0) Magic breakpoint
Next at t=449811185
(0) [0x000000100053] 0010:0000000000100053 (unk. ctxt): jmp .-2 (0x00100053) ; ebfe
00449811185i[XGUI ] Mouse capture off
&amp;lt;bochs:2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　ok，整个配置过程就完毕了，整个过程都是在linux中完成的。使用fat32的osx同好可以使用类似的方法来完成。整个过程每一步的功能都写的很清楚了，看到这里理​理思路应该就明白整个流程了。&lt;/p&gt;

&lt;h1 id=&#34;七-osx中读写ext2文件系统的虚拟磁盘:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;七、osx中读写ext2文件系统的虚拟磁盘&lt;/h1&gt;

&lt;p&gt;　　最后说说osx相关的内容，因为我不想每次做开发的时候都需要开个linux虚拟机。以下是在osx下读写虚拟磁盘的方法，比如更新的kernel.bin等等。linu​xer可以无视这一步。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装osxfuse和fuse-ext2&lt;br /&gt;
fuse-ext2默认只能以只读方式挂载设备，所以需要进行以下修改使其默认以可读可写方式挂载设备：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo vi /System/Library/Filesystems/fuse-ext2.fs/fuse-ext2.util
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搜索定位到Mount函数，为其名为“OPTIONS”的变量增加额外的“rw+”选项。&lt;br /&gt;
比如：原内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mount ()
{
      LogDebug &amp;quot;[Mount] Entering function Mount...&amp;quot;
      # Setting both defer_auth and defer_permissions. The option was renamed
      # starting with MacFUSE 1.0.0, and there seems to be no backward
      # compatibility on the options.
      OPTIONS=&amp;quot;auto_xattr,defer_permissions&amp;quot;
      ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Mount ()
{
      LogDebug &amp;quot;[Mount] Entering function Mount...&amp;quot;
      # Setting both defer_auth and defer_permissions. The option was renamed
      # starting with MacFUSE 1.0.0, and there seems to be no backward
      # compatibility on the options.
      OPTIONS=&amp;quot;auto_xattr,defer_permissions,rw+&amp;quot;
      ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;挂载磁盘到设备&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hdiutil attach -nomount antos.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是会输出如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dev/disk1              FDisk_partition_scheme
/dev/disk1s1            Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明虚拟磁盘已经挂载到/dev/disk1设备上了，分区已经挂载到/dev/disk1s1。（之所以加上-nomount参数，是因为hdiutil没法正确地挂载ext2分区到目录）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;挂载分区到目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sbin/mount_fuse-ext2 /dev/disk1s1 ./mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/dev/disk1s1是步骤3中得到的设备（分区)名。&lt;br /&gt;
到这里，就可以对分区内容进行修改了，比如更新kernel.bin等等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从目录卸载分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;umount ./mnt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;卸载虚拟磁盘&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hdiutil detach /dev/disk1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（注意是磁盘设备，不是分区设备disk1s1）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;八-附录一-x64-ubuntu-12-04-2中执行grub-install遇到的问题:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;八、附录一：x64 ubuntu 12.04.2中执行grub-install遇到的问题&lt;/h1&gt;

&lt;p&gt;　　我在x64 ubuntu 12.04.2中执行“安装grub2到虚拟磁盘”操作时总是失败，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@x64:~# grub-install --no-floppy --modules=&amp;quot;biosdisk part_msdos ext2 configfile normal multiboot&amp;quot; --root-directory=/tmp/antos /dev/loop0
Path `/tmp/antos/boot/grub&#39; is not readable by GRUB on boot. Installation is impossible. Aborting.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　加上&amp;ndash;deubg选项后，发现grub-install输出了这么几行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ /usr/local/sbin/grub-probe -t fs /tmp/antos/boot/grub
+ return 1
+ gettext_printf Path `%s&#39; is not readable by GRUB on boot. Installation is impossible. Aborting.\n /tmp/antos/boot/grub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　手动执行grub-probe，输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu:~# /usr/local/sbin/grub-probe -t fs /tmp/antos/boot/grub/usr/local/sbin/grub-probe: error: disk `lvm/loop0p1&#39; not found.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我查阅了很多资料，都没有明确的解决方案。经过了约莫20个小时的摸索，最终发现只需要使用新版本的系统自带的grub 2.0.0即可。（注：x64 ubuntu 12.04.2中的grub2是我源码编译的2.0.0版，也尝试过使用trunk源码编译或者使用系统自带的1.99，都会报错。）&lt;/p&gt;

&lt;h1 id=&#34;九-附录二-创建虚拟磁盘分区的另外一种方法-losetup:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;九、附录二：创建虚拟磁盘分区的另外一种方法（losetup）&lt;/h1&gt;

&lt;p&gt;　　需要说明，这种方法较前面介绍的使用kpartx的方法要繁琐，所以并不推荐（特别是如果要使用多分区）。补充在这里的原因是我最开始搜索到的资料使用的就是losetu​p工具，摸索成功之后才发现kpartx。&lt;br /&gt;
　　另外，操作过程中有部分步骤和前面讲述的步骤一样，所以省略了那些步骤的说明。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;dd if=/dev/zero of=antos.img bs=516096 count=#cylinders&lt;/li&gt;
&lt;li&gt;losetup /dev/loop0 ./antos.img&lt;br /&gt;
这个时候执行“ps aux | grep loop”，会看到一个名为[loop0]的进程。（如果loop0被占用，可以换一个设备）&lt;/li&gt;
&lt;li&gt;fdisk -u -C#cylinders -S63 -H16 /dev/loop0&lt;/li&gt;
&lt;li&gt;losetup /dev/loop0 ./antos.img&lt;br /&gt;
这个时候执行“ps aux | grep loop”，会看到一个名为[loop0]的进程。（如果loop0被占用，可以换一个设备）&lt;/li&gt;
&lt;li&gt;losetup -d /dev/loop0&lt;br /&gt;
到这里，虚拟磁盘已经创建完毕了，从设备（“loop0”）上卸载虚拟磁盘，准备格式化。&lt;/li&gt;
&lt;li&gt;losetup -o1048576 /dev/loop0 ./antos.img&lt;br /&gt;
再次挂载，与前面挂载不同的是，这次使用了“-o1048576”参数，目的是跳过前1048576字节，来到分区的开始。前面提到要记住Start的值，即分区开始扇区号，这里就需要使用它了，1048576=20​48*512。&lt;/li&gt;
&lt;li&gt;mke2fs -b1024 /dev/loop0 9056&lt;br /&gt;
对加载到“loop0”设备上的*分区*（注意是分区，不是整个磁盘了，前面咱跳到了分区开始处）进行格式化，使用的是ext2文件系统。&lt;br /&gt;
”-b1024“表示使用1KB的block，9056就是之前的Blocks的值，即整个分区的blocks数。&lt;/li&gt;
&lt;li&gt;mkdir /tmp/antos&lt;/li&gt;
&lt;li&gt;mount -text2 /dev/loop0 /tmp/antos&lt;/li&gt;
&lt;li&gt;umount /dev/loop0&lt;/li&gt;
&lt;li&gt;losetup -d /dev/loop0&lt;br /&gt;
卸载目录和设备。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;十-主要参考资料:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;十、主要参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The Multiboot Specification&lt;/li&gt;
&lt;li&gt;grub2源码&lt;/li&gt;
&lt;li&gt;Mac OS X下读写ext2/ext3文件系统&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;十一-版本记录:31a30a92cbf0de02e916cc20c8b8ad92&#34;&gt;十一、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-09-02，初始发布。&lt;/li&gt;
&lt;li&gt;v1.1 - 2013-11-14，增加x64系统下的说明。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-11-14/linux、osx下搭建操作系统开发环境的完整步骤_v1.1.pdf&#34;&gt;2013-11-14-linux、osx下搭建操作系统开发环境_v1.1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下搭建操作系统开发环境之64位交叉开发工具集（gcc&#43;gdb）v1.0</title>
      <link>http://boxcounter.com/technique/2013-11-08-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B64%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.0/</link>
      <pubDate>Fri, 08 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-11-08-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B64%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.0/</guid>
      <description>

&lt;h1 id=&#34;一-前言:a48ba76a4646a20561a3efada380ccda&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　《&lt;a href=&#34;http://boxcounter.com/2013/11/04/osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B32%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc+gdb%EF%BC%89v1.1&#34;&gt;osx下搭建操作系统开发环境之32位交叉开发工具集(gcc+gdb)&lt;/a&gt;》一文中讲解了32位交叉工具的构建。64位（专指x64，非IA64）的构建方法和32位基本相同。看过前文的朋友看本文会发现绝大多数内容都是一样的。没错，之所以不基于前文、只讲差异，是为了独立性，方便只关注x64构建方法的朋友。&lt;br /&gt;
　　我的环境：osx 10.9&lt;/p&gt;

&lt;h1 id=&#34;二-安装osx版的gcc:a48ba76a4646a20561a3efada380ccda&#34;&gt;二、安装osx版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;brew install gcc48
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　推荐下载最新的稳定版gcc。&lt;/p&gt;

&lt;h1 id=&#34;三-配置编译环境:a48ba76a4646a20561a3efada380ccda&#34;&gt;三、配置编译环境&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;下载gcc源码&lt;br /&gt;
根据参考资料1的建议，最好使用最新的gcc来进行编译，被编译的源码也推荐使用一样版本的。也就是说，用gcc 4.8.2来编译gcc 4.8.2的源码。&lt;br /&gt;
下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gcc&#34;&gt;源码包&lt;/a&gt;并解压，得到的目录名称之为“$gcc-4.8.2”。&lt;/li&gt;
&lt;li&gt;下载gcc依赖项&lt;br /&gt;
需要的依赖项有：

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gnu.org/software/binutils/&#34;&gt;GNU Binutils&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gmplib.org/&#34;&gt;GMP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mpfr.org/&#34;&gt;MPFR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://multiprecision.org/&#34;&gt;MPC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将它们都解压出来，把解压出来的b、c、d的目录都放到gcc源码目录下。都需要去掉版本号，比如解压出来的目录名为“mpc-1.0.1”，那么现在就是“$gcc-4.8.2/mpc”。a无需这么做，因为它需要单独编译，参考后续的步骤4。&lt;br /&gt;
   其中GMP源码包是lzip压缩格式，需要下载lzip工具解压（brew安装）。
3. 下载gdb源码&lt;br /&gt;
   下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gdb&#34;&gt;源码包&lt;/a&gt;并解压，得到的目录名称之为“$gdb-7.6.1”。
4. 设置环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export CC=/usr/local/bin/gcc-4.8
    export CXX=/usr/local/bin/g++-4.8
    export CPP=/usr/local/bin/cpp-4.8
    export LD=/usr/local/bin/gcc-4.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都是brew版gcc4.8.2的软链接。如果不设置，那么会使用系统中默认自带的工具，这些工具的版本可能比较老。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export PREFIX=$HOME/opt/cross
    export TARGET=x86_64-pc-linux-gnu
    export PATH=&amp;quot;$PREFIX/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是编译时候使用的选项。需要注意的是：osdev上的《&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler_for_x86_64&#34;&gt;GCC Cross-Compiler for x86 64&lt;/a&gt;》建议将TARGET宏定义为x86_64-elf，但是我实验发现这样行不通，编译gdb的时候会报错“configure: error: configuration x86_64-pc-elf is unsupported.”。
5. 编译交叉版的binutils&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    cd $binutils-x.y.z
    mkdir build-binutils
    cd build-binutils
    ../configure --target=$TARGET --prefix=$PREFIX --enable-64-bit-bfd --enable-werror=no
    make
    make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;四-编译交叉版的gcc:a48ba76a4646a20561a3efada380ccda&#34;&gt;四、编译交叉版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gcc-4.8.2
mkdir build-gcc
cd build-gcc
../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls --enable-languages=c,c++ --without-headers
make all-gcc
make all-target-libgcc
make install-gcc
make install-target-libgcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后，在“~/opt/cross/bin”下就能看到编译好的交叉版的编译套件了，包括“x86_64-pc-linux-gnu-gcc”、“x86_64-pc-linux-gnu-g++”和“x86_64-pc-linux-gnu-ld ”等等。可以用“$HOME/opt/cross/bin/$TARGET-gcc &amp;ndash;version”来验证一下版本是否正确。&lt;br /&gt;
　　另外，为了方便使用，可以在.bashrc或者.zshrc中调整环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=&amp;quot;$HOME/opt/cross/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;五-编译交叉版的gdb:a48ba76a4646a20561a3efada380ccda&#34;&gt;五、编译交叉版的gdb&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gdb-7.6.1
mkdir build-$TARGET
cd build-$TARGET
../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls --enable-64-bit-bfd --enable-werror=no CFLAGS=&amp;quot;-m64&amp;quot;
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后，在“~/opt/cross/bin”下就能看到编译好的交叉版的x86_64-pc-linux-gnu-gdb了。&lt;/p&gt;

&lt;p&gt;　　注：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;和x64的bochs配合调试的时候，需要切换到x86-64模式（默认模式是i386）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) set architecture i386:x86-64
The target architecture is assumed to be i386:x86-64
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在这个编译选项版本之前，我尝试了好几种其他的编译选项，虽然都能编译出gdb，但是都无法与x64的bochs进行配合调试。包括使用“../configure &amp;ndash;enable-targets=all &amp;ndash;enable-64-bit-bfd”。无法与x64的bochs进行配合调试的现象是，gdb能够下断，但是中断点都是错误的，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) target remote localhost:1234
Remote debugging using 192.168.1.16:1234
0x00000000 in ?? ()
(gdb) b *0x7c00
Breakpoint 1 at 0x7c00
(gdb) c
Continuing.
Program received signal SIGTRAP, Trace/breakpoint trap.
0x000e0000 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常应该是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) target remote 192.168.1.16:1234
Remote debugging using localhost:1234
0x000000000000fff0 in ?? ()
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结，gdb的TARGET要和bochs（而非被调试OS）的平台一致，即如果使用的是x64的bochs，那么gdb的编译TARGET也需要是x64的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;六-参考资料:a48ba76a4646a20561a3efada380ccda&#34;&gt;六、参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler&#34;&gt;GCC Cross-Compiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler_for_x86_64&#34;&gt;GCC Cross-Compiler for x86 64&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.utah.edu/~manua/sim_doc/simics-reference-manual-public-all/topic96.html&#34;&gt;gdb-remote&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sourceforge.net/p/bochs/discussion/39592/thread/a489c7f1&#34;&gt;bochs + GDB help&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;七-版本记录:a48ba76a4646a20561a3efada380ccda&#34;&gt;七、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-11-08，初始发布。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-11-08/osx下搭建操作系统开发环境之64位交叉开发工具集（gcc+gdb）v1.0.pdf&#34;&gt;osx下搭建操作系统开发环境之64位交叉开发工具集（gcc+gdb）v1.0.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下搭建操作系统开发环境之构建bochs v1.0</title>
      <link>http://boxcounter.com/technique/2013-11-05-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B%E6%9E%84%E5%BB%BAbochs_v1.0/</link>
      <pubDate>Tue, 05 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-11-05-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B%E6%9E%84%E5%BB%BAbochs_v1.0/</guid>
      <description>

&lt;h1 id=&#34;一-前言:29112401aeca7f6da9b81a38b0dff7ac&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　我编译bochs的目的是为了启用gdb调试功能。bochs提供的调试器功能较简单，开发过程中还是gdb更趁手。本文记录的方法是我一点点尝试出来的，参考了网上一些零碎资料。整个过程虽然简单但是整体比较凌乱，特别是需要对bochs的官方源码包做好几处修改。目前不太想再花时间优化过程，能编译出来就好。如果有同好有更简单的方法，有劳和我分享一下吧。&lt;br /&gt;
　　我的环境：osx 10.9，bochs 2.6.2、使用x11作为界面库。&lt;/p&gt;

&lt;h1 id=&#34;二-安装x11:29112401aeca7f6da9b81a38b0dff7ac&#34;&gt;二、安装X11&lt;/h1&gt;

&lt;p&gt;　　下载&lt;a href=&#34;http://xquartz.macosforge.org/trac&#34;&gt;XQuartz&lt;/a&gt;安装包，并安装。&lt;/p&gt;

&lt;h1 id=&#34;三-配置编译环境:29112401aeca7f6da9b81a38b0dff7ac&#34;&gt;三、配置编译环境&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;export CC=/usr/bin/gcc
export CXX=/usr/bin/g++
export CPP=/usr/bin/cpp
export LD=/usr/bin/g++
export CFLAGS=-I/usr/X11/include
export PREFIX=/Users/boxcounter/opt/bochs-gdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　根据我的试验，使用brew安装的gcc编译会报错，使用系统自带的就可以正常编译，所以调整了CC等环境变量。PREFIX宏请根据需要自行修改。&lt;/p&gt;

&lt;h1 id=&#34;四-编译bochs:29112401aeca7f6da9b81a38b0dff7ac&#34;&gt;四、编译bochs&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;下载&lt;a href=&#34;http://sourceforge.net/projects/bochs/files/bochs/&#34;&gt;源码包&lt;/a&gt;并解压，解压出来的目录名称之为“$bochs”。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改.conf.macosx&lt;br /&gt;
根据需要修改configure的参数，比如以下是我使用的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --enable-disasm \
            --disable-docbook \
            --enable-x86-64 \
            --enable-pci \
            --enable-all-optimizations \
            --enable-plugins \
            --enable-cdrom \
            --enable-a20-pin \
            --enable-fpu \
            --enable-alignment-check \
            --enable-large-ramfile \
            --enable-readline \
            --enable-iodebug \
            --enable-xpm \
            --enable-show-ips \
            --enable-logging \
            --enable-usb \
            --enable-ne2000 \
            --enable-cpu-level=6 \
            --enable-sb16 \
            --enable-clgd54xx \
            --with-term \
            --enable-ne2000 \
            --with-x11 \
            --enable-idle-hack \
            --enable-gdb-stub \
            --prefix=${PREFIX} \
            ${CONFIGURE_ARGS}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;chmod u+x ./.conf.macosx &amp;amp;&amp;amp; ./.conf.macosx&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改ldtl相关选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将$bochs/config.h中的“BX_HAVE_LTDL”宏的定义由1改为0，只有一处。&lt;/li&gt;
&lt;li&gt;将$bochs/Makefile中的“-lltdl”改为“ltdl.o”，有多处。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调整gui模块的编译选项&lt;br /&gt;
将$bochs/gui/Makefile中的“X_LIBS =  -lXpm -lXrandr”修改为“X_LIBS = -L/usr/X11/lib -lXpm -lXrandr”&lt;br /&gt;
如果不进行此项修改，在gui目录下进行链接的时候总会报错，提示无法找到Xmp库。使用LDFLAGS环境变量或者修改.conf.macosx中的LDFLAGS都没有用，因为gui模块链接过程中并没有使用到它们。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make &amp;amp;&amp;amp; make install&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;五-参考资料:29112401aeca7f6da9b81a38b0dff7ac&#34;&gt;五、参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sourceforge.net/p/bochs/discussion/39592/thread/9c22887c&#34;&gt;No rule to make target `-lltdl&amp;rsquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;六-版本记录:29112401aeca7f6da9b81a38b0dff7ac&#34;&gt;六、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-11-05，初始发布。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-11-05/osx下搭建操作系统开发环境之构建bochs_v1.0.pdf&#34;&gt;osx下搭建操作系统开发环境之构建bochs_v1.0.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下搭建操作系统开发环境之32位交叉开发工具集（gcc&#43;gdb）v1.1</title>
      <link>http://boxcounter.com/technique/2013-09-07-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B32%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.1/</link>
      <pubDate>Mon, 04 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-09-07-osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B32%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86%EF%BC%88gcc&#43;gdb%EF%BC%89v1.1/</guid>
      <description>

&lt;h1 id=&#34;一-前言:1fb642315dd7f0464840b224b39a5096&#34;&gt;一、前言&lt;/h1&gt;

&lt;p&gt;　　《&lt;a href=&#34;http://boxcounter.com/2013/11/14/linux%E3%80%81osx%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83_v1.1&#34;&gt;linux、osx下搭建操作系统开发环境的完整步骤&lt;/a&gt;》一文中讲解了一些基本的搭建方法，并提供了一个nasm汇编编写的简单的系统内核源码。实际开发过程中更多使用的是C语言，就需要有一个配套的C编译器。因为我使用的可执行文件是elf格式，所以我选择的是GCC。但是osx下安装的GCC生成的是osx的可执行文件格式，并不是elf。所以我需要一个能在osx下生成elf的GCC，俗称的交叉编译器。&lt;br /&gt;
　　我的环境：osx 10.8.4 &amp;amp; 10.9&lt;/p&gt;

&lt;h1 id=&#34;二-安装osx版的gcc:1fb642315dd7f0464840b224b39a5096&#34;&gt;二、安装osx版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;brew install gcc48
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　推荐下载最新的稳定版gcc。&lt;/p&gt;

&lt;h1 id=&#34;三-配置编译环境:1fb642315dd7f0464840b224b39a5096&#34;&gt;三、配置编译环境&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;下载gcc源码&lt;br /&gt;
根据&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler&#34; title=&#34;「GCC Cross-Compiler」&#34;&gt;参考资料1&lt;/a&gt;的建议，最好使用最新的gcc来进行编译，被编译的源码也推荐使用一样版本的。也就是说，用gcc 4.8.1来编译gcc 4.8.1的源码。&lt;br /&gt;
下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gcc/&#34;&gt;源码包&lt;/a&gt;并解压，得到的目录名称之为「$gcc-4.8.1」。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载依赖项&lt;br /&gt;
需要的依赖项有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://gnu.org/software/binutils/&#34;&gt;GNU Binutils&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gmplib.org/&#34;&gt;GMP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mpfr.org/&#34;&gt;MPFR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://multiprecision.org/&#34;&gt;MPC&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将它们都解压出来，把解压出来的2、3、4的目录都放到gcc源码目录下。都需要去掉版本号，比如解压出来的目录名为「mpc-1.0.1」，那么现在就是「$gcc-4.8.1/mpc」。1无需这么做，因为它需要单独编译，参考后续的步骤4。&lt;br /&gt;
   其中GMP源码包是lzip压缩格式，需要下载lzip工具解压（brew安装）。
3. 下载 gdb 源码&lt;br /&gt;
   下载&lt;a href=&#34;http://ftp.gnu.org/gnu/gdb/&#34;&gt;源码包&lt;/a&gt;并解压,得到的目录名称之为「$gdb-7.6.1」。
4. 设置环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export CC=/usr/local/bin/gcc-4.8
    export CXX=/usr/local/bin/g++-4.8
    export CPP=/usr/local/bin/cpp-4.8
    export LD=/usr/local/bin/gcc-4.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都是brew版gcc4.8.1的软链接。如果不设置，那么会使用系统中默认自带的工具，这些工具版本都很陈旧。比如osx 10.8.4带的/usr/bin/gcc是4.2版本的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    export PREFIX=$HOME/opt/cross
    export TARGET=i586-elf
    export PATH=&amp;quot;$PREFIX/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是编译时候使用的选项。
5. 编译交叉版的binutils&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    cd $binutils-x.y.z
    mkdir build-binutils
    cd build-binutils
    ../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls
    make
    make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;四-编译交叉版的gcc:1fb642315dd7f0464840b224b39a5096&#34;&gt;四、编译交叉版的gcc&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gcc-4.8.1
mkdir build-gcc
cd build-gcc
../configure --target=$TARGET --prefix=&amp;quot;$PREFIX&amp;quot; --disable-nls --enable-languages=c,c++ --without-headers
make all-gcc
make all-target-libgcc
make install-gcc
make install-target-libgcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后，在「~/opt/cross/bin」下就能看到编译好的交叉版的编译套件了，包括「i586-elf-gcc」、「i586-elf-g++」和「i586-elf-ld」等等。可以用「$HOME/opt/cross/bin/$TARGET-gcc &amp;ndash;version」来验证一下版本是否正确。&lt;br /&gt;
　　另外，为了方便使用，可以在.bashrc或者.zshrc中调整环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=&amp;quot;$HOME/opt/cross/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;五-测试源码:1fb642315dd7f0464840b224b39a5096&#34;&gt;五、测试源码&lt;/h1&gt;

&lt;p&gt;　　现在咱有了交叉编译器了，试试效果吧：
&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000&#34;&gt;// kernel.c&lt;/span&gt;
&lt;span style=&#34;color: #0000ff&#34;&gt;#include &amp;quot;multiboot2.h&amp;quot;&lt;/span&gt;


&lt;span style=&#34;color: #0000ff&#34;&gt;#define INFO_REQ_COUNT  2&lt;/span&gt;

&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header_tag_information_request
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header_tag_information_request info_req __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
    &lt;span style=&#34;color: #2b91af&#34;&gt;multiboot_uint32_t&lt;/span&gt; req[INFO_REQ_COUNT];
} __attribute__((packed));


&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header header __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header_tag_information_request info_req __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
    &lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header_tag end __attribute__((aligned(MULTIBOOT_TAG_ALIGN)));
} __attribute__((packed));


&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header amb =
{
    {
        MULTIBOOT2_HEADER_MAGIC,
        MULTIBOOT_ARCHITECTURE_I386,
        &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header),
        -(MULTIBOOT2_HEADER_MAGIC + MULTIBOOT_ARCHITECTURE_I386 + &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header))
    },

    {
        {
            MULTIBOOT_HEADER_TAG_INFORMATION_REQUEST,
            MULTIBOOT_HEADER_TAG_OPTIONAL,
            &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; antos_multiboot_header_tag_information_request)
        },
        MULTIBOOT_TAG_TYPE_BASIC_MEMINFO,
        MULTIBOOT_TAG_TYPE_FRAMEBUFFER
    },

    {
        MULTIBOOT_HEADER_TAG_END,
        MULTIBOOT_HEADER_TAG_OPTIONAL,
        &lt;span style=&#34;color: #0000ff&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color: #0000ff&#34;&gt;struct&lt;/span&gt; multiboot_header_tag)
    }
};


&lt;span style=&#34;color: #2b91af&#34;&gt;void&lt;/span&gt; breakpoint()
{
    &lt;span style=&#34;color: #0000ff&#34;&gt;asm&lt;/span&gt;(&lt;span style=&#34;color: #a31515&#34;&gt;&amp;quot;xchg %bx, %bx&amp;quot;&lt;/span&gt;);
}


&lt;span style=&#34;color: #2b91af&#34;&gt;int&lt;/span&gt; _start()
{
    breakpoint();
    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;　　multiboot2.h头文件是从grub2.0.0的源码里拷贝过来的，主要定义了符合multiboot2规范的数据结构。&lt;br /&gt;
　　编译方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/opt/cross/bin/i586-elf-gcc -c -o kernel.o kernel.c
~/opt/cross/bin/i586-elf-ld -Ttext=0x100000 -o kernel.bin kernel.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　「-Ttext=0x100000」是为了让代码段加载到0x100000，而不是默认的08048074（我的环境中），后者超出我的bochs虚拟机的物理内存空间。&lt;br /&gt;
　　然后用kernel.bin替换之前的虚拟磁盘中的同名文件，再运行bochs虚拟机就能看到熟悉的magic breakpoint了。&lt;/p&gt;

&lt;h1 id=&#34;六-编译交叉版的-gdb:1fb642315dd7f0464840b224b39a5096&#34;&gt;六、编译交叉版的 gdb&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;cd $gdb-7.6.1
mkdir build-$TARGET
cd build-$TARGET
../configure --target=$TARGET --prefix=$PREFIX --disable-nls
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　完成后,在「~/opt/cross/bin」下就能看到编译好的交叉版的i586-elf-gdb 了。&lt;/p&gt;

&lt;h1 id=&#34;七-参考资料:1fb642315dd7f0464840b224b39a5096&#34;&gt;七、参考资料&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.osdev.org/GCC_Cross-Compiler&#34;&gt;GCC Cross-Compiler&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;八-版本记录:1fb642315dd7f0464840b224b39a5096&#34;&gt;八、版本记录&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v1.0 - 2013-09-07，初始发布。&lt;/li&gt;
&lt;li&gt;v1.1 - 2013-11-04，增加「编译交叉版的gdb」章节。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;九-网友补充:1fb642315dd7f0464840b224b39a5096&#34;&gt;九、网友补充&lt;/h1&gt;

&lt;p&gt;以下内容为热心网友补充，供同好参考。（我没有验证。暂记录在这里，后续验证过后我再补入正文。感谢这位网友被我之前老博客系统的验证码刁难了N次后，还依然告知我，非常感谢。）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;OSX10.9下使用gcc4.8编译binutils-2.24会报错：nm.c:1687:7: error: &amp;lsquo;sbrk&amp;rsquo; is deprecated (declared at /usr/include/unistd.h:582)&lt;br /&gt;
需要使用gcc4.9，编译时指定编译参数CFLAGS=-Wno-error=deprecated-declarations&lt;br /&gt;
gcc的依赖项GMP/FPMR/MPC也不需要手动下载，在gcc的源码下执行./contrib/download_prerequisites即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文的pdf版：&lt;a href=&#34;http://boxcounter.com/attachments/2013-09-17/osx下搭建操作系统开发环境之32位交叉开发工具集（gcc+gdb）v1.1.pdf&#34;&gt;osx下搭建操作系统开发环境之32位交叉开发工具集（gcc+gdb）v1.1.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下为timeoutfree添加定时任务</title>
      <link>http://boxcounter.com/technique/2013-08-14-osx%E4%B8%8B%E4%B8%BAtimeoutfree%E6%B7%BB%E5%8A%A0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Wed, 14 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-08-14-osx%E4%B8%8B%E4%B8%BAtimeoutfree%E6%B7%BB%E5%8A%A0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid>
      <description>&lt;p&gt;我习惯使用休息提醒软件定时提醒我站起来扭扭腰，目前使用的是“Time Out Free”，挺好用的一款免费软件。&lt;/p&gt;

&lt;p&gt;　　但是使用过程中我有一个用着不够爽的地方：&lt;br /&gt;
　　下班回家后或者周末，我基本是躺着或者趴在床上用电脑，不需要再提醒我。但是它没有提供时间段配置，于是我用了定时任务来实现了，如下：&lt;/p&gt;

&lt;p&gt;　　下载附件“timeoutfree.sh”，加上执行权限。然后在终端中输入“crontab -e”编辑个人的定时任务，在里面添加如下两行（路径根据情况调整）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*/20    9-10    *   *   1-5 /Users/boxcounter/timeoutfree.sh start
*/20    18-23   *   *   1-5 /Users/boxcounter/timeoutfree.sh stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　然后保存退出，终端应该会输出“crontab: installing new crontab”，说明添加定时任务成功了。&lt;/p&gt;

&lt;p&gt;　　说明：&lt;br /&gt;
　　第一行的意思是：工作日每天早上9～11点这两个小时内，每隔20分钟尝试一次启动TimeOutFree。&lt;br /&gt;
　　第二行的意思是：工作日每天晚上18～24点这几个小时内，每隔20分钟尝试一次关闭TimeOutFree。&lt;/p&gt;

&lt;p&gt;　　附件：&lt;/p&gt;

&lt;p&gt;　　（脚本可能看起来很麻烦，是我随手找了个守护程序的脚本改的。）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>osx下解决emacs执行中文路径命令出错的方法</title>
      <link>http://boxcounter.com/technique/2013-08-08-osx%E4%B8%8B%E8%A7%A3%E5%86%B3emacs%E6%89%A7%E8%A1%8C%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E5%91%BD%E4%BB%A4%E5%87%BA%E9%94%99%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 12 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2013-08-08-osx%E4%B8%8B%E8%A7%A3%E5%86%B3emacs%E6%89%A7%E8%A1%8C%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E5%91%BD%E4%BB%A4%E5%87%BA%E9%94%99%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;我第一次发现这个问题是在使用auctex编译中文名tex文件的时候发现的，后来发现不仅仅是auctex，M－!执行shell命令中如果包含中文路径或文件名也失败，最后搜了一些资料测试了几种，发现了这个解决方案。&lt;/p&gt;

&lt;p&gt;在emacs配置文件中增加如下一行：&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;(set-language-environment &lt;span style=&#34;color: #a31515&#34;&gt;&amp;#39;utf-8&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;话说，测试了好几种方法才解决的，一高兴忘了记下出处。惭愧惭愧，谢谢那位我记不得的博主吧。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;后记2013-08-14：&lt;/p&gt;

&lt;p&gt;发现会影响vc-mode（svn1.8），导致提交中文修改纪录时报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emacs svn: E000022: Can&#39;t convert string from native encoding to &#39;UTF-8&#39;:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;暂未处理，后续处理了再补在这里。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>戏谈红颜祸水之夏姬</title>
      <link>http://boxcounter.com/essay/2013-08-08-%E6%88%8F%E8%B0%88%E7%BA%A2%E9%A2%9C%E7%A5%B8%E6%B0%B4%E4%B9%8B%E5%A4%8F%E5%A7%AC/</link>
      <pubDate>Thu, 08 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/essay/2013-08-08-%E6%88%8F%E8%B0%88%E7%BA%A2%E9%A2%9C%E7%A5%B8%E6%B0%B4%E4%B9%8B%E5%A4%8F%E5%A7%AC/</guid>
      <description>&lt;p&gt;故事要从春秋 &lt;strong&gt;郑国&lt;/strong&gt; 讲起，郑国有个美公主，嫁给了陈国的夏御叔，因此被称为夏姬。夏姬生了一个儿子唤做征叔。夏御叔壮年去世，留下孤儿寡母。夏姬不耐寂寞勾搭上了 &lt;strong&gt;陈国&lt;/strong&gt; 国君和两位大臣。有一天这三爷们在夏家喝酒，国君指着征叔对其中一个大臣说：“这孩子像你”。大臣也戏谑：“这孩子也像你”。正好征叔听到这段，忍无可忍射杀了国君。当时陈附楚， &lt;strong&gt;楚国&lt;/strong&gt; 发兵攻陈杀了征叔。到此陈国内事暂告一段落，下面是楚国。&lt;/p&gt;

&lt;p&gt;　　夏姬被虏到楚国，楚王想收编，被大臣申公巫臣一番大道理给劝阻了。另一大臣也想收编夏姬，又被申公巫臣一番道理给驳了。后来夏姬落在另一个大臣怀里。没多久这位大臣也去世了（亡于战场）。然后这大臣的儿子（偷偷地）收编了夏姬。（是不是感觉有点乱了？耐心往下看～）这个时候申公巫臣出现了，暗中和夏姬搭上线，允诺会娶她，然后找了个机会把夏姬安排回了郑国。隔了段时间，申公巫臣也找了个机会逃出楚国，带着夏姬跑到了 &lt;strong&gt;晋国&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;　　前面提到的那位原想收编夏姬但被驳的大臣不乐意了，联合了和申公巫臣有矛盾的另一位大臣找了个由头把申公巫臣一族给屠了。申公巫臣怒了，开始琢磨复仇计划。正好晋国那些年和楚国交战不利，正愁着怎么办，申公巫臣就提议联和楚国背后的 &lt;strong&gt;吴国&lt;/strong&gt; 一起抗楚。晋国国君同意，于是申公巫臣就跑到吴国，撺掇吴王抗楚。吴王一直都很头疼怎么抵抗楚国，因为吴国在下游、楚在上游，当时作战都是水战，逆流太吃亏，吴一直都处于被欺负的状态。申公巫臣就传授吴王步兵野战，整军经武之后吴国军力强了，就开始不停的伐楚，最后攻入楚郢都才罢休。害得楚王不得不迁都。&lt;/p&gt;

&lt;p&gt;　　楚国虽幅员辽阔、经济富庶，但也耐不住晋吴两头折腾。于是也照猫画虎去撺掇吴国背后的 &lt;strong&gt;越国&lt;/strong&gt; （这是在吴攻入郢都之前就开始的）。越国挺卖力，弄死了那位攻入郢都的吴王（大名鼎鼎的阖闾）。后任的吴王夫差又复仇几乎灭了越。再后面就是越王勾践卧薪尝胆、鸟尽弓藏、范蠡西施逍遥泛舟的故事，我就不啰嗦了。&lt;/p&gt;

&lt;p&gt;　　怎一个乱字了得。&lt;/p&gt;

&lt;p&gt;　　除夏姬之外还有不少红颜搅得国与国之间乌烟瘴气，比如文姜，有兴趣的自行google吧。&lt;/p&gt;

&lt;p&gt;　　参考资料：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;《中国史纲》张荫麟/吕思勉/蒋廷黻&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zh.wikipedia.org/wiki/%E5%A4%8F%E5%A7%AC&#34;&gt;夏姬的维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>内核资源泄漏样本之一</title>
      <link>http://boxcounter.com/technique/2012-11-02-%E5%86%85%E6%A0%B8%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E6%A0%B7%E6%9C%AC%E4%B9%8B%E4%B8%80/</link>
      <pubDate>Fri, 02 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://boxcounter.com/technique/2012-11-02-%E5%86%85%E6%A0%B8%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E6%A0%B7%E6%9C%AC%E4%B9%8B%E4%B8%80/</guid>
      <description>

&lt;p&gt;又遇到一个很好玩的内核资源泄漏样本，分享一下。&lt;br /&gt;
某台WinXP sp3系统出现了死机现象，该现象是在安装了我的驱动后才出现的，第一反应是“MD，怎么又泄漏了”。&lt;br /&gt;
以下是分析过程：&lt;/p&gt;

&lt;h1 id=&#34;poolused的输出:d0f14dd6c2c81221381bb269dedb95d3&#34;&gt;!poolused的输出&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; !poolused 2

Sorting by NonPaged Pool Consumed

           NonPaged                  Paged
Tag     Allocs         Used     Allocs         Used

tsni     62403     33947232          0            0 UNKNOWN pooltag &#39;tsni&#39;, please update pooltag.txt
FMvo     21652     21825376          0            0 FLT_VOLUME structure , Binary: fltmgr.sys
SBcx     10828     11780864          0            0 UNKNOWN pooltag &#39;SBcx&#39;, please update pooltag.txt
Devi     32861     10905648          0            0 Device objects 
FMis     10841      6503328          0            0 FLT_INSTANCE structure , Binary: fltmgr.sys
Drti     10844      5899136          0            0 UNKNOWN pooltag &#39;Drti&#39;, please update pooltag.txt
FMrr     21682      2425184          0            0 Per-processor Cache-aware rundown ref structure , Binary: fltmgr.sys
FMct     10841      2339864          0            0 TRACK_COMPLETION_NODES structure , Binary: fltmgr.sys
Tef2       220      2242016          0            0 UNKNOWN pooltag &#39;Tef2&#39;, please update pooltag.txt
WPSd       278      1677896          0            0 UNKNOWN pooltag &#39;WPSd&#39;, please update pooltag.txt
MmCm        30       963440          0            0 Calls made to MmAllocateContiguousMemory , Binary: nt!mm
Pp       10822       779184        287        33456 UNKNOWN pooltag &#39;Pp  &#39;, please update pooltag.txt
DmaB        34       729088          0            0 UNKNOWN pooltag &#39;DmaB&#39;, please update pooltag.txt
Io       16786       693632        156         6480 general IO allocations , Binary: nt!io
Thre      1033       661120          0            0 Thread objects , Binary: nt!ps
File      3038       465648          0            0 File objects 
FMwi     10831       433240          0            0 Work item structures , Binary: fltmgr.sys
iAEC       183       361992          0            0 UNKNOWN pooltag &#39;iAEC&#39;, please update pooltag.txt
SEY4      2970       332752          0            0 UNKNOWN pooltag &#39;SEY4&#39;, please update pooltag.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见fltmgr的卷相关资源占用特别严重（tag名以&amp;rdquo;FM&amp;rdquo;开头的几项，如&amp;rdquo;FMvo&amp;rdquo;和&amp;rdquo;FMi&amp;rdquo;等）&lt;br /&gt;
fltmgr.sys是微软的文件过滤驱动，一般可以排除由它导致资源泄漏的可能性。于是想到可能是基于fltmgr的minifilter驱动引起此故障。&lt;br /&gt;
于是继续列举系统中目前以存在的minifilter驱动。&lt;/p&gt;

&lt;h1 id=&#34;fltkd-filters的输出:d0f14dd6c2c81221381bb269dedb95d3&#34;&gt;!fltkd.filters的输出&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; !fltkd.filters

Filter List: 8999805c &amp;quot;Frame 1&amp;quot; 
   FLT_FILTER: 897e5ba8 &amp;quot;SEyeFilter&amp;quot; &amp;quot;382020&amp;quot;
      FLT_INSTANCE: 89965510 &amp;quot;SEyeFilter - Top Instance&amp;quot; &amp;quot;382020&amp;quot;
      FLT_INSTANCE: 89964b50 &amp;quot;SEyeFilter - Top Instance&amp;quot; &amp;quot;382020&amp;quot;
   FLT_FILTER: 89e8be68 &amp;quot;SPBBCDrv&amp;quot; &amp;quot;365100&amp;quot;
      FLT_INSTANCE: 89987420 &amp;quot;SPBBCDrv&amp;quot; &amp;quot;365100&amp;quot;
      FLT_INSTANCE: 89984008 &amp;quot;SPBBCDrv&amp;quot; &amp;quot;365100&amp;quot;
   FLT_FILTER: 89e4aba8 &amp;quot;eeCtrl&amp;quot; &amp;quot;329010&amp;quot;
      FLT_INSTANCE: 89ec5c28 &amp;quot;eeCtrl&amp;quot; &amp;quot;329010&amp;quot;
      FLT_INSTANCE: 899ba008 &amp;quot;eeCtrl&amp;quot; &amp;quot;329010&amp;quot;
   FLT_FILTER: 89ab9568 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
      FLT_INSTANCE: 89981de0 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
      FLT_INSTANCE: 89982270 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
      FLT_INSTANCE: 896dd780 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
      FLT_INSTANCE: 896be9d8 &amp;quot;SRTSP&amp;quot; &amp;quot;329000&amp;quot;
   FLT_FILTER: 893e0e30 &amp;quot;vfsmfd&amp;quot; &amp;quot;263410&amp;quot;
      FLT_INSTANCE: 893f6008 &amp;quot;VEAI&amp;quot; &amp;quot;263400&amp;quot;
      FLT_INSTANCE: 89649008 &amp;quot;VEAI&amp;quot; &amp;quot;263400&amp;quot;
      FLT_INSTANCE: 895ee008 &amp;quot;VEAI&amp;quot; &amp;quot;263400&amp;quot;
      FLT_INSTANCE: 895f0008 &amp;quot;VEAI&amp;quot; &amp;quot;263400&amp;quot;
      FLT_INSTANCE: 893f67c0 &amp;quot;Default&amp;quot; &amp;quot;263410&amp;quot;
   FLT_FILTER: 8971bb58 &amp;quot;WavxDMgr&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 89cf58b0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 8997b400 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 896de608 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 896d7998 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 89230cf0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 87018878 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 870076a8 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 87018b30 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 870032d0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 8700e970 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 87003008 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 87003580 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 86fffdb0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      FLT_INSTANCE: 86ff02d0 &amp;quot;WavxDMgr Instance&amp;quot; &amp;quot;145300&amp;quot;
      ... 省略若干重复输出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现WavxDmgr这个minifilter对卷设备进行了上万次的挂载（有上万条“FLT_INSTANCE: XXXXXXXX &amp;ldquo;WavxDMgr Instance&amp;rdquo; &amp;ldquo;145300&amp;rdquo;”），&lt;br /&gt;
因此占用了大量的Nonpaged Pool资源。有理由猜测某种操作触发了WavxDmgr的BUG，导致它疯狂的进行挂载操作，最终导致系统资源耗尽而死机。&lt;/p&gt;

&lt;p&gt;以“WavxDmgr”为关键字搜索，可以找到这么一篇文章：&lt;a href=&#34;http://www.novell.com/zh-cn/documentation/zenworks11/readme/data/readme_zenworks11sp2.html&#34;&gt;Novell ZENworks 11 SP2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中有一段相关的说明：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2.6.3 数据加密与 Tablet PC 上的 Dell ControlPoint Security Manager 不兼容&lt;br /&gt;
如果将数据加密策略应用到使用 Dell ControlPoint Security Manager 的 Tablet PC，设备将无法重引导到操作系统。&lt;br /&gt;
此问题是因 Dell ControlPoint Security Manager 驱动程序 (WavxDMgr.sys) 过渡使用文件系统堆栈所致。对于任何使用名称解析且晚于该安全管理器驱动程序装载的文件系统过滤器驱动程序，都可能会发生同样的结果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而我的驱动正好符合“使用名称解析且晚于该安全管理器驱动程序装载的文件系统过滤器驱动程序”，于是触发了WavxDmgr的资源泄漏BUG。&lt;/p&gt;

&lt;h1 id=&#34;验证:d0f14dd6c2c81221381bb269dedb95d3&#34;&gt;验证&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;0: kd&amp;gt; !for_each_module s -a @#Base @#End &amp;quot;tsni&amp;quot;
a7e0f300  74 73 6e 69 14 02 00 00-68 c9 54 80 50 c9 54 80  tsni....h.T.P.T.
a7e10ba3  74 73 6e 69 68 14 02 00-00 53 53 53 68 e0 f2 e0  tsnih....SSSh...

0: kd&amp;gt; lm a a7e0f300
start    end        module name
a7ddb000 a7e14180   WavxDMgr   (deferred)             

0: kd&amp;gt; lm a a7e10ba3
start    end        module name
a7ddb000 a7e14180   WavxDMgr   (deferred)             

0: kd&amp;gt; !for_each_module s -a @#Base @#End &amp;quot;SBcx&amp;quot;
a7e0e114  53 42 63 78 00 00 00 00-00 00 00 00 00 00 00 00  SBcx............

0: kd&amp;gt; lm a a7e0e114
start    end        module name
a7ddb000 a7e14180   WavxDMgr   (deferred)             

0: kd&amp;gt; !for_each_module s -a @#Base @#End &amp;quot;Drti&amp;quot;
a7dde5ad  44 72 74 69 68 18 02 00-00 6a 00 ff 15 e8 df e0  Drtih....j......

0: kd&amp;gt; lm a a7dde5ad
start    end        module name
a7ddb000 a7e14180   WavxDMgr   (deferred)             
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是这厮！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>